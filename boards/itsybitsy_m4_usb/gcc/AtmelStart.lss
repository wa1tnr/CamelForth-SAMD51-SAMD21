
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004dd4  00004000  00004000  00004000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00008dd4  00008dd4  00008dd4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00001680  20000000  00008ddc  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bkupram      00000000  47000000  47000000  00011680  2**0
                  CONTENTS
  4 .qspi         00000000  04000000  04000000  00011680  2**0
                  CONTENTS
  5 .bss          00002c58  20001680  0000a45c  00011680  2**2
                  ALLOC
  6 .stack        0000c000  200042d8  0000d0b4  00011680  2**0
                  ALLOC
  7 .ARM.attributes 0000002e  00000000  00000000  00011680  2**0
                  CONTENTS, READONLY
  8 .comment      0000007f  00000000  00000000  000116ae  2**0
                  CONTENTS, READONLY
  9 .debug_info   0001910c  00000000  00000000  0001172d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00003074  00000000  00000000  0002a839  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006eaa  00000000  00000000  0002d8ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000908  00000000  00000000  00034757  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00001318  00000000  00000000  0003505f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  000080ce  00000000  00000000  00036377  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000bc42  00000000  00000000  0003e445  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000e1120  00000000  00000000  0004a087  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00001bd4  00000000  00000000  0012b1a8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00004000 <exception_table>:
    4000:	d8 02 01 20 f1 5b 00 00 ed 5b 00 00 ed 5b 00 00     ... .[...[...[..
    4010:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 00 00 00 00     .[...[...[......
	...
    402c:	ed 5b 00 00 ed 5b 00 00 00 00 00 00 ed 5b 00 00     .[...[.......[..
    403c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    404c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    405c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    406c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    407c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    408c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    409c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    40ac:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    40bc:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    40cc:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    40dc:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 00 00 00 00     .[...[...[......
	...
    40f4:	01 55 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .U...[...[...[..
    4104:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    4114:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    4124:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    4134:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    4144:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    4154:	ed 5b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     .[..............
	...
    4180:	d1 53 00 00 d9 53 00 00 e1 53 00 00 e9 53 00 00     .S...S...S...S..
    4190:	00 00 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .....[...[...[..
    41a0:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    41b0:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    41c0:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    41d0:	ed 5b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     .[..............
	...
    41ec:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
	...
    420c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    421c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    422c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    423c:	ed 5b 00 00 00 00 00 00 ed 5b 00 00 ed 5b 00 00     .[.......[...[..
    424c:	ed 5b 00 00 ed 5b 00 00 ed 5b 00 00 ed 5b 00 00     .[...[...[...[..
    425c:	ed 5b 00 00 00 00 00 00                             .[......

00004264 <__do_global_dtors_aux>:
    4264:	b510      	push	{r4, lr}
    4266:	4c05      	ldr	r4, [pc, #20]	; (427c <__do_global_dtors_aux+0x18>)
    4268:	7823      	ldrb	r3, [r4, #0]
    426a:	b933      	cbnz	r3, 427a <__do_global_dtors_aux+0x16>
    426c:	4b04      	ldr	r3, [pc, #16]	; (4280 <__do_global_dtors_aux+0x1c>)
    426e:	b113      	cbz	r3, 4276 <__do_global_dtors_aux+0x12>
    4270:	4804      	ldr	r0, [pc, #16]	; (4284 <__do_global_dtors_aux+0x20>)
    4272:	f3af 8000 	nop.w
    4276:	2301      	movs	r3, #1
    4278:	7023      	strb	r3, [r4, #0]
    427a:	bd10      	pop	{r4, pc}
    427c:	20001680 	.word	0x20001680
    4280:	00000000 	.word	0x00000000
    4284:	00008ddc 	.word	0x00008ddc

00004288 <frame_dummy>:
    4288:	b508      	push	{r3, lr}
    428a:	4b03      	ldr	r3, [pc, #12]	; (4298 <frame_dummy+0x10>)
    428c:	b11b      	cbz	r3, 4296 <frame_dummy+0xe>
    428e:	4903      	ldr	r1, [pc, #12]	; (429c <frame_dummy+0x14>)
    4290:	4803      	ldr	r0, [pc, #12]	; (42a0 <frame_dummy+0x18>)
    4292:	f3af 8000 	nop.w
    4296:	bd08      	pop	{r3, pc}
    4298:	00000000 	.word	0x00000000
    429c:	20001684 	.word	0x20001684
    42a0:	00008ddc 	.word	0x00008ddc

000042a4 <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    42a4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    42a8:	4617      	mov	r7, r2
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    42aa:	780a      	ldrb	r2, [r1, #0]
    42ac:	f3c2 1341 	ubfx	r3, r2, #5, #2
    42b0:	2b01      	cmp	r3, #1
{
    42b2:	4680      	mov	r8, r0
    42b4:	460c      	mov	r4, r1
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    42b6:	d153      	bne.n	4360 <cdcdf_acm_req+0xbc>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
    42b8:	4b2c      	ldr	r3, [pc, #176]	; (436c <cdcdf_acm_req+0xc8>)
    42ba:	8889      	ldrh	r1, [r1, #4]
    42bc:	7818      	ldrb	r0, [r3, #0]
    42be:	4288      	cmp	r0, r1
    42c0:	461e      	mov	r6, r3
    42c2:	d002      	beq.n	42ca <cdcdf_acm_req+0x26>
    42c4:	785b      	ldrb	r3, [r3, #1]
    42c6:	428b      	cmp	r3, r1
    42c8:	d14a      	bne.n	4360 <cdcdf_acm_req+0xbc>
		if (req->bmRequestType & USB_EP_DIR_IN) {
    42ca:	0613      	lsls	r3, r2, #24
    42cc:	88e5      	ldrh	r5, [r4, #6]
    42ce:	d50f      	bpl.n	42f0 <cdcdf_acm_req+0x4c>
	if (USB_DATA_STAGE == stage) {
    42d0:	2f01      	cmp	r7, #1
    42d2:	d032      	beq.n	433a <cdcdf_acm_req+0x96>
	switch (req->bRequest) {
    42d4:	7863      	ldrb	r3, [r4, #1]
    42d6:	2b21      	cmp	r3, #33	; 0x21
    42d8:	d112      	bne.n	4300 <cdcdf_acm_req+0x5c>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    42da:	2d07      	cmp	r5, #7
    42dc:	d143      	bne.n	4366 <cdcdf_acm_req+0xc2>
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
    42de:	4924      	ldr	r1, [pc, #144]	; (4370 <cdcdf_acm_req+0xcc>)
    42e0:	2300      	movs	r3, #0
    42e2:	462a      	mov	r2, r5
			return usbdc_xfer(ep, ctrl_buf, len, false);
    42e4:	4640      	mov	r0, r8
    42e6:	4c23      	ldr	r4, [pc, #140]	; (4374 <cdcdf_acm_req+0xd0>)
    42e8:	47a0      	blx	r4
			return cdcdf_acm_set_req(ep, req, stage);
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
    42ea:	b002      	add	sp, #8
    42ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    42f0:	4b21      	ldr	r3, [pc, #132]	; (4378 <cdcdf_acm_req+0xd4>)
    42f2:	4798      	blx	r3
	switch (req->bRequest) {
    42f4:	7863      	ldrb	r3, [r4, #1]
    42f6:	2b20      	cmp	r3, #32
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    42f8:	4601      	mov	r1, r0
	switch (req->bRequest) {
    42fa:	d004      	beq.n	4306 <cdcdf_acm_req+0x62>
    42fc:	2b22      	cmp	r3, #34	; 0x22
    42fe:	d023      	beq.n	4348 <cdcdf_acm_req+0xa4>
		return ERR_INVALID_ARG;
    4300:	f06f 000c 	mvn.w	r0, #12
    4304:	e7f1      	b.n	42ea <cdcdf_acm_req+0x46>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    4306:	2d07      	cmp	r5, #7
    4308:	d12d      	bne.n	4366 <cdcdf_acm_req+0xc2>
		if (USB_SETUP_STAGE == stage) {
    430a:	b917      	cbnz	r7, 4312 <cdcdf_acm_req+0x6e>
			return usbdc_xfer(ep, ctrl_buf, len, false);
    430c:	463b      	mov	r3, r7
    430e:	462a      	mov	r2, r5
    4310:	e7e8      	b.n	42e4 <cdcdf_acm_req+0x40>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    4312:	6800      	ldr	r0, [r0, #0]
    4314:	9000      	str	r0, [sp, #0]
    4316:	798b      	ldrb	r3, [r1, #6]
    4318:	888a      	ldrh	r2, [r1, #4]
    431a:	f88d 3006 	strb.w	r3, [sp, #6]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    431e:	6933      	ldr	r3, [r6, #16]
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    4320:	f8ad 2004 	strh.w	r2, [sp, #4]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    4324:	b95b      	cbnz	r3, 433e <cdcdf_acm_req+0x9a>
				usbd_cdc_line_coding = line_coding_tmp;
    4326:	4b12      	ldr	r3, [pc, #72]	; (4370 <cdcdf_acm_req+0xcc>)
    4328:	9800      	ldr	r0, [sp, #0]
    432a:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    432e:	f89d 2006 	ldrb.w	r2, [sp, #6]
    4332:	f8c6 0006 	str.w	r0, [r6, #6]
    4336:	8099      	strh	r1, [r3, #4]
    4338:	719a      	strb	r2, [r3, #6]
		return ERR_NONE;
    433a:	2000      	movs	r0, #0
    433c:	e7d5      	b.n	42ea <cdcdf_acm_req+0x46>
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    433e:	4668      	mov	r0, sp
    4340:	4798      	blx	r3
    4342:	2800      	cmp	r0, #0
    4344:	d1ef      	bne.n	4326 <cdcdf_acm_req+0x82>
    4346:	e7f8      	b.n	433a <cdcdf_acm_req+0x96>
		usbdc_xfer(0, NULL, 0, 0);
    4348:	2300      	movs	r3, #0
    434a:	461a      	mov	r2, r3
    434c:	4619      	mov	r1, r3
    434e:	4618      	mov	r0, r3
    4350:	4d08      	ldr	r5, [pc, #32]	; (4374 <cdcdf_acm_req+0xd0>)
    4352:	47a8      	blx	r5
		if (NULL != cdcdf_acm_notify_state) {
    4354:	6973      	ldr	r3, [r6, #20]
    4356:	2b00      	cmp	r3, #0
    4358:	d0ef      	beq.n	433a <cdcdf_acm_req+0x96>
			cdcdf_acm_notify_state(req->wValue);
    435a:	8860      	ldrh	r0, [r4, #2]
    435c:	4798      	blx	r3
    435e:	e7ec      	b.n	433a <cdcdf_acm_req+0x96>
		return ERR_NOT_FOUND;
    4360:	f06f 0009 	mvn.w	r0, #9
    4364:	e7c1      	b.n	42ea <cdcdf_acm_req+0x46>
			return ERR_INVALID_DATA;
    4366:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    436a:	e7be      	b.n	42ea <cdcdf_acm_req+0x46>
    436c:	2000169c 	.word	0x2000169c
    4370:	200016a2 	.word	0x200016a2
    4374:	00005de5 	.word	0x00005de5
    4378:	00006205 	.word	0x00006205

0000437c <cdcdf_acm_ctrl>:
	switch (ctrl) {
    437c:	2901      	cmp	r1, #1
{
    437e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4382:	4615      	mov	r5, r2
	switch (ctrl) {
    4384:	d054      	beq.n	4430 <cdcdf_acm_ctrl+0xb4>
    4386:	d307      	bcc.n	4398 <cdcdf_acm_ctrl+0x1c>
		return ERR_INVALID_ARG;
    4388:	2902      	cmp	r1, #2
    438a:	bf0c      	ite	eq
    438c:	f06f 001a 	mvneq.w	r0, #26
    4390:	f06f 000c 	mvnne.w	r0, #12
}
    4394:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return cdcdf_acm_enable(drv, (struct usbd_descriptors *)param);
    4398:	6887      	ldr	r7, [r0, #8]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    439a:	f8df 8104 	ldr.w	r8, [pc, #260]	; 44a0 <cdcdf_acm_ctrl+0x124>
	ifc = desc->sod;
    439e:	6810      	ldr	r0, [r2, #0]
    43a0:	463e      	mov	r6, r7
		if (NULL == ifc) {
    43a2:	b910      	cbnz	r0, 43aa <cdcdf_acm_ctrl+0x2e>
			return ERR_NOT_FOUND;
    43a4:	f06f 0009 	mvn.w	r0, #9
    43a8:	e7f4      	b.n	4394 <cdcdf_acm_ctrl+0x18>
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    43aa:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    43ac:	7882      	ldrb	r2, [r0, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    43ae:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    43b2:	2b02      	cmp	r3, #2
    43b4:	d1f6      	bne.n	43a4 <cdcdf_acm_ctrl+0x28>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    43b6:	7833      	ldrb	r3, [r6, #0]
    43b8:	429a      	cmp	r2, r3
    43ba:	d062      	beq.n	4482 <cdcdf_acm_ctrl+0x106>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    43bc:	2bff      	cmp	r3, #255	; 0xff
    43be:	d163      	bne.n	4488 <cdcdf_acm_ctrl+0x10c>
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    43c0:	f806 2b01 	strb.w	r2, [r6], #1
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    43c4:	2205      	movs	r2, #5
    43c6:	6869      	ldr	r1, [r5, #4]
    43c8:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 44a4 <cdcdf_acm_ctrl+0x128>
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    43cc:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 44a8 <cdcdf_acm_ctrl+0x12c>
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    43d0:	47c0      	blx	r8
    43d2:	4604      	mov	r4, r0
		while (NULL != ep) {
    43d4:	b97c      	cbnz	r4, 43f6 <cdcdf_acm_ctrl+0x7a>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
    43d6:	682b      	ldr	r3, [r5, #0]
    43d8:	6869      	ldr	r1, [r5, #4]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
    43da:	7818      	ldrb	r0, [r3, #0]
    43dc:	2204      	movs	r2, #4
    43de:	4418      	add	r0, r3
    43e0:	47c0      	blx	r8
	for (i = 0; i < 2; i++) {
    43e2:	1cbb      	adds	r3, r7, #2
    43e4:	b2f2      	uxtb	r2, r6
    43e6:	b2db      	uxtb	r3, r3
    43e8:	429a      	cmp	r2, r3
    43ea:	d1da      	bne.n	43a2 <cdcdf_acm_ctrl+0x26>
	_cdcdf_acm_funcd.enabled = true;
    43ec:	4b29      	ldr	r3, [pc, #164]	; (4494 <cdcdf_acm_ctrl+0x118>)
    43ee:	2201      	movs	r2, #1
    43f0:	715a      	strb	r2, [r3, #5]
	return ERR_NONE;
    43f2:	4620      	mov	r0, r4
    43f4:	e7ce      	b.n	4394 <cdcdf_acm_ctrl+0x18>
	return (ptr[0] + (ptr[1] << 8));
    43f6:	7961      	ldrb	r1, [r4, #5]
    43f8:	7922      	ldrb	r2, [r4, #4]
			ep_desc.bEndpointAddress = ep[2];
    43fa:	f894 a002 	ldrb.w	sl, [r4, #2]
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43fe:	4b26      	ldr	r3, [pc, #152]	; (4498 <cdcdf_acm_ctrl+0x11c>)
    4400:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    4404:	b292      	uxth	r2, r2
    4406:	78e1      	ldrb	r1, [r4, #3]
    4408:	4650      	mov	r0, sl
    440a:	4798      	blx	r3
    440c:	2800      	cmp	r0, #0
    440e:	d13e      	bne.n	448e <cdcdf_acm_ctrl+0x112>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    4410:	f01a 0f80 	tst.w	sl, #128	; 0x80
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
    4414:	bf14      	ite	ne
    4416:	f886 a001 	strbne.w	sl, [r6, #1]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    441a:	f887 a004 	strbeq.w	sl, [r7, #4]
				usb_d_ep_enable(func_data->func_ep_out);
    441e:	4650      	mov	r0, sl
    4420:	47c8      	blx	r9
			desc->sod = ep;
    4422:	602c      	str	r4, [r5, #0]
	return (desc + usb_desc_len(desc));
    4424:	7820      	ldrb	r0, [r4, #0]
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    4426:	6869      	ldr	r1, [r5, #4]
    4428:	4420      	add	r0, r4
    442a:	47d8      	blx	fp
    442c:	4604      	mov	r4, r0
    442e:	e7d1      	b.n	43d4 <cdcdf_acm_ctrl+0x58>
		return cdcdf_acm_disable(drv, (struct usbd_descriptors *)param);
    4430:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    4432:	b12a      	cbz	r2, 4440 <cdcdf_acm_ctrl+0xc4>
		ifc_desc.bInterfaceClass = desc->sod[5];
    4434:	6813      	ldr	r3, [r2, #0]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
    4436:	795b      	ldrb	r3, [r3, #5]
    4438:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    443c:	2b02      	cmp	r3, #2
    443e:	d1b1      	bne.n	43a4 <cdcdf_acm_ctrl+0x28>
		if (func_data->func_iface[i] == 0xFF) {
    4440:	7823      	ldrb	r3, [r4, #0]
    4442:	2bff      	cmp	r3, #255	; 0xff
    4444:	d007      	beq.n	4456 <cdcdf_acm_ctrl+0xda>
			if (func_data->func_ep_in[i] != 0xFF) {
    4446:	78a0      	ldrb	r0, [r4, #2]
			func_data->func_iface[i] = 0xFF;
    4448:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    444a:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    444c:	7025      	strb	r5, [r4, #0]
			if (func_data->func_ep_in[i] != 0xFF) {
    444e:	d002      	beq.n	4456 <cdcdf_acm_ctrl+0xda>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    4450:	4b12      	ldr	r3, [pc, #72]	; (449c <cdcdf_acm_ctrl+0x120>)
    4452:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    4454:	70a5      	strb	r5, [r4, #2]
		if (func_data->func_iface[i] == 0xFF) {
    4456:	7863      	ldrb	r3, [r4, #1]
    4458:	2bff      	cmp	r3, #255	; 0xff
    445a:	d007      	beq.n	446c <cdcdf_acm_ctrl+0xf0>
			if (func_data->func_ep_in[i] != 0xFF) {
    445c:	78e0      	ldrb	r0, [r4, #3]
			func_data->func_iface[i] = 0xFF;
    445e:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    4460:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    4462:	7065      	strb	r5, [r4, #1]
			if (func_data->func_ep_in[i] != 0xFF) {
    4464:	d002      	beq.n	446c <cdcdf_acm_ctrl+0xf0>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    4466:	4b0d      	ldr	r3, [pc, #52]	; (449c <cdcdf_acm_ctrl+0x120>)
    4468:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    446a:	70e5      	strb	r5, [r4, #3]
	if (func_data->func_ep_out != 0xFF) {
    446c:	7920      	ldrb	r0, [r4, #4]
    446e:	28ff      	cmp	r0, #255	; 0xff
    4470:	d003      	beq.n	447a <cdcdf_acm_ctrl+0xfe>
		usb_d_ep_deinit(func_data->func_ep_out);
    4472:	4b0a      	ldr	r3, [pc, #40]	; (449c <cdcdf_acm_ctrl+0x120>)
    4474:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    4476:	23ff      	movs	r3, #255	; 0xff
    4478:	7123      	strb	r3, [r4, #4]
	_cdcdf_acm_funcd.enabled = false;
    447a:	4b06      	ldr	r3, [pc, #24]	; (4494 <cdcdf_acm_ctrl+0x118>)
    447c:	2000      	movs	r0, #0
    447e:	7158      	strb	r0, [r3, #5]
    4480:	e788      	b.n	4394 <cdcdf_acm_ctrl+0x18>
				return ERR_ALREADY_INITIALIZED;
    4482:	f06f 0011 	mvn.w	r0, #17
    4486:	e785      	b.n	4394 <cdcdf_acm_ctrl+0x18>
				return ERR_NO_RESOURCE;
    4488:	f06f 001b 	mvn.w	r0, #27
    448c:	e782      	b.n	4394 <cdcdf_acm_ctrl+0x18>
				return ERR_NOT_INITIALIZED;
    448e:	f06f 0013 	mvn.w	r0, #19
    4492:	e77f      	b.n	4394 <cdcdf_acm_ctrl+0x18>
    4494:	2000169c 	.word	0x2000169c
    4498:	00005835 	.word	0x00005835
    449c:	00005895 	.word	0x00005895
    44a0:	00005539 	.word	0x00005539
    44a4:	000058c1 	.word	0x000058c1
    44a8:	00005553 	.word	0x00005553

000044ac <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
    44ac:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    44ae:	4b0a      	ldr	r3, [pc, #40]	; (44d8 <cdcdf_acm_init+0x2c>)
    44b0:	4798      	blx	r3
    44b2:	2801      	cmp	r0, #1
    44b4:	d80c      	bhi.n	44d0 <cdcdf_acm_init+0x24>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
    44b6:	4809      	ldr	r0, [pc, #36]	; (44dc <cdcdf_acm_init+0x30>)
    44b8:	4b09      	ldr	r3, [pc, #36]	; (44e0 <cdcdf_acm_init+0x34>)
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
    44ba:	e9c0 3007 	strd	r3, r0, [r0, #28]

	usbdc_register_function(&_cdcdf_acm);
    44be:	3018      	adds	r0, #24
    44c0:	4b08      	ldr	r3, [pc, #32]	; (44e4 <cdcdf_acm_init+0x38>)
    44c2:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
    44c4:	2001      	movs	r0, #1
    44c6:	4908      	ldr	r1, [pc, #32]	; (44e8 <cdcdf_acm_init+0x3c>)
    44c8:	4b08      	ldr	r3, [pc, #32]	; (44ec <cdcdf_acm_init+0x40>)
    44ca:	4798      	blx	r3
	return ERR_NONE;
    44cc:	2000      	movs	r0, #0
}
    44ce:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    44d0:	f06f 0010 	mvn.w	r0, #16
    44d4:	e7fb      	b.n	44ce <cdcdf_acm_init+0x22>
    44d6:	bf00      	nop
    44d8:	00006211 	.word	0x00006211
    44dc:	2000169c 	.word	0x2000169c
    44e0:	0000437d 	.word	0x0000437d
    44e4:	000061b9 	.word	0x000061b9
    44e8:	20000000 	.word	0x20000000
    44ec:	00006131 	.word	0x00006131

000044f0 <cdcdf_acm_read>:

/**
 * \brief USB CDC ACM Function Read Data
 */
int32_t cdcdf_acm_read(uint8_t *buf, uint32_t size)
{
    44f0:	b410      	push	{r4}
/**
 * \brief Check whether CDC ACM Function is enabled
 */
bool cdcdf_acm_is_enabled(void)
{
	return _cdcdf_acm_funcd.enabled;
    44f2:	4c08      	ldr	r4, [pc, #32]	; (4514 <cdcdf_acm_read+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    44f4:	7963      	ldrb	r3, [r4, #5]
{
    44f6:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    44f8:	b13b      	cbz	r3, 450a <cdcdf_acm_read+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    44fa:	4601      	mov	r1, r0
    44fc:	7920      	ldrb	r0, [r4, #4]
    44fe:	4c06      	ldr	r4, [pc, #24]	; (4518 <cdcdf_acm_read+0x28>)
    4500:	2300      	movs	r3, #0
    4502:	46a4      	mov	ip, r4
}
    4504:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    4508:	4760      	bx	ip
}
    450a:	f06f 0010 	mvn.w	r0, #16
    450e:	f85d 4b04 	ldr.w	r4, [sp], #4
    4512:	4770      	bx	lr
    4514:	2000169c 	.word	0x2000169c
    4518:	00005de5 	.word	0x00005de5

0000451c <cdcdf_acm_write>:
{
    451c:	b410      	push	{r4}
	return _cdcdf_acm_funcd.enabled;
    451e:	4c08      	ldr	r4, [pc, #32]	; (4540 <cdcdf_acm_write+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    4520:	7963      	ldrb	r3, [r4, #5]
{
    4522:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    4524:	b13b      	cbz	r3, 4536 <cdcdf_acm_write+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    4526:	4601      	mov	r1, r0
    4528:	78e0      	ldrb	r0, [r4, #3]
    452a:	4c06      	ldr	r4, [pc, #24]	; (4544 <cdcdf_acm_write+0x28>)
    452c:	2301      	movs	r3, #1
    452e:	46a4      	mov	ip, r4
}
    4530:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    4534:	4760      	bx	ip
}
    4536:	f06f 0010 	mvn.w	r0, #16
    453a:	f85d 4b04 	ldr.w	r4, [sp], #4
    453e:	4770      	bx	lr
    4540:	2000169c 	.word	0x2000169c
    4544:	00005de5 	.word	0x00005de5

00004548 <cdcdf_acm_register_callback>:
{
    4548:	b508      	push	{r3, lr}
    454a:	460a      	mov	r2, r1
	switch (cb_type) {
    454c:	2803      	cmp	r0, #3
    454e:	d814      	bhi.n	457a <cdcdf_acm_register_callback+0x32>
    4550:	e8df f000 	tbb	[pc, r0]
    4554:	100d0902 	.word	0x100d0902
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    4558:	4b09      	ldr	r3, [pc, #36]	; (4580 <cdcdf_acm_register_callback+0x38>)
    455a:	7918      	ldrb	r0, [r3, #4]
    455c:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    455e:	4b09      	ldr	r3, [pc, #36]	; (4584 <cdcdf_acm_register_callback+0x3c>)
    4560:	4798      	blx	r3
	return ERR_NONE;
    4562:	2000      	movs	r0, #0
}
    4564:	bd08      	pop	{r3, pc}
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    4566:	4b06      	ldr	r3, [pc, #24]	; (4580 <cdcdf_acm_register_callback+0x38>)
    4568:	2102      	movs	r1, #2
    456a:	78d8      	ldrb	r0, [r3, #3]
    456c:	e7f7      	b.n	455e <cdcdf_acm_register_callback+0x16>
		cdcdf_acm_set_line_coding = (cdcdf_acm_set_line_coding_t)func;
    456e:	4b04      	ldr	r3, [pc, #16]	; (4580 <cdcdf_acm_register_callback+0x38>)
    4570:	6119      	str	r1, [r3, #16]
    4572:	e7f6      	b.n	4562 <cdcdf_acm_register_callback+0x1a>
		cdcdf_acm_notify_state = (cdcdf_acm_notify_state_t)func;
    4574:	4b02      	ldr	r3, [pc, #8]	; (4580 <cdcdf_acm_register_callback+0x38>)
    4576:	6159      	str	r1, [r3, #20]
    4578:	e7f3      	b.n	4562 <cdcdf_acm_register_callback+0x1a>
		return ERR_INVALID_ARG;
    457a:	f06f 000c 	mvn.w	r0, #12
    457e:	e7f1      	b.n	4564 <cdcdf_acm_register_callback+0x1c>
    4580:	2000169c 	.word	0x2000169c
    4584:	00005a5d 	.word	0x00005a5d

00004588 <cdcdf_acm_is_enabled>:
}
    4588:	4b01      	ldr	r3, [pc, #4]	; (4590 <cdcdf_acm_is_enabled+0x8>)
    458a:	7958      	ldrb	r0, [r3, #5]
    458c:	4770      	bx	lr
    458e:	bf00      	nop
    4590:	2000169c 	.word	0x2000169c

00004594 <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    4594:	4b04      	ldr	r3, [pc, #16]	; (45a8 <_sbrk+0x14>)
    4596:	6819      	ldr	r1, [r3, #0]
{
    4598:	4602      	mov	r2, r0
	if (heap == NULL) {
    459a:	b909      	cbnz	r1, 45a0 <_sbrk+0xc>
		heap = (unsigned char *)&_end;
    459c:	4903      	ldr	r1, [pc, #12]	; (45ac <_sbrk+0x18>)
    459e:	6019      	str	r1, [r3, #0]
	}
	prev_heap = heap;
    45a0:	6818      	ldr	r0, [r3, #0]

	heap += incr;
    45a2:	4402      	add	r2, r0
    45a4:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
}
    45a6:	4770      	bx	lr
    45a8:	200016c0 	.word	0x200016c0
    45ac:	200102d8 	.word	0x200102d8

000045b0 <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    45b0:	2000      	movs	r0, #0
    45b2:	4770      	bx	lr

000045b4 <_usb_d_dev_wait_dfll_rdy>:
}

static inline bool hri_oscctrl_get_DFLLCTRLB_MODE_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    45b4:	4b07      	ldr	r3, [pc, #28]	; (45d4 <_usb_d_dev_wait_dfll_rdy+0x20>)
    45b6:	f893 2020 	ldrb.w	r2, [r3, #32]
/**
 * \brief Wait DFLL clock to be ready
 */
static inline void _usb_d_dev_wait_dfll_rdy(void)
{
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(OSCCTRL)) {
    45ba:	07d1      	lsls	r1, r2, #31
    45bc:	d506      	bpl.n	45cc <_usb_d_dev_wait_dfll_rdy+0x18>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    45be:	691a      	ldr	r2, [r3, #16]
	tmp &= mask;
    45c0:	f402 6210 	and.w	r2, r2, #2304	; 0x900
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
    45c4:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
    45c8:	d1f9      	bne.n	45be <_usb_d_dev_wait_dfll_rdy+0xa>
    45ca:	4770      	bx	lr
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    45cc:	691a      	ldr	r2, [r3, #16]
		       != (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
			;
	} else {
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, OSCCTRL_STATUS_DFLLRDY) != OSCCTRL_STATUS_DFLLRDY)
    45ce:	05d2      	lsls	r2, r2, #23
    45d0:	d5fc      	bpl.n	45cc <_usb_d_dev_wait_dfll_rdy+0x18>
			;
	}
}
    45d2:	4770      	bx	lr
    45d4:	40001000 	.word	0x40001000

000045d8 <_usb_d_dev_ept>:
 * \param[in] epn Endpoint number.
 * \param[in] dir Endpoint direction.
 */
static inline struct _usb_d_dev_ep *_usb_d_dev_ept(uint8_t epn, bool dir)
{
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    45d8:	b110      	cbz	r0, 45e0 <_usb_d_dev_ept+0x8>
    45da:	b109      	cbz	r1, 45e0 <_usb_d_dev_ept+0x8>
    45dc:	3002      	adds	r0, #2
    45de:	b2c0      	uxtb	r0, r0
	return &dev_inst.ep[ep_index];
    45e0:	2314      	movs	r3, #20
    45e2:	fb00 3003 	mla	r0, r0, r3, r3
}
    45e6:	4b01      	ldr	r3, [pc, #4]	; (45ec <_usb_d_dev_ept+0x14>)
    45e8:	4418      	add	r0, r3
    45ea:	4770      	bx	lr
    45ec:	200016c4 	.word	0x200016c4

000045f0 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    45f0:	b430      	push	{r4, r5}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    45f2:	7cc1      	ldrb	r1, [r0, #19]
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    45f4:	7c85      	ldrb	r5, [r0, #18]

	if (!is_ctrl) {
    45f6:	f001 0307 	and.w	r3, r1, #7
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    45fa:	f005 020f 	and.w	r2, r5, #15
	if (!is_ctrl) {
    45fe:	2b01      	cmp	r3, #1
    4600:	ea4f 1442 	mov.w	r4, r2, lsl #5
    4604:	f102 0308 	add.w	r3, r2, #8
    4608:	d00a      	beq.n	4620 <_usb_d_dev_handle_setup+0x30>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    460a:	015a      	lsls	r2, r3, #5
    460c:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    4610:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4614:	2110      	movs	r1, #16
    4616:	71d1      	strb	r1, [r2, #7]
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
}
    4618:	bc30      	pop	{r4, r5}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    461a:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
    461e:	4770      	bx	lr
	if (_usb_d_dev_ep_is_busy(ept)) {
    4620:	f011 0f40 	tst.w	r1, #64	; 0x40
    4624:	d00b      	beq.n	463e <_usb_d_dev_handle_setup+0x4e>
    4626:	0152      	lsls	r2, r2, #5
		ept->flags.bits.is_busy = 0;
    4628:	f36f 1186 	bfc	r1, #6, #1
    462c:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    4630:	74c1      	strb	r1, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    4632:	2180      	movs	r1, #128	; 0x80
    4634:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    4638:	2140      	movs	r1, #64	; 0x40
    463a:	f882 1105 	strb.w	r1, [r2, #261]	; 0x105
	ept->flags.bits.is_stalled = 0;
    463e:	7cc2      	ldrb	r2, [r0, #19]
    4640:	f36f 02c3 	bfc	r2, #3, #1
    4644:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    4646:	4a0a      	ldr	r2, [pc, #40]	; (4670 <_usb_d_dev_handle_setup+0x80>)
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4648:	015b      	lsls	r3, r3, #5
    464a:	1911      	adds	r1, r2, r4
    464c:	2000      	movs	r0, #0
    464e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4652:	f881 00d2 	strb.w	r0, [r1, #210]	; 0xd2
    4656:	f881 00e2 	strb.w	r0, [r1, #226]	; 0xe2
    465a:	216f      	movs	r1, #111	; 0x6f
    465c:	71d9      	strb	r1, [r3, #7]
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    465e:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	dev_inst.ep_callbacks.setup(ept->ep);
    4662:	4628      	mov	r0, r5
    4664:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
}
    4668:	bc30      	pop	{r4, r5}
	dev_inst.ep_callbacks.setup(ept->ep);
    466a:	6893      	ldr	r3, [r2, #8]
    466c:	4718      	bx	r3
    466e:	bf00      	nop
    4670:	200016c4 	.word	0x200016c4

00004674 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    4674:	4602      	mov	r2, r0
	uint8_t epn = USB_EP_GET_N(ept->ep);
    4676:	7c80      	ldrb	r0, [r0, #18]
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    4678:	6892      	ldr	r2, [r2, #8]
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    467a:	2320      	movs	r3, #32
    467c:	fa03 f101 	lsl.w	r1, r3, r1
    4680:	f000 030f 	and.w	r3, r0, #15
    4684:	015b      	lsls	r3, r3, #5
    4686:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    468a:	b2c9      	uxtb	r1, r1
    468c:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    4690:	4b01      	ldr	r3, [pc, #4]	; (4698 <_usb_d_dev_handle_stall+0x24>)
    4692:	2101      	movs	r1, #1
    4694:	691b      	ldr	r3, [r3, #16]
    4696:	4718      	bx	r3
    4698:	200016c4 	.word	0x200016c4

0000469c <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    469c:	4602      	mov	r2, r0
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    469e:	7c80      	ldrb	r0, [r0, #18]
    46a0:	28ff      	cmp	r0, #255	; 0xff
    46a2:	d00a      	beq.n	46ba <_usb_d_dev_trans_done+0x1e>
    46a4:	7cd3      	ldrb	r3, [r2, #19]
    46a6:	f013 0f40 	tst.w	r3, #64	; 0x40
    46aa:	d006      	beq.n	46ba <_usb_d_dev_trans_done+0x1e>
		return;
	}
	ept->flags.bits.is_busy = 0;
    46ac:	f36f 1386 	bfc	r3, #6, #1
    46b0:	74d3      	strb	r3, [r2, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    46b2:	4b02      	ldr	r3, [pc, #8]	; (46bc <_usb_d_dev_trans_done+0x20>)
    46b4:	6892      	ldr	r2, [r2, #8]
    46b6:	691b      	ldr	r3, [r3, #16]
    46b8:	4718      	bx	r3
}
    46ba:	4770      	bx	lr
    46bc:	200016c4 	.word	0x200016c4

000046c0 <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    46c0:	b477      	push	{r0, r1, r2, r4, r5, r6}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    46c2:	7c83      	ldrb	r3, [r0, #18]
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    46c4:	f644 2425 	movw	r4, #18981	; 0x4a25
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    46c8:	2bff      	cmp	r3, #255	; 0xff
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    46ca:	f8ad 4004 	strh.w	r4, [sp, #4]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    46ce:	d021      	beq.n	4714 <_usb_d_dev_trans_stop+0x54>
    46d0:	7cc4      	ldrb	r4, [r0, #19]
    46d2:	0664      	lsls	r4, r4, #25
    46d4:	d51e      	bpl.n	4714 <_usb_d_dev_trans_stop+0x54>
    46d6:	f003 030f 	and.w	r3, r3, #15
    46da:	f103 0408 	add.w	r4, r3, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    46de:	0165      	lsls	r5, r4, #5
    46e0:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
		return;
	}
	/* Stop transfer */
	if (dir) {
    46e4:	b199      	cbz	r1, 470e <_usb_d_dev_trans_stop+0x4e>
    46e6:	2680      	movs	r6, #128	; 0x80
    46e8:	712e      	strb	r6, [r5, #4]
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    46ea:	ad02      	add	r5, sp, #8
    46ec:	440d      	add	r5, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    46ee:	0164      	lsls	r4, r4, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    46f0:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    46f2:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    46f6:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    46fa:	f815 1c04 	ldrb.w	r1, [r5, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    46fe:	71e1      	strb	r1, [r4, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4700:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	_usbd_ep_int_dis(epn, intflags[dir]);
	_usb_d_dev_trans_done(ept, code);
    4704:	4b05      	ldr	r3, [pc, #20]	; (471c <_usb_d_dev_trans_stop+0x5c>)
    4706:	4611      	mov	r1, r2
}
    4708:	b003      	add	sp, #12
    470a:	bc70      	pop	{r4, r5, r6}
	_usb_d_dev_trans_done(ept, code);
    470c:	4718      	bx	r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    470e:	2640      	movs	r6, #64	; 0x40
    4710:	716e      	strb	r6, [r5, #5]
    4712:	e7ea      	b.n	46ea <_usb_d_dev_trans_stop+0x2a>
}
    4714:	b003      	add	sp, #12
    4716:	bc70      	pop	{r4, r5, r6}
    4718:	4770      	bx	lr
    471a:	bf00      	nop
    471c:	0000469d 	.word	0x0000469d

00004720 <_usb_d_dev_handle_trfail>:
{
    4720:	b4f3      	push	{r0, r1, r4, r5, r6, r7}
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    4722:	7c86      	ldrb	r6, [r0, #18]
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    4724:	f640 0304 	movw	r3, #2052	; 0x804
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    4728:	f006 060f 	and.w	r6, r6, #15
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    472c:	f8ad 3004 	strh.w	r3, [sp, #4]
    4730:	f106 0308 	add.w	r3, r6, #8

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    4734:	015a      	lsls	r2, r3, #5
    4736:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    473a:	0175      	lsls	r5, r6, #5
    473c:	7812      	ldrb	r2, [r2, #0]
	uint8_t            eptype
    473e:	b329      	cbz	r1, 478c <_usb_d_dev_handle_trfail+0x6c>
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    4740:	f3c2 1202 	ubfx	r2, r2, #4, #3
	st.reg = bank[bank_n].STATUS_BK.reg;
    4744:	4c2a      	ldr	r4, [pc, #168]	; (47f0 <_usb_d_dev_handle_trfail+0xd0>)
    4746:	eb05 1501 	add.w	r5, r5, r1, lsl #4
    474a:	4425      	add	r5, r4
    474c:	af02      	add	r7, sp, #8
    474e:	7aac      	ldrb	r4, [r5, #10]
    4750:	440f      	add	r7, r1
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    4752:	2a02      	cmp	r2, #2
	st.reg = bank[bank_n].STATUS_BK.reg;
    4754:	b2e4      	uxtb	r4, r4
    4756:	f817 7c04 	ldrb.w	r7, [r7, #-4]
    475a:	ea4f 1246 	mov.w	r2, r6, lsl #5
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    475e:	d118      	bne.n	4792 <_usb_d_dev_handle_trfail+0x72>
    4760:	f014 0f01 	tst.w	r4, #1
    4764:	d015      	beq.n	4792 <_usb_d_dev_handle_trfail+0x72>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    4766:	7aac      	ldrb	r4, [r5, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4768:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    476a:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    476e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4772:	f36f 0400 	bfc	r4, #0, #1
    4776:	72ac      	strb	r4, [r5, #10]
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    4778:	f001 0101 	and.w	r1, r1, #1
    477c:	71df      	strb	r7, [r3, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    477e:	f882 7108 	strb.w	r7, [r2, #264]	; 0x108
    4782:	2204      	movs	r2, #4
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    4784:	4b1b      	ldr	r3, [pc, #108]	; (47f4 <_usb_d_dev_handle_trfail+0xd4>)
}
    4786:	b002      	add	sp, #8
    4788:	bcf0      	pop	{r4, r5, r6, r7}
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    478a:	4718      	bx	r3
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    478c:	f002 0207 	and.w	r2, r2, #7
    4790:	e7d8      	b.n	4744 <_usb_d_dev_handle_trfail+0x24>
	} else if (st.bit.ERRORFLOW) {
    4792:	f014 0402 	ands.w	r4, r4, #2
    4796:	d019      	beq.n	47cc <_usb_d_dev_handle_trfail+0xac>
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    4798:	7aac      	ldrb	r4, [r5, #10]
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    479a:	7cc6      	ldrb	r6, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    479c:	015b      	lsls	r3, r3, #5
    479e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    47a2:	f36f 0441 	bfc	r4, #1, #1
    47a6:	72ac      	strb	r4, [r5, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    47a8:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    47ac:	71df      	strb	r7, [r3, #7]
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    47ae:	f006 0307 	and.w	r3, r6, #7
    47b2:	2b01      	cmp	r3, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    47b4:	f882 7108 	strb.w	r7, [r2, #264]	; 0x108
    47b8:	7cc3      	ldrb	r3, [r0, #19]
    47ba:	d116      	bne.n	47ea <_usb_d_dev_handle_trfail+0xca>
    47bc:	0672      	lsls	r2, r6, #25
    47be:	d514      	bpl.n	47ea <_usb_d_dev_handle_trfail+0xca>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    47c0:	09db      	lsrs	r3, r3, #7
    47c2:	428b      	cmp	r3, r1
    47c4:	d011      	beq.n	47ea <_usb_d_dev_handle_trfail+0xca>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    47c6:	2200      	movs	r2, #0
    47c8:	4619      	mov	r1, r3
    47ca:	e7db      	b.n	4784 <_usb_d_dev_handle_trfail+0x64>
	bank->STATUS_BK.reg     = 0;
    47cc:	480a      	ldr	r0, [pc, #40]	; (47f8 <_usb_d_dev_handle_trfail+0xd8>)
    47ce:	eb01 0146 	add.w	r1, r1, r6, lsl #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    47d2:	015b      	lsls	r3, r3, #5
    47d4:	eb00 1101 	add.w	r1, r0, r1, lsl #4
    47d8:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    47dc:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    47e0:	f881 40d2 	strb.w	r4, [r1, #210]	; 0xd2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    47e4:	71df      	strb	r7, [r3, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    47e6:	f882 7108 	strb.w	r7, [r2, #264]	; 0x108
}
    47ea:	b002      	add	sp, #8
    47ec:	bcf0      	pop	{r4, r5, r6, r7}
    47ee:	4770      	bx	lr
    47f0:	2000178c 	.word	0x2000178c
    47f4:	000046c1 	.word	0x000046c1
    47f8:	200016c4 	.word	0x200016c4

000047fc <_usb_d_dev_reset_epts>:
{
    47fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4800:	4c09      	ldr	r4, [pc, #36]	; (4828 <_usb_d_dev_reset_epts+0x2c>)
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    4802:	4f0a      	ldr	r7, [pc, #40]	; (482c <_usb_d_dev_reset_epts+0x30>)
    4804:	f104 05b4 	add.w	r5, r4, #180	; 0xb4
		dev_inst.ep[i].ep       = 0xFF;
    4808:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    480a:	2103      	movs	r1, #3
    480c:	4620      	mov	r0, r4
    480e:	47b8      	blx	r7
		dev_inst.ep[i].flags.u8 = 0;
    4810:	2100      	movs	r1, #0
		dev_inst.ep[i].ep       = 0xFF;
    4812:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
    4814:	74e1      	strb	r1, [r4, #19]
    4816:	3414      	adds	r4, #20
	for (i = 0; i < USB_D_N_EP; i++) {
    4818:	42ac      	cmp	r4, r5
    481a:	d1f6      	bne.n	480a <_usb_d_dev_reset_epts+0xe>
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    481c:	2260      	movs	r2, #96	; 0x60
    481e:	4804      	ldr	r0, [pc, #16]	; (4830 <_usb_d_dev_reset_epts+0x34>)
    4820:	4b04      	ldr	r3, [pc, #16]	; (4834 <_usb_d_dev_reset_epts+0x38>)
}
    4822:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    4826:	4718      	bx	r3
    4828:	200016d8 	.word	0x200016d8
    482c:	0000469d 	.word	0x0000469d
    4830:	2000178c 	.word	0x2000178c
    4834:	000071c5 	.word	0x000071c5

00004838 <_usb_d_dev_in_next>:
{
    4838:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    483c:	4604      	mov	r4, r0
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    483e:	7c80      	ldrb	r0, [r0, #18]
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    4840:	4688      	mov	r8, r1
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    4842:	f000 070f 	and.w	r7, r0, #15
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    4846:	2900      	cmp	r1, #0
    4848:	d05b      	beq.n	4902 <_usb_d_dev_in_next+0xca>
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    484a:	4b4d      	ldr	r3, [pc, #308]	; (4980 <_usb_d_dev_in_next+0x148>)
    484c:	eb03 1347 	add.w	r3, r3, r7, lsl #5
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    4850:	695e      	ldr	r6, [r3, #20]
    4852:	f3c6 060d 	ubfx	r6, r6, #0, #14
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    4856:	f8b4 c010 	ldrh.w	ip, [r4, #16]
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    485a:	f894 e013 	ldrb.w	lr, [r4, #19]
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    485e:	f240 33ff 	movw	r3, #1023	; 0x3ff
    4862:	459c      	cmp	ip, r3
    4864:	bf1a      	itte	ne
    4866:	f10c 32ff 	addne.w	r2, ip, #4294967295	; 0xffffffff
    486a:	b212      	sxthne	r2, r2
    486c:	4662      	moveq	r2, ip
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    486e:	f00e 0907 	and.w	r9, lr, #7
	if (isr) {
    4872:	f1b8 0f00 	cmp.w	r8, #0
    4876:	d005      	beq.n	4884 <_usb_d_dev_in_next+0x4c>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4878:	017b      	lsls	r3, r7, #5
    487a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    487e:	2102      	movs	r1, #2
    4880:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	ept->trans_count += trans_count;
    4884:	68a1      	ldr	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    4886:	6863      	ldr	r3, [r4, #4]
	ept->trans_count += trans_count;
    4888:	4431      	add	r1, r6
	if (ept->trans_count < ept->trans_size) {
    488a:	4299      	cmp	r1, r3
	ept->trans_count += trans_count;
    488c:	60a1      	str	r1, [r4, #8]
    488e:	ea4f 1547 	mov.w	r5, r7, lsl #5
	if (ept->trans_count < ept->trans_size) {
    4892:	d242      	bcs.n	491a <_usb_d_dev_in_next+0xe2>
		trans_next = ept->trans_size - ept->trans_count;
    4894:	1a5b      	subs	r3, r3, r1
    4896:	b29e      	uxth	r6, r3
    4898:	6823      	ldr	r3, [r4, #0]
    489a:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 498c <_usb_d_dev_in_next+0x154>
		if (ept->flags.bits.use_cache) {
    489e:	f01e 0f20 	tst.w	lr, #32
    48a2:	4419      	add	r1, r3
    48a4:	d02f      	beq.n	4906 <_usb_d_dev_in_next+0xce>
    48a6:	4566      	cmp	r6, ip
    48a8:	bf28      	it	cs
    48aa:	4666      	movcs	r6, ip
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    48ac:	4632      	mov	r2, r6
    48ae:	4b35      	ldr	r3, [pc, #212]	; (4984 <_usb_d_dev_in_next+0x14c>)
    48b0:	68e0      	ldr	r0, [r4, #12]
    48b2:	4798      	blx	r3
	bank->ADDR.reg          = addr;
    48b4:	eb0a 0305 	add.w	r3, sl, r5
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    48b8:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    48ba:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    48be:	eb0a 0205 	add.w	r2, sl, r5
    48c2:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
    48c6:	f366 030d 	bfi	r3, r6, #0, #14
    48ca:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    48ce:	f8d2 30dc 	ldr.w	r3, [r2, #220]	; 0xdc
    48d2:	f36f 339b 	bfc	r3, #14, #14
    48d6:	f8c2 30dc 	str.w	r3, [r2, #220]	; 0xdc
	if (!isr) {
    48da:	f1b8 0f00 	cmp.w	r8, #0
    48de:	d108      	bne.n	48f2 <_usb_d_dev_in_next+0xba>
			inten = USB_D_BANK1_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL0;
    48e0:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    48e4:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    48e8:	bf14      	ite	ne
    48ea:	234a      	movne	r3, #74	; 0x4a
    48ec:	234e      	moveq	r3, #78	; 0x4e
    48ee:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    48f2:	017b      	lsls	r3, r7, #5
    48f4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    48f8:	2280      	movs	r2, #128	; 0x80
    48fa:	f883 2105 	strb.w	r2, [r3, #261]	; 0x105
}
    48fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    4902:	460e      	mov	r6, r1
    4904:	e7a7      	b.n	4856 <_usb_d_dev_in_next+0x1e>
	bank->ADDR.reg          = addr;
    4906:	eb0a 0305 	add.w	r3, sl, r5
    490a:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    490e:	bf28      	it	cs
    4910:	f44f 5600 	movcs.w	r6, #8192	; 0x2000
    4914:	f8c3 10d8 	str.w	r1, [r3, #216]	; 0xd8
    4918:	e7d1      	b.n	48be <_usb_d_dev_in_next+0x86>
	} else if (ept->flags.bits.need_zlp) {
    491a:	f01e 0f10 	tst.w	lr, #16
    491e:	d00e      	beq.n	493e <_usb_d_dev_in_next+0x106>
		ept->flags.bits.need_zlp = 0;
    4920:	7ce3      	ldrb	r3, [r4, #19]
    4922:	f36f 1304 	bfc	r3, #4, #1
    4926:	74e3      	strb	r3, [r4, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    4928:	4b17      	ldr	r3, [pc, #92]	; (4988 <_usb_d_dev_in_next+0x150>)
    492a:	442b      	add	r3, r5
    492c:	685a      	ldr	r2, [r3, #4]
    492e:	f36f 020d 	bfc	r2, #0, #14
    4932:	605a      	str	r2, [r3, #4]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    4934:	685a      	ldr	r2, [r3, #4]
    4936:	f36f 329b 	bfc	r2, #14, #14
    493a:	605a      	str	r2, [r3, #4]
    493c:	e7cd      	b.n	48da <_usb_d_dev_in_next+0xa2>
	if (is_ctrl) {
    493e:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4942:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
	if (last_pkt == ept->size) {
    4946:	ea02 0206 	and.w	r2, r2, r6
    494a:	bf0c      	ite	eq
    494c:	234b      	moveq	r3, #75	; 0x4b
    494e:	234a      	movne	r3, #74	; 0x4a
    4950:	4594      	cmp	ip, r2
    4952:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
    4956:	d10c      	bne.n	4972 <_usb_d_dev_in_next+0x13a>
		ept->flags.bits.is_busy = 0;
    4958:	7ce3      	ldrb	r3, [r4, #19]
    495a:	f36f 1386 	bfc	r3, #6, #1
    495e:	74e3      	strb	r3, [r4, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    4960:	4b0a      	ldr	r3, [pc, #40]	; (498c <_usb_d_dev_in_next+0x154>)
    4962:	68db      	ldr	r3, [r3, #12]
    4964:	4798      	blx	r3
    4966:	2800      	cmp	r0, #0
    4968:	d1c9      	bne.n	48fe <_usb_d_dev_in_next+0xc6>
		ept->flags.bits.is_busy = 1;
    496a:	7ce3      	ldrb	r3, [r4, #19]
    496c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4970:	74e3      	strb	r3, [r4, #19]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    4972:	4620      	mov	r0, r4
    4974:	2100      	movs	r1, #0
    4976:	4b06      	ldr	r3, [pc, #24]	; (4990 <_usb_d_dev_in_next+0x158>)
}
    4978:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    497c:	4718      	bx	r3
    497e:	bf00      	nop
    4980:	2000178c 	.word	0x2000178c
    4984:	0000717d 	.word	0x0000717d
    4988:	2000179c 	.word	0x2000179c
    498c:	200016c4 	.word	0x200016c4
    4990:	0000469d 	.word	0x0000469d

00004994 <_usb_d_dev_out_next>:
{
    4994:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    4998:	7c86      	ldrb	r6, [r0, #18]
    499a:	f006 060f 	and.w	r6, r6, #15
{
    499e:	4604      	mov	r4, r0
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    49a0:	460f      	mov	r7, r1
    49a2:	0175      	lsls	r5, r6, #5
    49a4:	2900      	cmp	r1, #0
    49a6:	d062      	beq.n	4a6e <_usb_d_dev_out_next+0xda>
    49a8:	4b61      	ldr	r3, [pc, #388]	; (4b30 <_usb_d_dev_out_next+0x19c>)
    49aa:	442b      	add	r3, r5
    49ac:	685a      	ldr	r2, [r3, #4]
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    49ae:	685b      	ldr	r3, [r3, #4]
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    49b0:	f3c2 398d 	ubfx	r9, r2, #14, #14
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    49b4:	f3c3 0a0d 	ubfx	sl, r3, #0, #14
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    49b8:	f8b4 8010 	ldrh.w	r8, [r4, #16]
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    49bc:	7ce2      	ldrb	r2, [r4, #19]
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    49be:	f240 33ff 	movw	r3, #1023	; 0x3ff
    49c2:	4598      	cmp	r8, r3
    49c4:	bf1c      	itt	ne
    49c6:	f108 38ff 	addne.w	r8, r8, #4294967295	; 0xffffffff
    49ca:	fa1f f888 	uxthne.w	r8, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    49ce:	f002 0307 	and.w	r3, r2, #7
	uint16_t           last_pkt   = last_trans & size_mask;
    49d2:	ea0a 0b08 	and.w	fp, sl, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    49d6:	9301      	str	r3, [sp, #4]
	if (isr) {
    49d8:	b12f      	cbz	r7, 49e6 <_usb_d_dev_out_next+0x52>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    49da:	0173      	lsls	r3, r6, #5
    49dc:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    49e0:	2101      	movs	r1, #1
    49e2:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	if (ept->flags.bits.use_cache && ept->trans_size) {
    49e6:	0690      	lsls	r0, r2, #26
    49e8:	d50c      	bpl.n	4a04 <_usb_d_dev_out_next+0x70>
    49ea:	6862      	ldr	r2, [r4, #4]
    49ec:	b152      	cbz	r2, 4a04 <_usb_d_dev_out_next+0x70>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    49ee:	68a0      	ldr	r0, [r4, #8]
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    49f0:	6823      	ldr	r3, [r4, #0]
    49f2:	68e1      	ldr	r1, [r4, #12]
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    49f4:	1a12      	subs	r2, r2, r0
    49f6:	b292      	uxth	r2, r2
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    49f8:	455a      	cmp	r2, fp
    49fa:	4418      	add	r0, r3
    49fc:	bf28      	it	cs
    49fe:	465a      	movcs	r2, fp
    4a00:	4b4c      	ldr	r3, [pc, #304]	; (4b34 <_usb_d_dev_out_next+0x1a0>)
    4a02:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    4a04:	6862      	ldr	r2, [r4, #4]
    4a06:	2a00      	cmp	r2, #0
    4a08:	d134      	bne.n	4a74 <_usb_d_dev_out_next+0xe0>
    4a0a:	7ce3      	ldrb	r3, [r4, #19]
    4a0c:	06d9      	lsls	r1, r3, #27
    4a0e:	f140 8089 	bpl.w	4b24 <_usb_d_dev_out_next+0x190>
		ept->flags.bits.need_zlp  = 0;
    4a12:	f362 1304 	bfi	r3, r2, #4, #1
	bank->ADDR.reg          = addr;
    4a16:	4848      	ldr	r0, [pc, #288]	; (4b38 <_usb_d_dev_out_next+0x1a4>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    4a18:	68e1      	ldr	r1, [r4, #12]
		ept->flags.bits.use_cache = 1;
    4a1a:	b2db      	uxtb	r3, r3
	bank->ADDR.reg          = addr;
    4a1c:	4428      	add	r0, r5
		ept->flags.bits.use_cache = 1;
    4a1e:	f043 0320 	orr.w	r3, r3, #32
    4a22:	74e3      	strb	r3, [r4, #19]
	bank->ADDR.reg          = addr;
    4a24:	f100 03c8 	add.w	r3, r0, #200	; 0xc8
    4a28:	f8c0 10c8 	str.w	r1, [r0, #200]	; 0xc8
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    4a2c:	6859      	ldr	r1, [r3, #4]
    4a2e:	8a20      	ldrh	r0, [r4, #16]
    4a30:	f360 319b 	bfi	r1, r0, #14, #14
    4a34:	6059      	str	r1, [r3, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    4a36:	6859      	ldr	r1, [r3, #4]
    4a38:	f362 010d 	bfi	r1, r2, #0, #14
    4a3c:	6059      	str	r1, [r3, #4]
	if (!isr) {
    4a3e:	b96f      	cbnz	r7, 4a5c <_usb_d_dev_out_next+0xc8>
		if (is_ctrl) {
    4a40:	9b01      	ldr	r3, [sp, #4]
    4a42:	2b01      	cmp	r3, #1
	bank->STATUS_BK.reg     = 0;
    4a44:	bf04      	itt	eq
    4a46:	4b3c      	ldreq	r3, [pc, #240]	; (4b38 <_usb_d_dev_out_next+0x1a4>)
    4a48:	195b      	addeq	r3, r3, r5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    4a4a:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    4a4e:	bf0a      	itet	eq
    4a50:	f883 70e2 	strbeq.w	r7, [r3, #226]	; 0xe2
			inten = USB_D_BANK0_INT_FLAGS;
    4a54:	2325      	movne	r3, #37	; 0x25
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    4a56:	232d      	moveq	r3, #45	; 0x2d
    4a58:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    4a5c:	0176      	lsls	r6, r6, #5
    4a5e:	f106 4682 	add.w	r6, r6, #1090519040	; 0x41000000
    4a62:	2340      	movs	r3, #64	; 0x40
    4a64:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
}
    4a68:	b003      	add	sp, #12
    4a6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    4a6e:	4689      	mov	r9, r1
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    4a70:	468a      	mov	sl, r1
    4a72:	e7a1      	b.n	49b8 <_usb_d_dev_out_next+0x24>
	} else if (isr && last_pkt < ept->size) {
    4a74:	b1f7      	cbz	r7, 4ab4 <_usb_d_dev_out_next+0x120>
    4a76:	8a23      	ldrh	r3, [r4, #16]
    4a78:	455b      	cmp	r3, fp
    4a7a:	d91b      	bls.n	4ab4 <_usb_d_dev_out_next+0x120>
		ept->flags.bits.need_zlp = 0;
    4a7c:	7ce2      	ldrb	r2, [r4, #19]
    4a7e:	68a3      	ldr	r3, [r4, #8]
    4a80:	f36f 1204 	bfc	r2, #4, #1
    4a84:	74e2      	strb	r2, [r4, #19]
		ept->trans_count += last_trans;
    4a86:	4453      	add	r3, sl
		ept->trans_count += trans_size;
    4a88:	60a3      	str	r3, [r4, #8]
	if (is_ctrl) {
    4a8a:	9b01      	ldr	r3, [sp, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4a8c:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    4a90:	2b01      	cmp	r3, #1
    4a92:	bf0c      	ite	eq
    4a94:	232d      	moveq	r3, #45	; 0x2d
    4a96:	2325      	movne	r3, #37	; 0x25
    4a98:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
	if (0 == epn) {
    4a9c:	b91e      	cbnz	r6, 4aa6 <_usb_d_dev_out_next+0x112>
	bank->ADDR.reg          = addr;
    4a9e:	4b26      	ldr	r3, [pc, #152]	; (4b38 <_usb_d_dev_out_next+0x1a4>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    4aa0:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    4aa2:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    4aa6:	4b25      	ldr	r3, [pc, #148]	; (4b3c <_usb_d_dev_out_next+0x1a8>)
    4aa8:	2100      	movs	r1, #0
    4aaa:	4620      	mov	r0, r4
}
    4aac:	b003      	add	sp, #12
    4aae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    4ab2:	4718      	bx	r3
		ept->trans_count += trans_size;
    4ab4:	68a1      	ldr	r1, [r4, #8]
    4ab6:	4449      	add	r1, r9
		if (ept->trans_count < ept->trans_size) {
    4ab8:	428a      	cmp	r2, r1
		ept->trans_count += trans_size;
    4aba:	60a1      	str	r1, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    4abc:	d9e5      	bls.n	4a8a <_usb_d_dev_out_next+0xf6>
			if (ept->flags.bits.use_cache) {
    4abe:	7ce0      	ldrb	r0, [r4, #19]
    4ac0:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    4ac4:	4b1c      	ldr	r3, [pc, #112]	; (4b38 <_usb_d_dev_out_next+0x1a4>)
			trans_next = ept->trans_size - ept->trans_count;
    4ac6:	1a52      	subs	r2, r2, r1
			if (ept->flags.bits.use_cache) {
    4ac8:	f010 0f20 	tst.w	r0, #32
			trans_next = ept->trans_size - ept->trans_count;
    4acc:	b292      	uxth	r2, r2
			if (ept->flags.bits.use_cache) {
    4ace:	d014      	beq.n	4afa <_usb_d_dev_out_next+0x166>
	bank->ADDR.reg          = addr;
    4ad0:	1959      	adds	r1, r3, r5
    4ad2:	4562      	cmp	r2, ip
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    4ad4:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    4ad6:	f8c1 00c8 	str.w	r0, [r1, #200]	; 0xc8
    4ada:	bf28      	it	cs
    4adc:	4662      	movcs	r2, ip
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    4ade:	442b      	add	r3, r5
    4ae0:	f8d3 10cc 	ldr.w	r1, [r3, #204]	; 0xcc
    4ae4:	f362 319b 	bfi	r1, r2, #14, #14
    4ae8:	f8c3 10cc 	str.w	r1, [r3, #204]	; 0xcc
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    4aec:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
    4af0:	f36f 020d 	bfc	r2, #0, #14
    4af4:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
    4af8:	e7a1      	b.n	4a3e <_usb_d_dev_out_next+0xaa>
				if (trans_next > ept->size) {
    4afa:	4562      	cmp	r2, ip
    4afc:	d90a      	bls.n	4b14 <_usb_d_dev_out_next+0x180>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    4afe:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    4b02:	d80c      	bhi.n	4b1e <_usb_d_dev_out_next+0x18a>
						trans_next -= trans_next & size_mask;
    4b04:	ea22 0208 	bic.w	r2, r2, r8
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    4b08:	6820      	ldr	r0, [r4, #0]
    4b0a:	4401      	add	r1, r0
	bank->ADDR.reg          = addr;
    4b0c:	1958      	adds	r0, r3, r5
    4b0e:	f8c0 10c8 	str.w	r1, [r0, #200]	; 0xc8
    4b12:	e7e4      	b.n	4ade <_usb_d_dev_out_next+0x14a>
				} else if (trans_next < ept->size) {
    4b14:	d2f8      	bcs.n	4b08 <_usb_d_dev_out_next+0x174>
					ept->flags.bits.use_cache = 1;
    4b16:	f040 0020 	orr.w	r0, r0, #32
    4b1a:	74e0      	strb	r0, [r4, #19]
    4b1c:	e7f4      	b.n	4b08 <_usb_d_dev_out_next+0x174>
						trans_next = USB_D_DEV_TRANS_MAX;
    4b1e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    4b22:	e7f1      	b.n	4b08 <_usb_d_dev_out_next+0x174>
	} else if (isr && last_pkt < ept->size) {
    4b24:	2f00      	cmp	r7, #0
    4b26:	d1a6      	bne.n	4a76 <_usb_d_dev_out_next+0xe2>
		ept->trans_count += trans_size;
    4b28:	68a3      	ldr	r3, [r4, #8]
    4b2a:	444b      	add	r3, r9
    4b2c:	e7ac      	b.n	4a88 <_usb_d_dev_out_next+0xf4>
    4b2e:	bf00      	nop
    4b30:	2000178c 	.word	0x2000178c
    4b34:	0000717d 	.word	0x0000717d
    4b38:	200016c4 	.word	0x200016c4
    4b3c:	0000469d 	.word	0x0000469d

00004b40 <_usb_d_dev_handler>:
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    4b40:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
{
    4b44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    4b48:	8c1e      	ldrh	r6, [r3, #32]
    4b4a:	4c6c      	ldr	r4, [pc, #432]	; (4cfc <_usb_d_dev_handler+0x1bc>)
    4b4c:	b2b6      	uxth	r6, r6
	if (0 == epint) {
    4b4e:	2e00      	cmp	r6, #0
    4b50:	d167      	bne.n	4c22 <_usb_d_dev_handler+0xe2>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    4b52:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    4b54:	8b1a      	ldrh	r2, [r3, #24]
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    4b56:	400a      	ands	r2, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    4b58:	f012 0004 	ands.w	r0, r2, #4
    4b5c:	d005      	beq.n	4b6a <_usb_d_dev_handler+0x2a>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4b5e:	2204      	movs	r2, #4
    4b60:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    4b62:	6823      	ldr	r3, [r4, #0]
}
    4b64:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.sof();
    4b68:	4718      	bx	r3
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    4b6a:	f412 7100 	ands.w	r1, r2, #512	; 0x200
    4b6e:	d024      	beq.n	4bba <_usb_d_dev_handler+0x7a>
    4b70:	f240 2201 	movw	r2, #513	; 0x201
    4b74:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    4b76:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4b78:	2270      	movs	r2, #112	; 0x70
    4b7a:	831a      	strh	r2, [r3, #24]
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    4b7c:	f8b4 30d0 	ldrh.w	r3, [r4, #208]	; 0xd0
    4b80:	f003 030f 	and.w	r3, r3, #15
    4b84:	2b03      	cmp	r3, #3
    4b86:	d014      	beq.n	4bb2 <_usb_d_dev_handler+0x72>
    4b88:	f8b4 30f0 	ldrh.w	r3, [r4, #240]	; 0xf0
    4b8c:	f003 030f 	and.w	r3, r3, #15
    4b90:	2b03      	cmp	r3, #3
    4b92:	d110      	bne.n	4bb6 <_usb_d_dev_handler+0x76>
		UsbDeviceDescBank *bank = &prvt_inst.desc_table[i].DeviceDescBank[0];
    4b94:	2101      	movs	r1, #1
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    4b96:	eb04 1041 	add.w	r0, r4, r1, lsl #5
			bank->EXTREG.reg = 0;
    4b9a:	2300      	movs	r3, #0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    4b9c:	f8b0 10d0 	ldrh.w	r1, [r0, #208]	; 0xd0
			bank->EXTREG.reg = 0;
    4ba0:	f8a0 30d0 	strh.w	r3, [r0, #208]	; 0xd0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    4ba4:	f3c1 110a 	ubfx	r1, r1, #4, #11
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    4ba8:	6863      	ldr	r3, [r4, #4]
    4baa:	2003      	movs	r0, #3
}
    4bac:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    4bb0:	4718      	bx	r3
		UsbDeviceDescBank *bank = &prvt_inst.desc_table[i].DeviceDescBank[0];
    4bb2:	4601      	mov	r1, r0
    4bb4:	e7ef      	b.n	4b96 <_usb_d_dev_handler+0x56>
	uint32_t lpm_variable = 0;
    4bb6:	4601      	mov	r1, r0
    4bb8:	e7f6      	b.n	4ba8 <_usb_d_dev_handler+0x68>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    4bba:	f012 0080 	ands.w	r0, r2, #128	; 0x80
    4bbe:	d004      	beq.n	4bca <_usb_d_dev_handler+0x8a>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4bc0:	2280      	movs	r2, #128	; 0x80
    4bc2:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    4bc4:	2005      	movs	r0, #5
    4bc6:	6863      	ldr	r3, [r4, #4]
    4bc8:	e7f0      	b.n	4bac <_usb_d_dev_handler+0x6c>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    4bca:	f012 0570 	ands.w	r5, r2, #112	; 0x70
    4bce:	d00b      	beq.n	4be8 <_usb_d_dev_handler+0xa8>
    4bd0:	2270      	movs	r2, #112	; 0x70
    4bd2:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    4bd4:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4bd6:	f240 2201 	movw	r2, #513	; 0x201
    4bda:	831a      	strh	r2, [r3, #24]
		_usb_d_dev_wait_dfll_rdy();
    4bdc:	4b48      	ldr	r3, [pc, #288]	; (4d00 <_usb_d_dev_handler+0x1c0>)
    4bde:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    4be0:	6863      	ldr	r3, [r4, #4]
    4be2:	4601      	mov	r1, r0
    4be4:	2002      	movs	r0, #2
    4be6:	e7e1      	b.n	4bac <_usb_d_dev_handler+0x6c>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    4be8:	f012 0108 	ands.w	r1, r2, #8
    4bec:	d00e      	beq.n	4c0c <_usb_d_dev_handler+0xcc>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4bee:	2208      	movs	r2, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    4bf0:	f883 5100 	strb.w	r5, [r3, #256]	; 0x100
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4bf4:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    4bf6:	2270      	movs	r2, #112	; 0x70
    4bf8:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4bfa:	f240 2201 	movw	r2, #513	; 0x201
    4bfe:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    4c00:	4b40      	ldr	r3, [pc, #256]	; (4d04 <_usb_d_dev_handler+0x1c4>)
    4c02:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    4c04:	6863      	ldr	r3, [r4, #4]
    4c06:	4629      	mov	r1, r5
    4c08:	2001      	movs	r0, #1
    4c0a:	e7cf      	b.n	4bac <_usb_d_dev_handler+0x6c>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    4c0c:	07d0      	lsls	r0, r2, #31
    4c0e:	d535      	bpl.n	4c7c <_usb_d_dev_handler+0x13c>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4c10:	f240 2201 	movw	r2, #513	; 0x201
    4c14:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    4c16:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4c18:	2270      	movs	r2, #112	; 0x70
    4c1a:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    4c1c:	2004      	movs	r0, #4
    4c1e:	6863      	ldr	r3, [r4, #4]
    4c20:	e7c4      	b.n	4bac <_usb_d_dev_handler+0x6c>
    4c22:	2500      	movs	r5, #0
    4c24:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 4d18 <_usb_d_dev_handler+0x1d8>
			_usb_d_dev_handle_setup(ept);
    4c28:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 4d1c <_usb_d_dev_handler+0x1dc>
			_usb_d_dev_handle_trfail(ept, 1);
    4c2c:	4f36      	ldr	r7, [pc, #216]	; (4d08 <_usb_d_dev_handler+0x1c8>)
    4c2e:	2014      	movs	r0, #20
    4c30:	4368      	muls	r0, r5
		if (ept->ep == 0xFF) {
    4c32:	eb04 0c00 	add.w	ip, r4, r0
    4c36:	f89c 2026 	ldrb.w	r2, [ip, #38]	; 0x26
    4c3a:	2aff      	cmp	r2, #255	; 0xff
    4c3c:	d028      	beq.n	4c90 <_usb_d_dev_handler+0x150>
	if (!(epint & (1u << epn))) {
    4c3e:	f002 020f 	and.w	r2, r2, #15
    4c42:	2101      	movs	r1, #1
    4c44:	fa01 f302 	lsl.w	r3, r1, r2
    4c48:	4233      	tst	r3, r6
    4c4a:	d021      	beq.n	4c90 <_usb_d_dev_handler+0x150>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    4c4c:	0153      	lsls	r3, r2, #5
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    4c4e:	0152      	lsls	r2, r2, #5
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    4c50:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    4c54:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    4c58:	f893 e107 	ldrb.w	lr, [r3, #263]	; 0x107
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    4c5c:	f892 3109 	ldrb.w	r3, [r2, #265]	; 0x109
	if (flags) {
    4c60:	ea1e 0303 	ands.w	r3, lr, r3
    4c64:	d014      	beq.n	4c90 <_usb_d_dev_handler+0x150>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    4c66:	f89c 2027 	ldrb.w	r2, [ip, #39]	; 0x27
    4c6a:	f002 0c47 	and.w	ip, r2, #71	; 0x47
    4c6e:	458c      	cmp	ip, r1
    4c70:	4448      	add	r0, r9
    4c72:	d112      	bne.n	4c9a <_usb_d_dev_handler+0x15a>
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    4c74:	06da      	lsls	r2, r3, #27
    4c76:	d503      	bpl.n	4c80 <_usb_d_dev_handler+0x140>
			_usb_d_dev_handle_setup(ept);
    4c78:	47c0      	blx	r8
    4c7a:	e009      	b.n	4c90 <_usb_d_dev_handler+0x150>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    4c7c:	4635      	mov	r5, r6
    4c7e:	e7d1      	b.n	4c24 <_usb_d_dev_handler+0xe4>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    4c80:	f013 0140 	ands.w	r1, r3, #64	; 0x40
    4c84:	d002      	beq.n	4c8c <_usb_d_dev_handler+0x14c>
		_usb_d_dev_handle_stall(ept, 1);
    4c86:	4661      	mov	r1, ip
		_usb_d_dev_handle_stall(ept, 0);
    4c88:	4b20      	ldr	r3, [pc, #128]	; (4d0c <_usb_d_dev_handler+0x1cc>)
    4c8a:	e015      	b.n	4cb8 <_usb_d_dev_handler+0x178>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    4c8c:	069b      	lsls	r3, r3, #26
    4c8e:	d4fb      	bmi.n	4c88 <_usb_d_dev_handler+0x148>
    4c90:	3501      	adds	r5, #1
	for (i = 0; i < USB_D_N_EP; i++) {
    4c92:	2d09      	cmp	r5, #9
    4c94:	d1cb      	bne.n	4c2e <_usb_d_dev_handler+0xee>
}
    4c96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (_usb_d_dev_ep_is_in(ept)) {
    4c9a:	f012 0f80 	tst.w	r2, #128	; 0x80
    4c9e:	d015      	beq.n	4ccc <_usb_d_dev_handler+0x18c>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    4ca0:	f013 0f40 	tst.w	r3, #64	; 0x40
    4ca4:	d1f0      	bne.n	4c88 <_usb_d_dev_handler+0x148>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    4ca6:	f013 0f08 	tst.w	r3, #8
    4caa:	d001      	beq.n	4cb0 <_usb_d_dev_handler+0x170>
			_usb_d_dev_handle_trfail(ept, 1);
    4cac:	47b8      	blx	r7
    4cae:	e7ef      	b.n	4c90 <_usb_d_dev_handler+0x150>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    4cb0:	f013 0f02 	tst.w	r3, #2
    4cb4:	d002      	beq.n	4cbc <_usb_d_dev_handler+0x17c>
		_usb_d_dev_in_next(ept, true);
    4cb6:	4b16      	ldr	r3, [pc, #88]	; (4d10 <_usb_d_dev_handler+0x1d0>)
		_usb_d_dev_out_next(ept, true);
    4cb8:	4798      	blx	r3
    4cba:	e7e9      	b.n	4c90 <_usb_d_dev_handler+0x150>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    4cbc:	f002 0207 	and.w	r2, r2, #7
    4cc0:	2a01      	cmp	r2, #1
    4cc2:	d1e5      	bne.n	4c90 <_usb_d_dev_handler+0x150>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    4cc4:	075a      	lsls	r2, r3, #29
    4cc6:	d516      	bpl.n	4cf6 <_usb_d_dev_handler+0x1b6>
			_usb_d_dev_handle_trfail(ept, 0);
    4cc8:	2100      	movs	r1, #0
    4cca:	e7ef      	b.n	4cac <_usb_d_dev_handler+0x16c>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    4ccc:	f013 0c20 	ands.w	ip, r3, #32
    4cd0:	d001      	beq.n	4cd6 <_usb_d_dev_handler+0x196>
		_usb_d_dev_handle_stall(ept, 0);
    4cd2:	2100      	movs	r1, #0
    4cd4:	e7d8      	b.n	4c88 <_usb_d_dev_handler+0x148>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    4cd6:	f013 0f04 	tst.w	r3, #4
    4cda:	d1f5      	bne.n	4cc8 <_usb_d_dev_handler+0x188>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    4cdc:	f013 0f01 	tst.w	r3, #1
    4ce0:	d001      	beq.n	4ce6 <_usb_d_dev_handler+0x1a6>
		_usb_d_dev_out_next(ept, true);
    4ce2:	4b0c      	ldr	r3, [pc, #48]	; (4d14 <_usb_d_dev_handler+0x1d4>)
    4ce4:	e7e8      	b.n	4cb8 <_usb_d_dev_handler+0x178>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    4ce6:	f002 0207 	and.w	r2, r2, #7
    4cea:	2a01      	cmp	r2, #1
    4cec:	d1d0      	bne.n	4c90 <_usb_d_dev_handler+0x150>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    4cee:	071a      	lsls	r2, r3, #28
    4cf0:	d501      	bpl.n	4cf6 <_usb_d_dev_handler+0x1b6>
			_usb_d_dev_handle_trfail(ept, 1);
    4cf2:	2101      	movs	r1, #1
    4cf4:	e7da      	b.n	4cac <_usb_d_dev_handler+0x16c>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    4cf6:	06db      	lsls	r3, r3, #27
    4cf8:	d5ca      	bpl.n	4c90 <_usb_d_dev_handler+0x150>
    4cfa:	e7bd      	b.n	4c78 <_usb_d_dev_handler+0x138>
    4cfc:	200016c4 	.word	0x200016c4
    4d00:	000045b5 	.word	0x000045b5
    4d04:	000047fd 	.word	0x000047fd
    4d08:	00004721 	.word	0x00004721
    4d0c:	00004675 	.word	0x00004675
    4d10:	00004839 	.word	0x00004839
    4d14:	00004995 	.word	0x00004995
    4d18:	200016d8 	.word	0x200016d8
    4d1c:	000045f1 	.word	0x000045f1

00004d20 <_usbd_ep_pcksize_size>:
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    4d20:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    4d24:	d80f      	bhi.n	4d46 <_usbd_ep_pcksize_size+0x26>
    4d26:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    4d2a:	d80e      	bhi.n	4d4a <_usbd_ep_pcksize_size+0x2a>
    4d2c:	2880      	cmp	r0, #128	; 0x80
    4d2e:	d80e      	bhi.n	4d4e <_usbd_ep_pcksize_size+0x2e>
    4d30:	2840      	cmp	r0, #64	; 0x40
    4d32:	d80e      	bhi.n	4d52 <_usbd_ep_pcksize_size+0x32>
    4d34:	2820      	cmp	r0, #32
    4d36:	d80e      	bhi.n	4d56 <_usbd_ep_pcksize_size+0x36>
    4d38:	2810      	cmp	r0, #16
    4d3a:	d80e      	bhi.n	4d5a <_usbd_ep_pcksize_size+0x3a>
    4d3c:	2808      	cmp	r0, #8
    4d3e:	bf94      	ite	ls
    4d40:	2000      	movls	r0, #0
    4d42:	2001      	movhi	r0, #1
    4d44:	4770      	bx	lr
    4d46:	2007      	movs	r0, #7
    4d48:	4770      	bx	lr
    4d4a:	2006      	movs	r0, #6
    4d4c:	4770      	bx	lr
    4d4e:	2005      	movs	r0, #5
    4d50:	4770      	bx	lr
    4d52:	2004      	movs	r0, #4
    4d54:	4770      	bx	lr
    4d56:	2003      	movs	r0, #3
    4d58:	4770      	bx	lr
    4d5a:	2002      	movs	r0, #2
}
    4d5c:	4770      	bx	lr
	...

00004d60 <_usb_d_dev_init>:
{
    4d60:	b508      	push	{r3, lr}
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    4d62:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4d66:	789a      	ldrb	r2, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    4d68:	07d0      	lsls	r0, r2, #31
    4d6a:	d41a      	bmi.n	4da2 <_usb_d_dev_init+0x42>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4d6c:	789a      	ldrb	r2, [r3, #2]
    4d6e:	0791      	lsls	r1, r2, #30
    4d70:	d1fc      	bne.n	4d6c <_usb_d_dev_init+0xc>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    4d72:	781a      	ldrb	r2, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    4d74:	0792      	lsls	r2, r2, #30
    4d76:	d50d      	bpl.n	4d94 <_usb_d_dev_init+0x34>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    4d78:	781a      	ldrb	r2, [r3, #0]
    4d7a:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    4d7e:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4d80:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    4d84:	7893      	ldrb	r3, [r2, #2]
    4d86:	0798      	lsls	r0, r3, #30
    4d88:	d1fc      	bne.n	4d84 <_usb_d_dev_init+0x24>
    4d8a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    4d8e:	7893      	ldrb	r3, [r2, #2]
    4d90:	0799      	lsls	r1, r3, #30
    4d92:	d4fc      	bmi.n	4d8e <_usb_d_dev_init+0x2e>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    4d94:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4d98:	2201      	movs	r2, #1
    4d9a:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4d9c:	789a      	ldrb	r2, [r3, #2]
    4d9e:	0792      	lsls	r2, r2, #30
    4da0:	d1fc      	bne.n	4d9c <_usb_d_dev_init+0x3c>
    4da2:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    4da6:	7893      	ldrb	r3, [r2, #2]
    4da8:	07db      	lsls	r3, r3, #31
    4daa:	d4fc      	bmi.n	4da6 <_usb_d_dev_init+0x46>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    4dac:	4a1e      	ldr	r2, [pc, #120]	; (4e28 <_usb_d_dev_init+0xc8>)
    4dae:	4b1f      	ldr	r3, [pc, #124]	; (4e2c <_usb_d_dev_init+0xcc>)
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    4db0:	e9c3 2200 	strd	r2, r2, [r3]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    4db4:	e9c3 2202 	strd	r2, r2, [r3, #8]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    4db8:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
    4dba:	4b1d      	ldr	r3, [pc, #116]	; (4e30 <_usb_d_dev_init+0xd0>)
    4dbc:	4798      	blx	r3
	    = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    4dbe:	4b1d      	ldr	r3, [pc, #116]	; (4e34 <_usb_d_dev_init+0xd4>)
    4dc0:	681a      	ldr	r2, [r3, #0]
	uint32_t pad_transp
    4dc2:	f3c2 1344 	ubfx	r3, r2, #5, #5
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    4dc6:	f3c2 2182 	ubfx	r1, r2, #10, #3
	if (pad_transn == 0 || pad_transn == 0x1F) {
    4dca:	f012 021f 	ands.w	r2, r2, #31
    4dce:	d025      	beq.n	4e1c <_usb_d_dev_init+0xbc>
		pad_transn = 9;
    4dd0:	2a1f      	cmp	r2, #31
    4dd2:	bf08      	it	eq
    4dd4:	2209      	moveq	r2, #9
	if (pad_transp == 0 || pad_transp == 0x1F) {
    4dd6:	b31b      	cbz	r3, 4e20 <_usb_d_dev_init+0xc0>
		pad_transp = 25;
    4dd8:	2b1f      	cmp	r3, #31
    4dda:	bf08      	it	eq
    4ddc:	2319      	moveq	r3, #25
	if (pad_trim == 0 || pad_trim == 0x7) {
    4dde:	b309      	cbz	r1, 4e24 <_usb_d_dev_init+0xc4>
		pad_trim = 6;
    4de0:	2907      	cmp	r1, #7
    4de2:	bf08      	it	eq
    4de4:	2106      	moveq	r1, #6
	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    4de6:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    4dea:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    4dee:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    4df2:	b29b      	uxth	r3, r3
    4df4:	8513      	strh	r3, [r2, #40]	; 0x28
	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    4df6:	78d3      	ldrb	r3, [r2, #3]
    4df8:	f043 0303 	orr.w	r3, r3, #3
    4dfc:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    4dfe:	78d3      	ldrb	r3, [r2, #3]
    4e00:	f043 030c 	orr.w	r3, r3, #12
    4e04:	70d3      	strb	r3, [r2, #3]
	((Usb *)hw)->HOST.CTRLA.reg = data;
    4e06:	2304      	movs	r3, #4
    4e08:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4e0a:	7890      	ldrb	r0, [r2, #2]
    4e0c:	f010 0003 	ands.w	r0, r0, #3
    4e10:	d1fb      	bne.n	4e0a <_usb_d_dev_init+0xaa>
	hri_usbdevice_write_DESCADD_reg(hw, (uint32_t)prvt_inst.desc_table);
    4e12:	4b09      	ldr	r3, [pc, #36]	; (4e38 <_usb_d_dev_init+0xd8>)
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    4e14:	6253      	str	r3, [r2, #36]	; 0x24
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    4e16:	2301      	movs	r3, #1
    4e18:	8113      	strh	r3, [r2, #8]
}
    4e1a:	bd08      	pop	{r3, pc}
		pad_transn = 9;
    4e1c:	2209      	movs	r2, #9
    4e1e:	e7da      	b.n	4dd6 <_usb_d_dev_init+0x76>
		pad_transp = 25;
    4e20:	2319      	movs	r3, #25
    4e22:	e7dc      	b.n	4dde <_usb_d_dev_init+0x7e>
		pad_trim = 6;
    4e24:	2106      	movs	r1, #6
    4e26:	e7de      	b.n	4de6 <_usb_d_dev_init+0x86>
    4e28:	000045b1 	.word	0x000045b1
    4e2c:	200016c4 	.word	0x200016c4
    4e30:	000047fd 	.word	0x000047fd
    4e34:	00800084 	.word	0x00800084
    4e38:	2000178c 	.word	0x2000178c

00004e3c <_usb_d_dev_enable>:
	tmp = ((Usb *)hw)->HOST.SYNCBUSY.reg;
    4e3c:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4e40:	789a      	ldrb	r2, [r3, #2]
	if (hri_usbdevice_get_SYNCBUSY_reg(hw, (USB_SYNCBUSY_ENABLE | USB_SYNCBUSY_SWRST))) {
    4e42:	0792      	lsls	r2, r2, #30
    4e44:	d122      	bne.n	4e8c <_usb_d_dev_enable+0x50>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4e46:	789a      	ldrb	r2, [r3, #2]
    4e48:	0790      	lsls	r0, r2, #30
    4e4a:	d1fc      	bne.n	4e46 <_usb_d_dev_enable+0xa>
	return ((Usb *)hw)->HOST.CTRLA.reg;
    4e4c:	781a      	ldrb	r2, [r3, #0]
    4e4e:	b2d2      	uxtb	r2, r2
	if ((ctrla & USB_CTRLA_ENABLE) == 0) {
    4e50:	0791      	lsls	r1, r2, #30
    4e52:	d407      	bmi.n	4e64 <_usb_d_dev_enable+0x28>
		hri_usbdevice_write_CTRLA_reg(hw, ctrla | USB_CTRLA_ENABLE);
    4e54:	f042 0202 	orr.w	r2, r2, #2
	((Usb *)hw)->HOST.CTRLA.reg = data;
    4e58:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    4e5a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    4e5e:	7893      	ldrb	r3, [r2, #2]
    4e60:	079b      	lsls	r3, r3, #30
    4e62:	d1fc      	bne.n	4e5e <_usb_d_dev_enable+0x22>
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    4e64:	4b0b      	ldr	r3, [pc, #44]	; (4e94 <_usb_d_dev_enable+0x58>)
    4e66:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    4e6a:	609a      	str	r2, [r3, #8]
    4e6c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    4e70:	609a      	str	r2, [r3, #8]
    4e72:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    4e76:	609a      	str	r2, [r3, #8]
    4e78:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    4e7c:	609a      	str	r2, [r3, #8]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4e7e:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4e82:	f240 228d 	movw	r2, #653	; 0x28d
    4e86:	831a      	strh	r2, [r3, #24]
	return ERR_NONE;
    4e88:	2000      	movs	r0, #0
    4e8a:	4770      	bx	lr
		return -USB_ERR_DENIED;
    4e8c:	f06f 0010 	mvn.w	r0, #16
}
    4e90:	4770      	bx	lr
    4e92:	bf00      	nop
    4e94:	e000e100 	.word	0xe000e100

00004e98 <_usb_d_dev_attach>:
	((Usb *)hw)->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    4e98:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    4e9c:	8913      	ldrh	r3, [r2, #8]
    4e9e:	f023 0301 	bic.w	r3, r3, #1
    4ea2:	041b      	lsls	r3, r3, #16
    4ea4:	0c1b      	lsrs	r3, r3, #16
    4ea6:	8113      	strh	r3, [r2, #8]
}
    4ea8:	4770      	bx	lr

00004eaa <_usb_d_dev_set_address>:
	((Usb *)hw)->DEVICE.DADD.reg = data;
    4eaa:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
	hri_usbdevice_write_DADD_reg(USB, USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(addr));
    4eae:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    4eb2:	7298      	strb	r0, [r3, #10]
}
    4eb4:	4770      	bx	lr
	...

00004eb8 <_usb_d_dev_ep_init>:
{
    4eb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    4ebc:	f000 040f 	and.w	r4, r0, #15
    4ec0:	b246      	sxtb	r6, r0
{
    4ec2:	460d      	mov	r5, r1
    4ec4:	4680      	mov	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    4ec6:	0ff1      	lsrs	r1, r6, #31
    4ec8:	4620      	mov	r0, r4
    4eca:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 4f6c <_usb_d_dev_ep_init+0xb4>
    4ece:	47c8      	blx	r9
	if (epn > CONF_USB_D_MAX_EP_N) {
    4ed0:	2c02      	cmp	r4, #2
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    4ed2:	4607      	mov	r7, r0
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    4ed4:	f005 0503 	and.w	r5, r5, #3
	if (epn > CONF_USB_D_MAX_EP_N) {
    4ed8:	d83d      	bhi.n	4f56 <_usb_d_dev_ep_init+0x9e>
	if (ept->ep != 0xFF) {
    4eda:	7c83      	ldrb	r3, [r0, #18]
    4edc:	2bff      	cmp	r3, #255	; 0xff
    4ede:	d13d      	bne.n	4f5c <_usb_d_dev_ep_init+0xa4>
	if (ep_type == USB_EP_XTYPE_CTRL) {
    4ee0:	b97d      	cbnz	r5, 4f02 <_usb_d_dev_ep_init+0x4a>
		struct _usb_d_dev_ep *ept_in = _usb_d_dev_ept(epn, !dir);
    4ee2:	43f1      	mvns	r1, r6
    4ee4:	0fc9      	lsrs	r1, r1, #31
    4ee6:	4620      	mov	r0, r4
    4ee8:	47c8      	blx	r9
		if (ept_in->ep != 0xFF) {
    4eea:	7c83      	ldrb	r3, [r0, #18]
    4eec:	2bff      	cmp	r3, #255	; 0xff
    4eee:	d135      	bne.n	4f5c <_usb_d_dev_ep_init+0xa4>
		if (pcfg->cache == NULL) {
    4ef0:	230c      	movs	r3, #12
    4ef2:	4363      	muls	r3, r4
    4ef4:	491c      	ldr	r1, [pc, #112]	; (4f68 <_usb_d_dev_ep_init+0xb0>)
    4ef6:	58cb      	ldr	r3, [r1, r3]
    4ef8:	2b00      	cmp	r3, #0
    4efa:	d132      	bne.n	4f62 <_usb_d_dev_ep_init+0xaa>
			return -USB_ERR_FUNC;
    4efc:	f06f 0012 	mvn.w	r0, #18
    4f00:	e01b      	b.n	4f3a <_usb_d_dev_ep_init+0x82>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    4f02:	2e00      	cmp	r6, #0
    4f04:	da1b      	bge.n	4f3e <_usb_d_dev_ep_init+0x86>
    4f06:	4918      	ldr	r1, [pc, #96]	; (4f68 <_usb_d_dev_ep_init+0xb0>)
    4f08:	230c      	movs	r3, #12
    4f0a:	fb03 1304 	mla	r3, r3, r4, r1
    4f0e:	6859      	ldr	r1, [r3, #4]
    4f10:	b111      	cbz	r1, 4f18 <_usb_d_dev_ep_init+0x60>
    4f12:	895b      	ldrh	r3, [r3, #10]
    4f14:	429a      	cmp	r2, r3
    4f16:	dcf1      	bgt.n	4efc <_usb_d_dev_ep_init+0x44>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    4f18:	4913      	ldr	r1, [pc, #76]	; (4f68 <_usb_d_dev_ep_init+0xb0>)
	ept->size     = max_pkt_siz;
    4f1a:	823a      	strh	r2, [r7, #16]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    4f1c:	230c      	movs	r3, #12
    4f1e:	435c      	muls	r4, r3
    4f20:	190b      	adds	r3, r1, r4
    4f22:	5909      	ldr	r1, [r1, r4]
    4f24:	685b      	ldr	r3, [r3, #4]
	ept->ep       = ep;
    4f26:	f887 8012 	strb.w	r8, [r7, #18]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    4f2a:	ea13 0326 	ands.w	r3, r3, r6, asr #32
    4f2e:	bf38      	it	cc
    4f30:	460b      	movcc	r3, r1
	ept->flags.u8 = (ep_type + 1);
    4f32:	3501      	adds	r5, #1
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    4f34:	60fb      	str	r3, [r7, #12]
	ept->flags.u8 = (ep_type + 1);
    4f36:	74fd      	strb	r5, [r7, #19]
	return USB_OK;
    4f38:	2000      	movs	r0, #0
}
    4f3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    4f3e:	230c      	movs	r3, #12
    4f40:	4363      	muls	r3, r4
    4f42:	4909      	ldr	r1, [pc, #36]	; (4f68 <_usb_d_dev_ep_init+0xb0>)
    4f44:	58cb      	ldr	r3, [r1, r3]
    4f46:	2b00      	cmp	r3, #0
    4f48:	d0e6      	beq.n	4f18 <_usb_d_dev_ep_init+0x60>
    4f4a:	4907      	ldr	r1, [pc, #28]	; (4f68 <_usb_d_dev_ep_init+0xb0>)
    4f4c:	230c      	movs	r3, #12
    4f4e:	fb03 1304 	mla	r3, r3, r4, r1
    4f52:	891b      	ldrh	r3, [r3, #8]
    4f54:	e7de      	b.n	4f14 <_usb_d_dev_ep_init+0x5c>
		return -USB_ERR_PARAM;
    4f56:	f06f 0011 	mvn.w	r0, #17
    4f5a:	e7ee      	b.n	4f3a <_usb_d_dev_ep_init+0x82>
		return -USB_ERR_REDO;
    4f5c:	f06f 0013 	mvn.w	r0, #19
    4f60:	e7eb      	b.n	4f3a <_usb_d_dev_ep_init+0x82>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    4f62:	2e00      	cmp	r6, #0
    4f64:	daf1      	bge.n	4f4a <_usb_d_dev_ep_init+0x92>
    4f66:	e7ce      	b.n	4f06 <_usb_d_dev_ep_init+0x4e>
    4f68:	00007a5c 	.word	0x00007a5c
    4f6c:	000045d9 	.word	0x000045d9

00004f70 <_usb_d_dev_ep_deinit>:
{
    4f70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4f74:	b247      	sxtb	r7, r0
	uint8_t               epn = USB_EP_GET_N(ep);
    4f76:	f000 050f 	and.w	r5, r0, #15
	bool                  dir = USB_EP_GET_DIR(ep);
    4f7a:	ea4f 78d7 	mov.w	r8, r7, lsr #31
{
    4f7e:	4604      	mov	r4, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    4f80:	4641      	mov	r1, r8
    4f82:	4628      	mov	r0, r5
    4f84:	4b17      	ldr	r3, [pc, #92]	; (4fe4 <_usb_d_dev_ep_deinit+0x74>)
    4f86:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    4f88:	2d02      	cmp	r5, #2
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    4f8a:	4606      	mov	r6, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    4f8c:	d812      	bhi.n	4fb4 <_usb_d_dev_ep_deinit+0x44>
    4f8e:	7c83      	ldrb	r3, [r0, #18]
    4f90:	2bff      	cmp	r3, #255	; 0xff
    4f92:	d00f      	beq.n	4fb4 <_usb_d_dev_ep_deinit+0x44>
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
    4f94:	4b14      	ldr	r3, [pc, #80]	; (4fe8 <_usb_d_dev_ep_deinit+0x78>)
    4f96:	2203      	movs	r2, #3
    4f98:	4798      	blx	r3
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    4f9a:	7cf3      	ldrb	r3, [r6, #19]
    4f9c:	f003 0307 	and.w	r3, r3, #7
    4fa0:	2b01      	cmp	r3, #1
    4fa2:	d109      	bne.n	4fb8 <_usb_d_dev_ep_deinit+0x48>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg = 0;
    4fa4:	0164      	lsls	r4, r4, #5
    4fa6:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    4faa:	2300      	movs	r3, #0
    4fac:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
	ept->ep       = 0xFF;
    4fb0:	23ff      	movs	r3, #255	; 0xff
    4fb2:	8273      	strh	r3, [r6, #18]
}
    4fb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (USB_EP_GET_DIR(ep)) {
    4fb8:	2f00      	cmp	r7, #0
    4fba:	da09      	bge.n	4fd0 <_usb_d_dev_ep_deinit+0x60>
    4fbc:	0168      	lsls	r0, r5, #5
    4fbe:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
		hw->DEVICE.DeviceEndpoint[USB_EP_GET_N(ep)].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE1_Msk;
    4fc2:	f890 3100 	ldrb.w	r3, [r0, #256]	; 0x100
    4fc6:	f003 038f 	and.w	r3, r3, #143	; 0x8f
    4fca:	f880 3100 	strb.w	r3, [r0, #256]	; 0x100
    4fce:	e7ef      	b.n	4fb0 <_usb_d_dev_ep_deinit+0x40>
    4fd0:	0164      	lsls	r4, r4, #5
    4fd2:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE0_Msk;
    4fd6:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
    4fda:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
    4fde:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
    4fe2:	e7e5      	b.n	4fb0 <_usb_d_dev_ep_deinit+0x40>
    4fe4:	000045d9 	.word	0x000045d9
    4fe8:	000046c1 	.word	0x000046c1

00004fec <_usb_d_dev_ep_enable>:
{
    4fec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn   = USB_EP_GET_N(ep);
    4ff0:	f000 040f 	and.w	r4, r0, #15
    4ff4:	fa4f f880 	sxtb.w	r8, r0
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    4ff8:	ea4f 71d8 	mov.w	r1, r8, lsr #31
    4ffc:	4620      	mov	r0, r4
    4ffe:	4b52      	ldr	r3, [pc, #328]	; (5148 <_usb_d_dev_ep_enable+0x15c>)
    5000:	4798      	blx	r3
    5002:	0167      	lsls	r7, r4, #5
    5004:	f107 4582 	add.w	r5, r7, #1090519040	; 0x41000000
    5008:	4606      	mov	r6, r0
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    500a:	f895 0100 	ldrb.w	r0, [r5, #256]	; 0x100
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    500e:	2c02      	cmp	r4, #2
    5010:	b2c0      	uxtb	r0, r0
    5012:	f200 8093 	bhi.w	513c <_usb_d_dev_ep_enable+0x150>
    5016:	7cb2      	ldrb	r2, [r6, #18]
    5018:	2aff      	cmp	r2, #255	; 0xff
    501a:	f000 808f 	beq.w	513c <_usb_d_dev_ep_enable+0x150>
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    501e:	494b      	ldr	r1, [pc, #300]	; (514c <_usb_d_dev_ep_enable+0x160>)
    5020:	f101 03c8 	add.w	r3, r1, #200	; 0xc8
    5024:	441f      	add	r7, r3
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    5026:	7cf3      	ldrb	r3, [r6, #19]
    5028:	f003 0c07 	and.w	ip, r3, #7
    502c:	f1bc 0f01 	cmp.w	ip, #1
    5030:	d148      	bne.n	50c4 <_usb_d_dev_ep_enable+0xd8>
		if (epcfg & (USB_DEVICE_EPCFG_EPTYPE1_Msk | USB_DEVICE_EPCFG_EPTYPE0_Msk)) {
    5032:	f010 0377 	ands.w	r3, r0, #119	; 0x77
    5036:	f040 8084 	bne.w	5142 <_usb_d_dev_ep_enable+0x156>
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    503a:	f8b6 8010 	ldrh.w	r8, [r6, #16]
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    503e:	f8df 9110 	ldr.w	r9, [pc, #272]	; 5150 <_usb_d_dev_ep_enable+0x164>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    5042:	2011      	movs	r0, #17
    5044:	f885 0100 	strb.w	r0, [r5, #256]	; 0x100
    5048:	4640      	mov	r0, r8
    504a:	47c8      	blx	r9
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    504c:	f8df c104 	ldr.w	ip, [pc, #260]	; 5154 <_usb_d_dev_ep_enable+0x168>
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5050:	0700      	lsls	r0, r0, #28
    5052:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    5056:	ea0c 3c88 	and.w	ip, ip, r8, lsl #14
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    505a:	f3c8 080d 	ubfx	r8, r8, #0, #14
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    505e:	ea4c 0c00 	orr.w	ip, ip, r0
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5062:	ea48 0000 	orr.w	r0, r8, r0
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    5066:	f8c7 c004 	str.w	ip, [r7, #4]
	uint8_t epn = USB_EP_GET_N(ept->ep);
    506a:	f002 020f 	and.w	r2, r2, #15
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    506e:	6178      	str	r0, [r7, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    5070:	2740      	movs	r7, #64	; 0x40
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    5072:	2080      	movs	r0, #128	; 0x80
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    5074:	f885 7105 	strb.w	r7, [r5, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    5078:	f885 0104 	strb.w	r0, [r5, #260]	; 0x104
	bank->ADDR.reg          = addr;
    507c:	0150      	lsls	r0, r2, #5
	bank->STATUS_BK.reg     = 0;
    507e:	eb01 1444 	add.w	r4, r1, r4, lsl #5
	bank->ADDR.reg          = addr;
    5082:	4401      	add	r1, r0
	_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    5084:	68f5      	ldr	r5, [r6, #12]
	bank->STATUS_BK.reg     = 0;
    5086:	f884 30d2 	strb.w	r3, [r4, #210]	; 0xd2
    508a:	f884 30e2 	strb.w	r3, [r4, #226]	; 0xe2
	bank->ADDR.reg          = addr;
    508e:	f8c1 50c8 	str.w	r5, [r1, #200]	; 0xc8
    5092:	f101 04c8 	add.w	r4, r1, #200	; 0xc8
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    5096:	f8d1 10cc 	ldr.w	r1, [r1, #204]	; 0xcc
    509a:	f368 319b 	bfi	r1, r8, #14, #14
    509e:	6061      	str	r1, [r4, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    50a0:	6861      	ldr	r1, [r4, #4]
    50a2:	f100 4282 	add.w	r2, r0, #1090519040	; 0x41000000
    50a6:	f363 010d 	bfi	r1, r3, #0, #14
    50aa:	6061      	str	r1, [r4, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    50ac:	4610      	mov	r0, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    50ae:	21b0      	movs	r1, #176	; 0xb0
    50b0:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    50b4:	f882 7105 	strb.w	r7, [r2, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    50b8:	2210      	movs	r2, #16
    50ba:	f880 2109 	strb.w	r2, [r0, #265]	; 0x109
	return USB_OK;
    50be:	4618      	mov	r0, r3
}
    50c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (dir) {
    50c4:	f1b8 0f00 	cmp.w	r8, #0
    50c8:	da1c      	bge.n	5104 <_usb_d_dev_ep_enable+0x118>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE1_Msk) {
    50ca:	f010 0270 	ands.w	r2, r0, #112	; 0x70
    50ce:	d138      	bne.n	5142 <_usb_d_dev_ep_enable+0x156>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    50d0:	f3c3 0302 	ubfx	r3, r3, #0, #3
    50d4:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    50d8:	8a33      	ldrh	r3, [r6, #16]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    50da:	f885 0100 	strb.w	r0, [r5, #256]	; 0x100
    50de:	4e1c      	ldr	r6, [pc, #112]	; (5150 <_usb_d_dev_ep_enable+0x164>)
    50e0:	4618      	mov	r0, r3
    50e2:	47b0      	blx	r6
    50e4:	0700      	lsls	r0, r0, #28
    50e6:	f3c3 030d 	ubfx	r3, r3, #0, #14
    50ea:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
	bank->STATUS_BK.reg     = 0;
    50ee:	eb01 1144 	add.w	r1, r1, r4, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    50f2:	4318      	orrs	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    50f4:	2380      	movs	r3, #128	; 0x80
    50f6:	6178      	str	r0, [r7, #20]
    50f8:	f885 3104 	strb.w	r3, [r5, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    50fc:	f881 20e2 	strb.w	r2, [r1, #226]	; 0xe2
	return USB_OK;
    5100:	4610      	mov	r0, r2
    5102:	e7dd      	b.n	50c0 <_usb_d_dev_ep_enable+0xd4>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE0_Msk) {
    5104:	f010 0207 	ands.w	r2, r0, #7
    5108:	d11b      	bne.n	5142 <_usb_d_dev_ep_enable+0x156>
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    510a:	8a36      	ldrh	r6, [r6, #16]
		epcfg |= USB_DEVICE_EPCFG_EPTYPE0(ept->flags.bits.eptype);
    510c:	f3c3 0302 	ubfx	r3, r3, #0, #3
    5110:	4318      	orrs	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    5112:	f885 0100 	strb.w	r0, [r5, #256]	; 0x100
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5116:	4b0e      	ldr	r3, [pc, #56]	; (5150 <_usb_d_dev_ep_enable+0x164>)
    5118:	4630      	mov	r0, r6
    511a:	4798      	blx	r3
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    511c:	4b0d      	ldr	r3, [pc, #52]	; (5154 <_usb_d_dev_ep_enable+0x168>)
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    511e:	0700      	lsls	r0, r0, #28
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    5120:	ea03 3386 	and.w	r3, r3, r6, lsl #14
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5124:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
    5128:	4303      	orrs	r3, r0
	bank->STATUS_BK.reg     = 0;
    512a:	eb01 1144 	add.w	r1, r1, r4, lsl #5
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    512e:	607b      	str	r3, [r7, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    5130:	2340      	movs	r3, #64	; 0x40
    5132:	f885 3105 	strb.w	r3, [r5, #261]	; 0x105
	bank->STATUS_BK.reg     = 0;
    5136:	f881 20d2 	strb.w	r2, [r1, #210]	; 0xd2
    513a:	e7e1      	b.n	5100 <_usb_d_dev_ep_enable+0x114>
		return -USB_ERR_PARAM;
    513c:	f06f 0011 	mvn.w	r0, #17
    5140:	e7be      	b.n	50c0 <_usb_d_dev_ep_enable+0xd4>
			return -USB_ERR_REDO;
    5142:	f06f 0013 	mvn.w	r0, #19
    5146:	e7bb      	b.n	50c0 <_usb_d_dev_ep_enable+0xd4>
    5148:	000045d9 	.word	0x000045d9
    514c:	200016c4 	.word	0x200016c4
    5150:	00004d21 	.word	0x00004d21
    5154:	0fffc000 	.word	0x0fffc000

00005158 <_usb_d_dev_ep_stall>:
{
    5158:	b538      	push	{r3, r4, r5, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    515a:	f000 020f 	and.w	r2, r0, #15
	bool                  dir = USB_EP_GET_DIR(ep);
    515e:	09c5      	lsrs	r5, r0, #7
{
    5160:	460c      	mov	r4, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    5162:	4610      	mov	r0, r2
    5164:	4629      	mov	r1, r5
    5166:	4b2f      	ldr	r3, [pc, #188]	; (5224 <_usb_d_dev_ep_stall+0xcc>)
    5168:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N) {
    516a:	2a02      	cmp	r2, #2
    516c:	d857      	bhi.n	521e <_usb_d_dev_ep_stall+0xc6>
    516e:	7c83      	ldrb	r3, [r0, #18]
    5170:	2210      	movs	r2, #16
	if (USB_EP_STALL_SET == ctrl) {
    5172:	2c01      	cmp	r4, #1
    5174:	f003 030f 	and.w	r3, r3, #15
    5178:	fa02 f205 	lsl.w	r2, r2, r5
    517c:	d114      	bne.n	51a8 <_usb_d_dev_ep_stall+0x50>
    517e:	0159      	lsls	r1, r3, #5
    5180:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    5184:	b2d2      	uxtb	r2, r2
    5186:	f881 2105 	strb.w	r2, [r1, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    518a:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    518c:	2220      	movs	r2, #32
    518e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    5192:	fa02 f505 	lsl.w	r5, r2, r5
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    5196:	b2ed      	uxtb	r5, r5
    5198:	f883 5109 	strb.w	r5, [r3, #265]	; 0x109
	ept->flags.bits.is_stalled = 1;
    519c:	7cc3      	ldrb	r3, [r0, #19]
    519e:	f043 0308 	orr.w	r3, r3, #8
    51a2:	74c3      	strb	r3, [r0, #19]
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    51a4:	2000      	movs	r0, #0
}
    51a6:	bd38      	pop	{r3, r4, r5, pc}
	} else if (USB_EP_STALL_CLR == ctrl) {
    51a8:	bb74      	cbnz	r4, 5208 <_usb_d_dev_ep_stall+0xb0>
    51aa:	015c      	lsls	r4, r3, #5
    51ac:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    51b0:	f894 1106 	ldrb.w	r1, [r4, #262]	; 0x106
	if (!is_stalled) {
    51b4:	4211      	tst	r1, r2
    51b6:	d0f5      	beq.n	51a4 <_usb_d_dev_ep_stall+0x4c>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    51b8:	b2d2      	uxtb	r2, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    51ba:	f884 2104 	strb.w	r2, [r4, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    51be:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    51c0:	2220      	movs	r2, #32
    51c2:	40aa      	lsls	r2, r5
    51c4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    51c8:	b2d1      	uxtb	r1, r2
    51ca:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    51ce:	f894 3107 	ldrb.w	r3, [r4, #263]	; 0x107
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    51d2:	4213      	tst	r3, r2
    51d4:	d007      	beq.n	51e6 <_usb_d_dev_ep_stall+0x8e>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    51d6:	2301      	movs	r3, #1
    51d8:	fa03 f505 	lsl.w	r5, r3, r5
    51dc:	b2ed      	uxtb	r5, r5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    51de:	f884 1107 	strb.w	r1, [r4, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    51e2:	f884 5104 	strb.w	r5, [r4, #260]	; 0x104
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    51e6:	7cc2      	ldrb	r2, [r0, #19]
    51e8:	f002 0307 	and.w	r3, r2, #7
    51ec:	2b01      	cmp	r3, #1
    51ee:	d108      	bne.n	5202 <_usb_d_dev_ep_stall+0xaa>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    51f0:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    51f4:	f013 0330 	ands.w	r3, r3, #48	; 0x30
    51f8:	d1d4      	bne.n	51a4 <_usb_d_dev_ep_stall+0x4c>
			ept->flags.bits.is_stalled = 0;
    51fa:	f363 02c3 	bfi	r2, r3, #3, #1
		ept->flags.bits.is_stalled = 0;
    51fe:	74c2      	strb	r2, [r0, #19]
    5200:	e7d0      	b.n	51a4 <_usb_d_dev_ep_stall+0x4c>
    5202:	f36f 02c3 	bfc	r2, #3, #1
    5206:	e7fa      	b.n	51fe <_usb_d_dev_ep_stall+0xa6>
    5208:	015b      	lsls	r3, r3, #5
    520a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    520e:	f503 7380 	add.w	r3, r3, #256	; 0x100
    5212:	799b      	ldrb	r3, [r3, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    5214:	4213      	tst	r3, r2
    5216:	bf14      	ite	ne
    5218:	2001      	movne	r0, #1
    521a:	2000      	moveq	r0, #0
    521c:	e7c3      	b.n	51a6 <_usb_d_dev_ep_stall+0x4e>
		return -USB_ERR_PARAM;
    521e:	f06f 0011 	mvn.w	r0, #17
    5222:	e7c0      	b.n	51a6 <_usb_d_dev_ep_stall+0x4e>
    5224:	000045d9 	.word	0x000045d9

00005228 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    5228:	b530      	push	{r4, r5, lr}
	uint8_t            epn   = USB_EP_GET_N(ep);
    522a:	f000 000f 	and.w	r0, r0, #15
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    522e:	4b12      	ldr	r3, [pc, #72]	; (5278 <_usb_d_dev_ep_read_req+0x50>)
    5230:	0142      	lsls	r2, r0, #5
    5232:	189c      	adds	r4, r3, r2
	uint32_t           addr  = bank[0].ADDR.reg;
    5234:	589d      	ldr	r5, [r3, r2]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    5236:	6864      	ldr	r4, [r4, #4]

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    5238:	2802      	cmp	r0, #2
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    523a:	f3c4 040d 	ubfx	r4, r4, #0, #14
	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    523e:	d814      	bhi.n	526a <_usb_d_dev_ep_read_req+0x42>
    5240:	b199      	cbz	r1, 526a <_usb_d_dev_ep_read_req+0x42>
    5242:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    5246:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    524a:	2b11      	cmp	r3, #17
    524c:	d110      	bne.n	5270 <_usb_d_dev_ep_read_req+0x48>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    524e:	f892 3107 	ldrb.w	r3, [r2, #263]	; 0x107
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    5252:	f013 0010 	ands.w	r0, r3, #16
    5256:	d007      	beq.n	5268 <_usb_d_dev_ep_read_req+0x40>
		return ERR_NONE;
	}
	memcpy(req_buf, (void *)addr, 8);
    5258:	682b      	ldr	r3, [r5, #0]
    525a:	600b      	str	r3, [r1, #0]
    525c:	686b      	ldr	r3, [r5, #4]
    525e:	604b      	str	r3, [r1, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    5260:	2310      	movs	r3, #16
    5262:	f882 3107 	strb.w	r3, [r2, #263]	; 0x107
	_usbd_ep_ack_setup(epn);

	return bytes;
    5266:	4620      	mov	r0, r4
}
    5268:	bd30      	pop	{r4, r5, pc}
		return -USB_ERR_PARAM;
    526a:	f06f 0011 	mvn.w	r0, #17
    526e:	e7fb      	b.n	5268 <_usb_d_dev_ep_read_req+0x40>
		return -USB_ERR_FUNC;
    5270:	f06f 0012 	mvn.w	r0, #18
    5274:	e7f8      	b.n	5268 <_usb_d_dev_ep_read_req+0x40>
    5276:	bf00      	nop
    5278:	2000178c 	.word	0x2000178c

0000527c <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    527c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    5280:	7a07      	ldrb	r7, [r0, #8]
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    5282:	4b39      	ldr	r3, [pc, #228]	; (5368 <_usb_d_dev_ep_trans+0xec>)
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    5284:	f007 050f 	and.w	r5, r7, #15
    5288:	b27f      	sxtb	r7, r7
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    528a:	ea4f 79d7 	mov.w	r9, r7, lsr #31
{
    528e:	4680      	mov	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    5290:	4649      	mov	r1, r9
    5292:	4628      	mov	r0, r5
    5294:	4798      	blx	r3

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    5296:	8a02      	ldrh	r2, [r0, #16]
	bool     size_n_aligned = (trans->size & size_mask);
    5298:	f8d8 1004 	ldr.w	r1, [r8, #4]
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    529c:	f240 33ff 	movw	r3, #1023	; 0x3ff
    52a0:	429a      	cmp	r2, r3
    52a2:	bf1a      	itte	ne
    52a4:	f102 33ff 	addne.w	r3, r2, #4294967295	; 0xffffffff
    52a8:	b29b      	uxthne	r3, r3
    52aa:	4613      	moveq	r3, r2

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    52ac:	2d02      	cmp	r5, #2
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    52ae:	4604      	mov	r4, r0
	bool     size_n_aligned = (trans->size & size_mask);
    52b0:	ea03 0601 	and.w	r6, r3, r1
	if (epn > CONF_USB_D_MAX_EP_N) {
    52b4:	d828      	bhi.n	5308 <_usb_d_dev_ep_trans+0x8c>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    52b6:	f8d8 5000 	ldr.w	r5, [r8]
    52ba:	f1b5 5f00 	cmp.w	r5, #536870912	; 0x20000000
    52be:	d30a      	bcc.n	52d6 <_usb_d_dev_ep_trans+0x5a>
    52c0:	4b2a      	ldr	r3, [pc, #168]	; (536c <_usb_d_dev_ep_trans+0xf0>)
    52c2:	1948      	adds	r0, r1, r5
    52c4:	4298      	cmp	r0, r3
    52c6:	d806      	bhi.n	52d6 <_usb_d_dev_ep_trans+0x5a>
    52c8:	f015 0503 	ands.w	r5, r5, #3
    52cc:	d103      	bne.n	52d6 <_usb_d_dev_ep_trans+0x5a>
	    || (!dir && (trans->size < ept->size))) {
    52ce:	2f00      	cmp	r7, #0
    52d0:	db05      	blt.n	52de <_usb_d_dev_ep_trans+0x62>
    52d2:	4291      	cmp	r1, r2
    52d4:	d214      	bcs.n	5300 <_usb_d_dev_ep_trans+0x84>
		if (!ept->cache) {
    52d6:	68e3      	ldr	r3, [r4, #12]
    52d8:	2b00      	cmp	r3, #0
    52da:	d040      	beq.n	535e <_usb_d_dev_ep_trans+0xe2>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
    52dc:	2501      	movs	r5, #1
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    52de:	7ce3      	ldrb	r3, [r4, #19]
    52e0:	071b      	lsls	r3, r3, #28
    52e2:	d43f      	bmi.n	5364 <_usb_d_dev_ep_trans+0xe8>
		return USB_HALTED;
	}

	/* Try to start transactions. */

	atomic_enter_critical(&flags);
    52e4:	4b22      	ldr	r3, [pc, #136]	; (5370 <_usb_d_dev_ep_trans+0xf4>)
    52e6:	a801      	add	r0, sp, #4
    52e8:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    52ea:	7ce3      	ldrb	r3, [r4, #19]
    52ec:	4a21      	ldr	r2, [pc, #132]	; (5374 <_usb_d_dev_ep_trans+0xf8>)
    52ee:	f013 0a40 	ands.w	sl, r3, #64	; 0x40
    52f2:	d00e      	beq.n	5312 <_usb_d_dev_ep_trans+0x96>
		atomic_leave_critical(&flags);
    52f4:	a801      	add	r0, sp, #4
    52f6:	4790      	blx	r2
		return USB_BUSY;
    52f8:	2001      	movs	r0, #1
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    52fa:	b002      	add	sp, #8
    52fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!dir && size_n_aligned) {
    5300:	b12e      	cbz	r6, 530e <_usb_d_dev_ep_trans+0x92>
		if (!ept->cache) {
    5302:	68e3      	ldr	r3, [r4, #12]
    5304:	2b00      	cmp	r3, #0
    5306:	d1ea      	bne.n	52de <_usb_d_dev_ep_trans+0x62>
		return -USB_ERR_PARAM;
    5308:	f06f 0011 	mvn.w	r0, #17
    530c:	e7f5      	b.n	52fa <_usb_d_dev_ep_trans+0x7e>
	bool use_cache = false;
    530e:	4635      	mov	r5, r6
    5310:	e7e5      	b.n	52de <_usb_d_dev_ep_trans+0x62>
	ept->flags.bits.is_busy = 1;
    5312:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    5316:	74e3      	strb	r3, [r4, #19]
	atomic_leave_critical(&flags);
    5318:	a801      	add	r0, sp, #4
    531a:	4790      	blx	r2
	ept->trans_buf   = trans->buf;
    531c:	f8d8 3000 	ldr.w	r3, [r8]
    5320:	6023      	str	r3, [r4, #0]
	ept->trans_size  = trans->size;
    5322:	f8d8 3004 	ldr.w	r3, [r8, #4]
	ept->trans_count = 0;
    5326:	e9c4 3a01 	strd	r3, sl, [r4, #4]
	ept->flags.bits.dir       = dir;
    532a:	7ce3      	ldrb	r3, [r4, #19]
    532c:	f369 13c7 	bfi	r3, r9, #7, #1
	ept->flags.bits.use_cache = use_cache;
    5330:	f365 1345 	bfi	r3, r5, #5, #1
    5334:	74e3      	strb	r3, [r4, #19]
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    5336:	f898 3009 	ldrb.w	r3, [r8, #9]
    533a:	b113      	cbz	r3, 5342 <_usb_d_dev_ep_trans+0xc6>
    533c:	fab6 f386 	clz	r3, r6
    5340:	095b      	lsrs	r3, r3, #5
    5342:	7ce2      	ldrb	r2, [r4, #19]
	if (dir) {
    5344:	2f00      	cmp	r7, #0
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    5346:	f363 1204 	bfi	r2, r3, #4, #1
		_usb_d_dev_in_next(ept, false);
    534a:	4620      	mov	r0, r4
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    534c:	74e2      	strb	r2, [r4, #19]
		_usb_d_dev_in_next(ept, false);
    534e:	f04f 0100 	mov.w	r1, #0
    5352:	bfb4      	ite	lt
    5354:	4b08      	ldrlt	r3, [pc, #32]	; (5378 <_usb_d_dev_ep_trans+0xfc>)
		_usb_d_dev_out_next(ept, false);
    5356:	4b09      	ldrge	r3, [pc, #36]	; (537c <_usb_d_dev_ep_trans+0x100>)
    5358:	4798      	blx	r3
	return ERR_NONE;
    535a:	2000      	movs	r0, #0
    535c:	e7cd      	b.n	52fa <_usb_d_dev_ep_trans+0x7e>
			return -USB_ERR_FUNC;
    535e:	f06f 0012 	mvn.w	r0, #18
    5362:	e7ca      	b.n	52fa <_usb_d_dev_ep_trans+0x7e>
		return USB_HALTED;
    5364:	2002      	movs	r0, #2
    5366:	e7c8      	b.n	52fa <_usb_d_dev_ep_trans+0x7e>
    5368:	000045d9 	.word	0x000045d9
    536c:	20031fff 	.word	0x20031fff
    5370:	00006225 	.word	0x00006225
    5374:	00006233 	.word	0x00006233
    5378:	00004839 	.word	0x00004839
    537c:	00004995 	.word	0x00004995

00005380 <_usb_d_dev_register_callback>:
	return USB_OK;
}

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    5380:	4b06      	ldr	r3, [pc, #24]	; (539c <_usb_d_dev_register_callback+0x1c>)
    5382:	2900      	cmp	r1, #0
    5384:	bf08      	it	eq
    5386:	4619      	moveq	r1, r3
	if (type == USB_D_CB_EVENT) {
    5388:	2801      	cmp	r0, #1
    538a:	d102      	bne.n	5392 <_usb_d_dev_register_callback+0x12>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
    538c:	4b04      	ldr	r3, [pc, #16]	; (53a0 <_usb_d_dev_register_callback+0x20>)
    538e:	6059      	str	r1, [r3, #4]
    5390:	4770      	bx	lr
	} else if (type == USB_D_CB_SOF) {
    5392:	b908      	cbnz	r0, 5398 <_usb_d_dev_register_callback+0x18>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
    5394:	4b02      	ldr	r3, [pc, #8]	; (53a0 <_usb_d_dev_register_callback+0x20>)
    5396:	6019      	str	r1, [r3, #0]
	}
}
    5398:	4770      	bx	lr
    539a:	bf00      	nop
    539c:	000045b1 	.word	0x000045b1
    53a0:	200016c4 	.word	0x200016c4

000053a4 <_usb_d_dev_register_ep_callback>:

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    53a4:	4b08      	ldr	r3, [pc, #32]	; (53c8 <_usb_d_dev_register_ep_callback+0x24>)
    53a6:	2900      	cmp	r1, #0
    53a8:	bf08      	it	eq
    53aa:	4619      	moveq	r1, r3
	if (type == USB_D_DEV_EP_CB_SETUP) {
    53ac:	b910      	cbnz	r0, 53b4 <_usb_d_dev_register_ep_callback+0x10>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    53ae:	4b07      	ldr	r3, [pc, #28]	; (53cc <_usb_d_dev_register_ep_callback+0x28>)
    53b0:	6099      	str	r1, [r3, #8]
    53b2:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    53b4:	2801      	cmp	r0, #1
    53b6:	d102      	bne.n	53be <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    53b8:	4b04      	ldr	r3, [pc, #16]	; (53cc <_usb_d_dev_register_ep_callback+0x28>)
    53ba:	60d9      	str	r1, [r3, #12]
    53bc:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    53be:	2802      	cmp	r0, #2
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    53c0:	bf04      	itt	eq
    53c2:	4b02      	ldreq	r3, [pc, #8]	; (53cc <_usb_d_dev_register_ep_callback+0x28>)
    53c4:	6119      	streq	r1, [r3, #16]
	}
}
    53c6:	4770      	bx	lr
    53c8:	000045b1 	.word	0x000045b1
    53cc:	200016c4 	.word	0x200016c4

000053d0 <USB_0_Handler>:
 * \brief USB interrupt handler
 */
void USB_0_Handler(void)
{

	_usb_d_dev_handler();
    53d0:	4b00      	ldr	r3, [pc, #0]	; (53d4 <USB_0_Handler+0x4>)
    53d2:	4718      	bx	r3
    53d4:	00004b41 	.word	0x00004b41

000053d8 <USB_1_Handler>:
    53d8:	4b00      	ldr	r3, [pc, #0]	; (53dc <USB_1_Handler+0x4>)
    53da:	4718      	bx	r3
    53dc:	00004b41 	.word	0x00004b41

000053e0 <USB_2_Handler>:
    53e0:	4b00      	ldr	r3, [pc, #0]	; (53e4 <USB_2_Handler+0x4>)
    53e2:	4718      	bx	r3
    53e4:	00004b41 	.word	0x00004b41

000053e8 <USB_3_Handler>:
    53e8:	4b00      	ldr	r3, [pc, #0]	; (53ec <USB_3_Handler+0x4>)
    53ea:	4718      	bx	r3
    53ec:	00004b41 	.word	0x00004b41

000053f0 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    53f0:	6800      	ldr	r0, [r0, #0]
    53f2:	b900      	cbnz	r0, 53f6 <is_list_element+0x6>
    53f4:	4770      	bx	lr
		if (it == element) {
    53f6:	4288      	cmp	r0, r1
    53f8:	d1fa      	bne.n	53f0 <is_list_element>
			return true;
    53fa:	2001      	movs	r0, #1
		}
	}

	return false;
}
    53fc:	4770      	bx	lr
	...

00005400 <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
    5400:	b570      	push	{r4, r5, r6, lr}
	struct list_element *it = list->head;

	ASSERT(!is_list_element(list, element));
    5402:	4b0b      	ldr	r3, [pc, #44]	; (5430 <list_insert_at_end+0x30>)
	struct list_element *it = list->head;
    5404:	6805      	ldr	r5, [r0, #0]
{
    5406:	4606      	mov	r6, r0
    5408:	460c      	mov	r4, r1
	ASSERT(!is_list_element(list, element));
    540a:	4798      	blx	r3
    540c:	f080 0001 	eor.w	r0, r0, #1
    5410:	4b08      	ldr	r3, [pc, #32]	; (5434 <list_insert_at_end+0x34>)
    5412:	4909      	ldr	r1, [pc, #36]	; (5438 <list_insert_at_end+0x38>)
    5414:	224f      	movs	r2, #79	; 0x4f
    5416:	b2c0      	uxtb	r0, r0
    5418:	4798      	blx	r3

	if (!list->head) {
    541a:	6833      	ldr	r3, [r6, #0]
    541c:	b91b      	cbnz	r3, 5426 <list_insert_at_end+0x26>
		list->head                             = (struct list_element *)element;
    541e:	6034      	str	r4, [r6, #0]

	while (it->next) {
		it = it->next;
	}
	it->next                               = (struct list_element *)element;
	((struct list_element *)element)->next = NULL;
    5420:	6023      	str	r3, [r4, #0]
}
    5422:	bd70      	pop	{r4, r5, r6, pc}
    5424:	461d      	mov	r5, r3
	while (it->next) {
    5426:	682b      	ldr	r3, [r5, #0]
    5428:	2b00      	cmp	r3, #0
    542a:	d1fb      	bne.n	5424 <list_insert_at_end+0x24>
	it->next                               = (struct list_element *)element;
    542c:	602c      	str	r4, [r5, #0]
    542e:	e7f7      	b.n	5420 <list_insert_at_end+0x20>
    5430:	000053f1 	.word	0x000053f1
    5434:	0000543d 	.word	0x0000543d
    5438:	00007a80 	.word	0x00007a80

0000543c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    543c:	b900      	cbnz	r0, 5440 <assert+0x4>
		__asm("BKPT #0");
    543e:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    5440:	4770      	bx	lr

00005442 <usb_device_cb_bulk_in>:
static bool usb_device_cb_bulk_in(const uint8_t ep,
                                  const enum usb_xfer_code rc,
                                  const uint32_t count) {
    // No error. //
    return false;
}
    5442:	2000      	movs	r0, #0
    5444:	4770      	bx	lr
	...

00005448 <usb_device_cb_bulk_out>:
                                   const uint32_t count) {
    5448:	b508      	push	{r3, lr}
    cdcdf_acm_read((uint8_t *) usbd_cdc_in_buffer,
    544a:	2110      	movs	r1, #16
    544c:	4b02      	ldr	r3, [pc, #8]	; (5458 <usb_device_cb_bulk_out+0x10>)
    544e:	4803      	ldr	r0, [pc, #12]	; (545c <usb_device_cb_bulk_out+0x14>)
    5450:	4798      	blx	r3
}
    5452:	2000      	movs	r0, #0
    5454:	bd08      	pop	{r3, pc}
    5456:	bf00      	nop
    5458:	000044f1 	.word	0x000044f1
    545c:	20001998 	.word	0x20001998

00005460 <usb_device_cb_state_c>:

/**
 * \brief Callback invoked when Line State Change
 */
static bool usb_device_cb_state_c(usb_cdc_control_signal_t state) {
    5460:	b513      	push	{r0, r1, r4, lr}
    if (state.rs232.DTR) {
    5462:	07c3      	lsls	r3, r0, #31
static bool usb_device_cb_state_c(usb_cdc_control_signal_t state) {
    5464:	f8ad 0004 	strh.w	r0, [sp, #4]
    if (state.rs232.DTR) {
    5468:	d50a      	bpl.n	5480 <usb_device_cb_state_c+0x20>
        // Callbacks must be registered after endpoint allocation
        cdcdf_acm_register_callback(CDCDF_ACM_CB_READ,
    546a:	4907      	ldr	r1, [pc, #28]	; (5488 <usb_device_cb_state_c+0x28>)
    546c:	4c07      	ldr	r4, [pc, #28]	; (548c <usb_device_cb_state_c+0x2c>)
    546e:	2000      	movs	r0, #0
    5470:	47a0      	blx	r4
                                    (FUNC_PTR) usb_device_cb_bulk_in);
        cdcdf_acm_register_callback(CDCDF_ACM_CB_WRITE,
    5472:	4907      	ldr	r1, [pc, #28]	; (5490 <usb_device_cb_state_c+0x30>)
    5474:	2001      	movs	r0, #1
    5476:	47a0      	blx	r4
                                    (FUNC_PTR) usb_device_cb_bulk_out);
        // Start Rx
        cdcdf_acm_read((uint8_t *) usbd_cdc_in_buffer,
    5478:	2110      	movs	r1, #16
    547a:	4806      	ldr	r0, [pc, #24]	; (5494 <usb_device_cb_state_c+0x34>)
    547c:	4b06      	ldr	r3, [pc, #24]	; (5498 <usb_device_cb_state_c+0x38>)
    547e:	4798      	blx	r3
                       sizeof(usbd_cdc_in_buffer));
    }
    /* No error. */
    return false;
}
    5480:	2000      	movs	r0, #0
    5482:	b002      	add	sp, #8
    5484:	bd10      	pop	{r4, pc}
    5486:	bf00      	nop
    5488:	00005443 	.word	0x00005443
    548c:	00004549 	.word	0x00004549
    5490:	00005449 	.word	0x00005449
    5494:	20001998 	.word	0x20001998
    5498:	000044f1 	.word	0x000044f1

0000549c <cdc_device_acm_init>:

/**
 * \brief CDC ACM Init
 */
void cdc_device_acm_init(void) {
    549c:	b510      	push	{r4, lr}
    // usb stack init
    usbdc_init(ctrl_buffer);
    549e:	4b06      	ldr	r3, [pc, #24]	; (54b8 <cdc_device_acm_init+0x1c>)
    54a0:	4806      	ldr	r0, [pc, #24]	; (54bc <cdc_device_acm_init+0x20>)
    54a2:	4798      	blx	r3

    // usbdc_register_funcion inside
    cdcdf_acm_init();
    54a4:	4b06      	ldr	r3, [pc, #24]	; (54c0 <cdc_device_acm_init+0x24>)
    54a6:	4798      	blx	r3

    usbdc_start(single_desc);
    54a8:	4b06      	ldr	r3, [pc, #24]	; (54c4 <cdc_device_acm_init+0x28>)
    54aa:	4807      	ldr	r0, [pc, #28]	; (54c8 <cdc_device_acm_init+0x2c>)
    54ac:	4798      	blx	r3
    usbdc_attach();
    54ae:	4b07      	ldr	r3, [pc, #28]	; (54cc <cdc_device_acm_init+0x30>)
}
    54b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    usbdc_attach();
    54b4:	4718      	bx	r3
    54b6:	bf00      	nop
    54b8:	0000615d 	.word	0x0000615d
    54bc:	200018ac 	.word	0x200018ac
    54c0:	000044ad 	.word	0x000044ad
    54c4:	000061c9 	.word	0x000061c9
    54c8:	20000008 	.word	0x20000008
    54cc:	000061fd 	.word	0x000061fd

000054d0 <cdcd_acm_example>:
 * - Connect the TARGET USB on XPLAINED board to PC for running program.
 * The application will behave as a virtual COM.
 * - Open a HyperTerminal or other COM tools in PC side.
 * - Send out a character or string and it will echo the content received.
 */
void cdcd_acm_example(void) {
    54d0:	b508      	push	{r3, lr}
    while (!cdcdf_acm_is_enabled()) {
    54d2:	4c05      	ldr	r4, [pc, #20]	; (54e8 <cdcd_acm_example+0x18>)
    54d4:	47a0      	blx	r4
    54d6:	2800      	cmp	r0, #0
    54d8:	d0fc      	beq.n	54d4 <cdcd_acm_example+0x4>
        // wait cdc acm to be installed
    };

    cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C,
    54da:	4b04      	ldr	r3, [pc, #16]	; (54ec <cdcd_acm_example+0x1c>)
    54dc:	4904      	ldr	r1, [pc, #16]	; (54f0 <cdcd_acm_example+0x20>)
    54de:	2003      	movs	r0, #3
    54e0:	4798      	blx	r3
                                (FUNC_PTR) usb_device_cb_state_c);

    camelforth();
    54e2:	4b04      	ldr	r3, [pc, #16]	; (54f4 <cdcd_acm_example+0x24>)
    54e4:	4798      	blx	r3
    54e6:	e7fe      	b.n	54e6 <cdcd_acm_example+0x16>
    54e8:	00004589 	.word	0x00004589
    54ec:	00004549 	.word	0x00004549
    54f0:	00005461 	.word	0x00005461
    54f4:	00006dd9 	.word	0x00006dd9

000054f8 <usb_init>:
    while (1) {
    }
}

void usb_init(void) {
    cdc_device_acm_init();
    54f8:	4b00      	ldr	r3, [pc, #0]	; (54fc <usb_init+0x4>)
    54fa:	4718      	bx	r3
    54fc:	0000549d 	.word	0x0000549d

00005500 <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    5500:	4a0b      	ldr	r2, [pc, #44]	; (5530 <RAMECC_Handler+0x30>)
    5502:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    5504:	b082      	sub	sp, #8
    5506:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    5508:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    550a:	9b01      	ldr	r3, [sp, #4]
    550c:	0799      	lsls	r1, r3, #30
    550e:	d505      	bpl.n	551c <RAMECC_Handler+0x1c>
    5510:	4b08      	ldr	r3, [pc, #32]	; (5534 <RAMECC_Handler+0x34>)
    5512:	681b      	ldr	r3, [r3, #0]
    5514:	b113      	cbz	r3, 551c <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    5516:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    5518:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    551a:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    551c:	9b01      	ldr	r3, [sp, #4]
    551e:	07db      	lsls	r3, r3, #31
    5520:	d504      	bpl.n	552c <RAMECC_Handler+0x2c>
    5522:	4b04      	ldr	r3, [pc, #16]	; (5534 <RAMECC_Handler+0x34>)
    5524:	685b      	ldr	r3, [r3, #4]
    5526:	b10b      	cbz	r3, 552c <RAMECC_Handler+0x2c>
    5528:	4a01      	ldr	r2, [pc, #4]	; (5530 <RAMECC_Handler+0x30>)
    552a:	e7f4      	b.n	5516 <RAMECC_Handler+0x16>
}
    552c:	b002      	add	sp, #8
    552e:	4770      	bx	lr
    5530:	41020000 	.word	0x41020000
    5534:	200019a8 	.word	0x200019a8

00005538 <usb_find_desc>:
#define _param_error_check(cond) ASSERT(cond)
#define _desc_len_check() ASSERT(usb_desc_len(desc) >= 2)
#endif

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
    5538:	b510      	push	{r4, lr}
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    553a:	4288      	cmp	r0, r1
    553c:	d301      	bcc.n	5542 <usb_find_desc+0xa>
		_desc_len_check();
    553e:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    5540:	bd10      	pop	{r4, pc}
		_desc_len_check();
    5542:	7803      	ldrb	r3, [r0, #0]
    5544:	2b01      	cmp	r3, #1
    5546:	d9fa      	bls.n	553e <usb_find_desc+0x6>
		if (type == usb_desc_type(desc)) {
    5548:	7844      	ldrb	r4, [r0, #1]
    554a:	4294      	cmp	r4, r2
    554c:	d0f8      	beq.n	5540 <usb_find_desc+0x8>
    554e:	4418      	add	r0, r3
    5550:	e7f3      	b.n	553a <usb_find_desc+0x2>

00005552 <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    5552:	4288      	cmp	r0, r1
    5554:	d301      	bcc.n	555a <usb_find_ep_desc+0x8>
		_desc_len_check();
    5556:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    5558:	4770      	bx	lr
		_desc_len_check();
    555a:	7803      	ldrb	r3, [r0, #0]
    555c:	2b01      	cmp	r3, #1
    555e:	d9fa      	bls.n	5556 <usb_find_ep_desc+0x4>
	return desc[1];
    5560:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    5562:	2a04      	cmp	r2, #4
    5564:	d0f7      	beq.n	5556 <usb_find_ep_desc+0x4>
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    5566:	2a05      	cmp	r2, #5
    5568:	d0f6      	beq.n	5558 <usb_find_ep_desc+0x6>
	return (desc + usb_desc_len(desc));
    556a:	4418      	add	r0, r3
    556c:	e7f1      	b.n	5552 <usb_find_ep_desc>
	...

00005570 <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
    5570:	b538      	push	{r3, r4, r5, lr}
    5572:	4615      	mov	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    5574:	4b0c      	ldr	r3, [pc, #48]	; (55a8 <usb_find_cfg_desc+0x38>)
    5576:	2202      	movs	r2, #2
{
    5578:	460c      	mov	r4, r1
	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    557a:	4798      	blx	r3
	if (!desc) {
    557c:	b978      	cbnz	r0, 559e <usb_find_cfg_desc+0x2e>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
}
    557e:	bd38      	pop	{r3, r4, r5, pc}
		_desc_len_check();
    5580:	7803      	ldrb	r3, [r0, #0]
    5582:	2b01      	cmp	r3, #1
    5584:	d90d      	bls.n	55a2 <usb_find_cfg_desc+0x32>
		if (desc[1] != USB_DT_CONFIG) {
    5586:	7843      	ldrb	r3, [r0, #1]
    5588:	2b02      	cmp	r3, #2
    558a:	d10a      	bne.n	55a2 <usb_find_cfg_desc+0x32>
		if (desc[5] == cfg_value) {
    558c:	7943      	ldrb	r3, [r0, #5]
    558e:	42ab      	cmp	r3, r5
    5590:	d0f5      	beq.n	557e <usb_find_cfg_desc+0xe>
	return (ptr[0] + (ptr[1] << 8));
    5592:	78c2      	ldrb	r2, [r0, #3]
    5594:	7883      	ldrb	r3, [r0, #2]
    5596:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
    559a:	fa10 f083 	uxtah	r0, r0, r3
	while (desc < eof) {
    559e:	42a0      	cmp	r0, r4
    55a0:	d3ee      	bcc.n	5580 <usb_find_cfg_desc+0x10>
		return NULL;
    55a2:	2000      	movs	r0, #0
    55a4:	e7eb      	b.n	557e <usb_find_cfg_desc+0xe>
    55a6:	bf00      	nop
    55a8:	00005539 	.word	0x00005539

000055ac <usb_find_str_desc>:
	}
	return NULL;
}

uint8_t *usb_find_str_desc(uint8_t *desc, uint8_t *eof, uint8_t str_index)
{
    55ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    55ae:	4f0a      	ldr	r7, [pc, #40]	; (55d8 <usb_find_str_desc+0x2c>)
{
    55b0:	460d      	mov	r5, r1
    55b2:	4616      	mov	r6, r2
	for (i = 0; desc < eof;) {
    55b4:	2400      	movs	r4, #0
    55b6:	42a8      	cmp	r0, r5
    55b8:	d301      	bcc.n	55be <usb_find_str_desc+0x12>
				return desc;
			}
			i++;
			desc = usb_desc_next(desc);
		} else {
			return NULL;
    55ba:	2000      	movs	r0, #0
		}
	}
	return NULL;
}
    55bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    55be:	2203      	movs	r2, #3
    55c0:	4629      	mov	r1, r5
    55c2:	47b8      	blx	r7
		if (desc) {
    55c4:	2800      	cmp	r0, #0
    55c6:	d0f9      	beq.n	55bc <usb_find_str_desc+0x10>
			_desc_len_check();
    55c8:	7803      	ldrb	r3, [r0, #0]
    55ca:	2b01      	cmp	r3, #1
    55cc:	d9f5      	bls.n	55ba <usb_find_str_desc+0xe>
			if (i == str_index) {
    55ce:	42b4      	cmp	r4, r6
    55d0:	d0f4      	beq.n	55bc <usb_find_str_desc+0x10>
	return (desc + usb_desc_len(desc));
    55d2:	4418      	add	r0, r3
    55d4:	3401      	adds	r4, #1
    55d6:	e7ee      	b.n	55b6 <usb_find_str_desc+0xa>
    55d8:	00005539 	.word	0x00005539

000055dc <_usb_d_find_ep>:
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    55dc:	490a      	ldr	r1, [pc, #40]	; (5608 <_usb_d_find_ep+0x2c>)
{
    55de:	b570      	push	{r4, r5, r6, lr}
    55e0:	2300      	movs	r3, #0
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    55e2:	f000 060f 	and.w	r6, r0, #15
    55e6:	015d      	lsls	r5, r3, #5
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    55e8:	194c      	adds	r4, r1, r5
    55ea:	b25a      	sxtb	r2, r3
    55ec:	7864      	ldrb	r4, [r4, #1]
    55ee:	4284      	cmp	r4, r0
    55f0:	d008      	beq.n	5604 <_usb_d_find_ep+0x28>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    55f2:	5c6d      	ldrb	r5, [r5, r1]
    55f4:	b90d      	cbnz	r5, 55fa <_usb_d_find_ep+0x1e>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    55f6:	42b4      	cmp	r4, r6
    55f8:	d004      	beq.n	5604 <_usb_d_find_ep+0x28>
    55fa:	3301      	adds	r3, #1
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    55fc:	2b04      	cmp	r3, #4
    55fe:	d1f2      	bne.n	55e6 <_usb_d_find_ep+0xa>
			return i;
		}
	}
	return -1;
    5600:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
}
    5604:	4610      	mov	r0, r2
    5606:	bd70      	pop	{r4, r5, r6, pc}
    5608:	200018ec 	.word	0x200018ec

0000560c <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    560c:	2000      	movs	r0, #0
    560e:	4770      	bx	lr

00005610 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    5610:	b570      	push	{r4, r5, r6, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    5612:	4b09      	ldr	r3, [pc, #36]	; (5638 <usb_d_cb_trans_more+0x28>)
{
    5614:	4604      	mov	r4, r0
    5616:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    5618:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    561a:	4b08      	ldr	r3, [pc, #32]	; (563c <usb_d_cb_trans_more+0x2c>)
    561c:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    5620:	7883      	ldrb	r3, [r0, #2]
    5622:	2b03      	cmp	r3, #3
    5624:	d105      	bne.n	5632 <usb_d_cb_trans_more+0x22>
		return ept->callbacks.more(ep, transfered);
    5626:	6983      	ldr	r3, [r0, #24]
    5628:	4629      	mov	r1, r5
    562a:	4620      	mov	r0, r4
	}
	return false;
}
    562c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return ept->callbacks.more(ep, transfered);
    5630:	4718      	bx	r3
}
    5632:	2000      	movs	r0, #0
    5634:	bd70      	pop	{r4, r5, r6, pc}
    5636:	bf00      	nop
    5638:	000055dd 	.word	0x000055dd
    563c:	200018ec 	.word	0x200018ec

00005640 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    5640:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    5644:	4b37      	ldr	r3, [pc, #220]	; (5724 <_usb_d_cb_trans_done+0xe4>)
    5646:	4c38      	ldr	r4, [pc, #224]	; (5728 <_usb_d_cb_trans_done+0xe8>)
{
    5648:	b085      	sub	sp, #20
    564a:	4680      	mov	r8, r0
    564c:	460f      	mov	r7, r1
    564e:	4691      	mov	r9, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    5650:	4798      	blx	r3
    5652:	0146      	lsls	r6, r0, #5
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
    5654:	2f00      	cmp	r7, #0
    5656:	d142      	bne.n	56de <_usb_d_cb_trans_done+0x9e>
		ept->xfer.hdr.status = USB_XFER_DONE;
    5658:	19a5      	adds	r5, r4, r6
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    565a:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_DONE;
    565c:	70ef      	strb	r7, [r5, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    565e:	2900      	cmp	r1, #0
    5660:	d134      	bne.n	56cc <_usb_d_cb_trans_done+0x8c>
    5662:	230c      	movs	r3, #12
    5664:	2220      	movs	r2, #32
    5666:	fb12 3200 	smlabb	r2, r2, r0, r3
	if (state == USB_EP_S_X_DATA) {
    566a:	78ab      	ldrb	r3, [r5, #2]
    566c:	7868      	ldrb	r0, [r5, #1]
    566e:	2b03      	cmp	r3, #3
    5670:	4422      	add	r2, r4
    5672:	69eb      	ldr	r3, [r5, #28]
    5674:	d126      	bne.n	56c4 <_usb_d_cb_trans_done+0x84>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    5676:	2101      	movs	r1, #1
    5678:	f995 400c 	ldrsb.w	r4, [r5, #12]
    567c:	4798      	blx	r3
    567e:	786b      	ldrb	r3, [r5, #1]
		if (err) {
    5680:	b168      	cbz	r0, 569e <_usb_d_cb_trans_done+0x5e>
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    5682:	2c00      	cmp	r4, #0
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    5684:	f240 2205 	movw	r2, #517	; 0x205
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    5688:	bfb4      	ite	lt
    568a:	4618      	movlt	r0, r3
    568c:	f043 0080 	orrge.w	r0, r3, #128	; 0x80
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    5690:	806a      	strh	r2, [r5, #2]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    5692:	2101      	movs	r1, #1
    5694:	4b25      	ldr	r3, [pc, #148]	; (572c <_usb_d_cb_trans_done+0xec>)
    5696:	4798      	blx	r3
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
}
    5698:	b005      	add	sp, #20
    569a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct usb_d_transfer trans
    569e:	2c00      	cmp	r4, #0
    56a0:	bfac      	ite	ge
    56a2:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
    56a6:	f003 030f 	andlt.w	r3, r3, #15
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    56aa:	2204      	movs	r2, #4
	struct usb_d_transfer trans
    56ac:	f88d 300c 	strb.w	r3, [sp, #12]
    56b0:	2301      	movs	r3, #1
    56b2:	e9cd 0001 	strd	r0, r0, [sp, #4]
    56b6:	f88d 300d 	strb.w	r3, [sp, #13]
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    56ba:	70aa      	strb	r2, [r5, #2]
	return _usb_d_dev_ep_trans(&trans);
    56bc:	a801      	add	r0, sp, #4
    56be:	4b1c      	ldr	r3, [pc, #112]	; (5730 <_usb_d_cb_trans_done+0xf0>)
    56c0:	4798      	blx	r3
    56c2:	e7e9      	b.n	5698 <_usb_d_cb_trans_done+0x58>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    56c4:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    56c6:	2302      	movs	r3, #2
    56c8:	70ab      	strb	r3, [r5, #2]
    56ca:	e7e5      	b.n	5698 <_usb_d_cb_trans_done+0x58>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    56cc:	2301      	movs	r3, #1
    56ce:	70ab      	strb	r3, [r5, #2]
	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    56d0:	4434      	add	r4, r6
    56d2:	464a      	mov	r2, r9
    56d4:	69e3      	ldr	r3, [r4, #28]
    56d6:	78e1      	ldrb	r1, [r4, #3]
    56d8:	4640      	mov	r0, r8
    56da:	4798      	blx	r3
    56dc:	e7dc      	b.n	5698 <_usb_d_cb_trans_done+0x58>
	} else if (code == USB_TRANS_STALL) {
    56de:	2f01      	cmp	r7, #1
		ept->xfer.hdr.status = USB_XFER_HALT;
    56e0:	eb04 0306 	add.w	r3, r4, r6
	} else if (code == USB_TRANS_STALL) {
    56e4:	d10b      	bne.n	56fe <_usb_d_cb_trans_done+0xbe>
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    56e6:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_HALT;
    56e8:	2202      	movs	r2, #2
    56ea:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    56ec:	b921      	cbnz	r1, 56f8 <_usb_d_cb_trans_done+0xb8>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    56ee:	709a      	strb	r2, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    56f0:	4640      	mov	r0, r8
    56f2:	4b0e      	ldr	r3, [pc, #56]	; (572c <_usb_d_cb_trans_done+0xec>)
    56f4:	4798      	blx	r3
    56f6:	e7eb      	b.n	56d0 <_usb_d_cb_trans_done+0x90>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    56f8:	2205      	movs	r2, #5
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    56fa:	709a      	strb	r2, [r3, #2]
    56fc:	e7e8      	b.n	56d0 <_usb_d_cb_trans_done+0x90>
	} else if (code == USB_TRANS_ABORT) {
    56fe:	2f02      	cmp	r7, #2
    5700:	d107      	bne.n	5712 <_usb_d_cb_trans_done+0xd2>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    5702:	2204      	movs	r2, #4
    5704:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    5706:	5da2      	ldrb	r2, [r4, r6]
    5708:	b90a      	cbnz	r2, 570e <_usb_d_cb_trans_done+0xce>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    570a:	709f      	strb	r7, [r3, #2]
			return;
    570c:	e7c4      	b.n	5698 <_usb_d_cb_trans_done+0x58>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    570e:	2201      	movs	r2, #1
    5710:	e7f3      	b.n	56fa <_usb_d_cb_trans_done+0xba>
	} else if (code == USB_TRANS_RESET) {
    5712:	2f03      	cmp	r7, #3
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    5714:	bf0c      	ite	eq
    5716:	f44f 62a0 	moveq.w	r2, #1280	; 0x500
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    571a:	f240 6206 	movwne	r2, #1542	; 0x606
    571e:	805a      	strh	r2, [r3, #2]
    5720:	e7d6      	b.n	56d0 <_usb_d_cb_trans_done+0x90>
    5722:	bf00      	nop
    5724:	000055dd 	.word	0x000055dd
    5728:	200018ec 	.word	0x200018ec
    572c:	00005159 	.word	0x00005159
    5730:	0000527d 	.word	0x0000527d

00005734 <usb_d_cb_trans_setup>:
{
    5734:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    5738:	4b19      	ldr	r3, [pc, #100]	; (57a0 <usb_d_cb_trans_setup+0x6c>)
	uint8_t *        req      = ept->xfer.req;
    573a:	4e1a      	ldr	r6, [pc, #104]	; (57a4 <usb_d_cb_trans_setup+0x70>)
    573c:	4c1a      	ldr	r4, [pc, #104]	; (57a8 <usb_d_cb_trans_setup+0x74>)
{
    573e:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    5740:	4798      	blx	r3
	uint8_t *        req      = ept->xfer.req;
    5742:	2720      	movs	r7, #32
    5744:	230c      	movs	r3, #12
    5746:	fb17 3700 	smlabb	r7, r7, r0, r3
    574a:	4437      	add	r7, r6
	int8_t           ep_index = _usb_d_find_ep(ep);
    574c:	4681      	mov	r9, r0
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    574e:	4639      	mov	r1, r7
    5750:	4628      	mov	r0, r5
    5752:	4b16      	ldr	r3, [pc, #88]	; (57ac <usb_d_cb_trans_setup+0x78>)
    5754:	4798      	blx	r3
	if (n != 8) {
    5756:	b2c0      	uxtb	r0, r0
    5758:	2808      	cmp	r0, #8
    575a:	f045 0880 	orr.w	r8, r5, #128	; 0x80
    575e:	d008      	beq.n	5772 <usb_d_cb_trans_setup+0x3e>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    5760:	2101      	movs	r1, #1
    5762:	4628      	mov	r0, r5
    5764:	47a0      	blx	r4
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    5766:	4640      	mov	r0, r8
    5768:	4623      	mov	r3, r4
    576a:	2101      	movs	r1, #1
}
    576c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    5770:	4718      	bx	r3
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    5772:	eb06 1649 	add.w	r6, r6, r9, lsl #5
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    5776:	2100      	movs	r1, #0
    5778:	4628      	mov	r0, r5
    577a:	47a0      	blx	r4
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    577c:	f04f 0901 	mov.w	r9, #1
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    5780:	2100      	movs	r1, #0
    5782:	4640      	mov	r0, r8
    5784:	47a0      	blx	r4
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    5786:	f886 9002 	strb.w	r9, [r6, #2]
	if (!ept->callbacks.req(ep, req)) {
    578a:	6973      	ldr	r3, [r6, #20]
    578c:	4639      	mov	r1, r7
    578e:	4628      	mov	r0, r5
    5790:	4798      	blx	r3
    5792:	b910      	cbnz	r0, 579a <usb_d_cb_trans_setup+0x66>
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    5794:	2305      	movs	r3, #5
    5796:	70b3      	strb	r3, [r6, #2]
    5798:	e7e2      	b.n	5760 <usb_d_cb_trans_setup+0x2c>
}
    579a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    579e:	bf00      	nop
    57a0:	000055dd 	.word	0x000055dd
    57a4:	200018ec 	.word	0x200018ec
    57a8:	00005159 	.word	0x00005159
    57ac:	00005229 	.word	0x00005229

000057b0 <usb_d_init>:

int32_t usb_d_init(void)
{
    57b0:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    57b2:	4b10      	ldr	r3, [pc, #64]	; (57f4 <usb_d_init+0x44>)
    57b4:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    57b6:	2800      	cmp	r0, #0
    57b8:	db1b      	blt.n	57f2 <usb_d_init+0x42>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    57ba:	2280      	movs	r2, #128	; 0x80
    57bc:	2100      	movs	r1, #0
    57be:	4b0e      	ldr	r3, [pc, #56]	; (57f8 <usb_d_init+0x48>)
    57c0:	480e      	ldr	r0, [pc, #56]	; (57fc <usb_d_init+0x4c>)
    57c2:	4798      	blx	r3
    57c4:	4b0d      	ldr	r3, [pc, #52]	; (57fc <usb_d_init+0x4c>)
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    57c6:	4a0e      	ldr	r2, [pc, #56]	; (5800 <usb_d_init+0x50>)
    57c8:	f103 0180 	add.w	r1, r3, #128	; 0x80
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    57cc:	20ff      	movs	r0, #255	; 0xff
    57ce:	7058      	strb	r0, [r3, #1]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    57d0:	61da      	str	r2, [r3, #28]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    57d2:	e9c3 2205 	strd	r2, r2, [r3, #20]
    57d6:	3320      	adds	r3, #32
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    57d8:	428b      	cmp	r3, r1
    57da:	d1f8      	bne.n	57ce <usb_d_init+0x1e>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    57dc:	4c09      	ldr	r4, [pc, #36]	; (5804 <usb_d_init+0x54>)
    57de:	490a      	ldr	r1, [pc, #40]	; (5808 <usb_d_init+0x58>)
    57e0:	2000      	movs	r0, #0
    57e2:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    57e4:	4909      	ldr	r1, [pc, #36]	; (580c <usb_d_init+0x5c>)
    57e6:	2001      	movs	r0, #1
    57e8:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    57ea:	2002      	movs	r0, #2
    57ec:	4908      	ldr	r1, [pc, #32]	; (5810 <usb_d_init+0x60>)
    57ee:	47a0      	blx	r4
	return ERR_NONE;
    57f0:	2000      	movs	r0, #0
}
    57f2:	bd10      	pop	{r4, pc}
    57f4:	00004d61 	.word	0x00004d61
    57f8:	000071c5 	.word	0x000071c5
    57fc:	200018ec 	.word	0x200018ec
    5800:	0000560d 	.word	0x0000560d
    5804:	000053a5 	.word	0x000053a5
    5808:	00005735 	.word	0x00005735
    580c:	00005611 	.word	0x00005611
    5810:	00005641 	.word	0x00005641

00005814 <usb_d_register_callback>:
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
    5814:	4b00      	ldr	r3, [pc, #0]	; (5818 <usb_d_register_callback+0x4>)
    5816:	4718      	bx	r3
    5818:	00005381 	.word	0x00005381

0000581c <usb_d_enable>:
}

int32_t usb_d_enable(void)
{
	return _usb_d_dev_enable();
    581c:	4b00      	ldr	r3, [pc, #0]	; (5820 <usb_d_enable+0x4>)
    581e:	4718      	bx	r3
    5820:	00004e3d 	.word	0x00004e3d

00005824 <usb_d_attach>:
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
	_usb_d_dev_attach();
    5824:	4b00      	ldr	r3, [pc, #0]	; (5828 <usb_d_attach+0x4>)
    5826:	4718      	bx	r3
    5828:	00004e99 	.word	0x00004e99

0000582c <usb_d_set_address>:
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
	_usb_d_dev_set_address(addr);
    582c:	4b00      	ldr	r3, [pc, #0]	; (5830 <usb_d_set_address+0x4>)
    582e:	4718      	bx	r3
    5830:	00004eab 	.word	0x00004eab

00005834 <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
    5834:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
    5836:	4c10      	ldr	r4, [pc, #64]	; (5878 <usb_d_ep_init+0x44>)
{
    5838:	4606      	mov	r6, r0
    583a:	460d      	mov	r5, r1
    583c:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    583e:	47a0      	blx	r4
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
    5840:	2800      	cmp	r0, #0
    5842:	da13      	bge.n	586c <usb_d_ep_init+0x38>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
    5844:	20ff      	movs	r0, #255	; 0xff
    5846:	47a0      	blx	r4
		if (ep_index < 0) {
    5848:	1e04      	subs	r4, r0, #0
    584a:	db12      	blt.n	5872 <usb_d_ep_init+0x3e>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
    584c:	463a      	mov	r2, r7
    584e:	4629      	mov	r1, r5
    5850:	4630      	mov	r0, r6
    5852:	4b0a      	ldr	r3, [pc, #40]	; (587c <usb_d_ep_init+0x48>)
    5854:	4798      	blx	r3
	if (rc < 0) {
    5856:	2800      	cmp	r0, #0
    5858:	db07      	blt.n	586a <usb_d_ep_init+0x36>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
    585a:	4b09      	ldr	r3, [pc, #36]	; (5880 <usb_d_ep_init+0x4c>)
    585c:	0160      	lsls	r0, r4, #5
    585e:	181a      	adds	r2, r3, r0
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    5860:	f005 0503 	and.w	r5, r5, #3
    5864:	541d      	strb	r5, [r3, r0]
	ept->xfer.hdr.ep   = ep;
    5866:	7056      	strb	r6, [r2, #1]
	return ERR_NONE;
    5868:	2000      	movs	r0, #0
}
    586a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    586c:	f06f 0013 	mvn.w	r0, #19
    5870:	e7fb      	b.n	586a <usb_d_ep_init+0x36>
			return -USB_ERR_ALLOC_FAIL;
    5872:	f06f 0014 	mvn.w	r0, #20
    5876:	e7f8      	b.n	586a <usb_d_ep_init+0x36>
    5878:	000055dd 	.word	0x000055dd
    587c:	00004eb9 	.word	0x00004eb9
    5880:	200018ec 	.word	0x200018ec

00005884 <usb_d_ep0_init>:
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    5884:	2100      	movs	r1, #0
    5886:	4602      	mov	r2, r0
    5888:	4b01      	ldr	r3, [pc, #4]	; (5890 <usb_d_ep0_init+0xc>)
    588a:	4608      	mov	r0, r1
    588c:	4718      	bx	r3
    588e:	bf00      	nop
    5890:	00005835 	.word	0x00005835

00005894 <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
    5894:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    5896:	4b07      	ldr	r3, [pc, #28]	; (58b4 <usb_d_ep_deinit+0x20>)
{
    5898:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    589a:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
    589c:	1e04      	subs	r4, r0, #0
    589e:	db07      	blt.n	58b0 <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
    58a0:	4628      	mov	r0, r5
    58a2:	4b05      	ldr	r3, [pc, #20]	; (58b8 <usb_d_ep_deinit+0x24>)
    58a4:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
    58a6:	4805      	ldr	r0, [pc, #20]	; (58bc <usb_d_ep_deinit+0x28>)
    58a8:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    58ac:	23ff      	movs	r3, #255	; 0xff
    58ae:	7043      	strb	r3, [r0, #1]
}
    58b0:	bd38      	pop	{r3, r4, r5, pc}
    58b2:	bf00      	nop
    58b4:	000055dd 	.word	0x000055dd
    58b8:	00004f71 	.word	0x00004f71
    58bc:	200018ec 	.word	0x200018ec

000058c0 <usb_d_ep_enable>:

int32_t usb_d_ep_enable(const uint8_t ep)
{
    58c0:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    58c2:	4b0c      	ldr	r3, [pc, #48]	; (58f4 <usb_d_ep_enable+0x34>)
{
    58c4:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    58c6:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
    58c8:	2800      	cmp	r0, #0
    58ca:	db10      	blt.n	58ee <usb_d_ep_enable+0x2e>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    58cc:	0140      	lsls	r0, r0, #5
    58ce:	4c0a      	ldr	r4, [pc, #40]	; (58f8 <usb_d_ep_enable+0x38>)
    58d0:	5c23      	ldrb	r3, [r4, r0]
    58d2:	4404      	add	r4, r0
    58d4:	2b00      	cmp	r3, #0
    58d6:	bf0c      	ite	eq
    58d8:	2302      	moveq	r3, #2
    58da:	2301      	movne	r3, #1
    58dc:	70a3      	strb	r3, [r4, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
    58de:	4628      	mov	r0, r5
    58e0:	4b06      	ldr	r3, [pc, #24]	; (58fc <usb_d_ep_enable+0x3c>)
    58e2:	4798      	blx	r3
	if (rc < 0) {
    58e4:	2800      	cmp	r0, #0
    58e6:	da01      	bge.n	58ec <usb_d_ep_enable+0x2c>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
    58e8:	2300      	movs	r3, #0
    58ea:	70a3      	strb	r3, [r4, #2]
	}
	return rc;
}
    58ec:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
    58ee:	f06f 0011 	mvn.w	r0, #17
    58f2:	e7fb      	b.n	58ec <usb_d_ep_enable+0x2c>
    58f4:	000055dd 	.word	0x000055dd
    58f8:	200018ec 	.word	0x200018ec
    58fc:	00004fed 	.word	0x00004fed

00005900 <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
    5900:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    5904:	f890 a008 	ldrb.w	sl, [r0, #8]
    5908:	4b36      	ldr	r3, [pc, #216]	; (59e4 <usb_d_ep_transfer+0xe4>)
{
    590a:	4607      	mov	r7, r0
    590c:	b087      	sub	sp, #28
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    590e:	4650      	mov	r0, sl
    5910:	4798      	blx	r3
	uint32_t              len = xfer->size;
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
    5912:	f1b0 0800 	subs.w	r8, r0, #0
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    5916:	f897 9009 	ldrb.w	r9, [r7, #9]
	uint32_t              len = xfer->size;
    591a:	687e      	ldr	r6, [r7, #4]
	if (ep_index < 0) {
    591c:	db5d      	blt.n	59da <usb_d_ep_transfer+0xda>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
	state = ept->xfer.hdr.state;
    591e:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 59f4 <usb_d_ep_transfer+0xf4>
	atomic_enter_critical(&flags);
    5922:	4b31      	ldr	r3, [pc, #196]	; (59e8 <usb_d_ep_transfer+0xe8>)
	state = ept->xfer.hdr.state;
    5924:	ea4f 1848 	mov.w	r8, r8, lsl #5
    5928:	eb0b 0508 	add.w	r5, fp, r8
	atomic_enter_critical(&flags);
    592c:	a802      	add	r0, sp, #8
    592e:	4798      	blx	r3
	state = ept->xfer.hdr.state;
    5930:	78ab      	ldrb	r3, [r5, #2]
    5932:	f88d 3007 	strb.w	r3, [sp, #7]
	if (state == USB_EP_S_IDLE) {
    5936:	f89d 0007 	ldrb.w	r0, [sp, #7]
    593a:	4b2c      	ldr	r3, [pc, #176]	; (59ec <usb_d_ep_transfer+0xec>)
    593c:	b2c4      	uxtb	r4, r0
    593e:	2c01      	cmp	r4, #1
    5940:	d11c      	bne.n	597c <usb_d_ep_transfer+0x7c>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
    5942:	2203      	movs	r2, #3
    5944:	70aa      	strb	r2, [r5, #2]
		atomic_leave_critical(&flags);
    5946:	a802      	add	r0, sp, #8
    5948:	4798      	blx	r3
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
		}
	}

	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    594a:	f81b 3008 	ldrb.w	r3, [fp, r8]
    594e:	b34b      	cbz	r3, 59a4 <usb_d_ep_transfer+0xa4>
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    5950:	f119 0300 	adds.w	r3, r9, #0
    5954:	ea4f 14da 	mov.w	r4, sl, lsr #7
    5958:	bf18      	it	ne
    595a:	2301      	movne	r3, #1
	struct usb_d_transfer trans
    595c:	6839      	ldr	r1, [r7, #0]
				zlp = false;
			}
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    595e:	7a3a      	ldrb	r2, [r7, #8]
	struct usb_d_transfer trans
    5960:	e9cd 1603 	strd	r1, r6, [sp, #12]
    5964:	2c00      	cmp	r4, #0
    5966:	d035      	beq.n	59d4 <usb_d_ep_transfer+0xd4>
    5968:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    596c:	f88d 3015 	strb.w	r3, [sp, #21]
	return _usb_d_dev_ep_trans(&trans);
    5970:	a803      	add	r0, sp, #12
    5972:	4b1f      	ldr	r3, [pc, #124]	; (59f0 <usb_d_ep_transfer+0xf0>)
	struct usb_d_transfer trans
    5974:	f88d 2014 	strb.w	r2, [sp, #20]
	return _usb_d_dev_ep_trans(&trans);
    5978:	4798      	blx	r3
	return rc;
    597a:	e00d      	b.n	5998 <usb_d_ep_transfer+0x98>
		atomic_leave_critical(&flags);
    597c:	a802      	add	r0, sp, #8
    597e:	4798      	blx	r3
		switch (state) {
    5980:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5984:	b2db      	uxtb	r3, r3
    5986:	2b05      	cmp	r3, #5
    5988:	d02a      	beq.n	59e0 <usb_d_ep_transfer+0xe0>
    598a:	2b06      	cmp	r3, #6
    598c:	d007      	beq.n	599e <usb_d_ep_transfer+0x9e>
			return USB_BUSY;
    598e:	2b00      	cmp	r3, #0
    5990:	bf0c      	ite	eq
    5992:	f06f 0012 	mvneq.w	r0, #18
    5996:	2001      	movne	r0, #1
}
    5998:	b007      	add	sp, #28
    599a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return -USB_ERROR;
    599e:	f06f 000f 	mvn.w	r0, #15
    59a2:	e7f9      	b.n	5998 <usb_d_ep_transfer+0x98>
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
    59a4:	7ce9      	ldrb	r1, [r5, #19]
    59a6:	7caa      	ldrb	r2, [r5, #18]
    59a8:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    59ac:	b292      	uxth	r2, r2
		if (req_len == 0) {
    59ae:	b92a      	cbnz	r2, 59bc <usb_d_ep_transfer+0xbc>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    59b0:	2304      	movs	r3, #4
    59b2:	70ab      	strb	r3, [r5, #2]
			len                 = 0;
    59b4:	4616      	mov	r6, r2
			zlp                 = true;
    59b6:	4623      	mov	r3, r4
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    59b8:	461c      	mov	r4, r3
    59ba:	e7cf      	b.n	595c <usb_d_ep_transfer+0x5c>
			if (dir) {
    59bc:	f995 100c 	ldrsb.w	r1, [r5, #12]
    59c0:	4296      	cmp	r6, r2
    59c2:	bf28      	it	cs
    59c4:	4616      	movcs	r6, r2
    59c6:	2900      	cmp	r1, #0
    59c8:	daf6      	bge.n	59b8 <usb_d_ep_transfer+0xb8>
				zlp = (req_len > len);
    59ca:	42b2      	cmp	r2, r6
    59cc:	bf94      	ite	ls
    59ce:	2300      	movls	r3, #0
    59d0:	2301      	movhi	r3, #1
    59d2:	e7c3      	b.n	595c <usb_d_ep_transfer+0x5c>
	struct usb_d_transfer trans
    59d4:	f002 020f 	and.w	r2, r2, #15
    59d8:	e7c8      	b.n	596c <usb_d_ep_transfer+0x6c>
		return -USB_ERR_PARAM;
    59da:	f06f 0011 	mvn.w	r0, #17
    59de:	e7db      	b.n	5998 <usb_d_ep_transfer+0x98>
			return USB_HALTED;
    59e0:	2002      	movs	r0, #2
    59e2:	e7d9      	b.n	5998 <usb_d_ep_transfer+0x98>
    59e4:	000055dd 	.word	0x000055dd
    59e8:	00006225 	.word	0x00006225
    59ec:	00006233 	.word	0x00006233
    59f0:	0000527d 	.word	0x0000527d
    59f4:	200018ec 	.word	0x200018ec

000059f8 <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
    59f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    59fc:	4605      	mov	r5, r0
	if (ctrl == USB_EP_HALT_CLR) {
    59fe:	460c      	mov	r4, r1
    5a00:	b9d9      	cbnz	r1, 5a3a <usb_d_ep_halt+0x42>
	int8_t           ep_index = _usb_d_find_ep(ep);
    5a02:	4b13      	ldr	r3, [pc, #76]	; (5a50 <usb_d_ep_halt+0x58>)
    5a04:	4798      	blx	r3
	if (ep_index < 0) {
    5a06:	1e07      	subs	r7, r0, #0
    5a08:	db1e      	blt.n	5a48 <usb_d_ep_halt+0x50>
	if (_usb_d_dev_ep_stall(ep, USB_EP_STALL_GET)) {
    5a0a:	2102      	movs	r1, #2
    5a0c:	4628      	mov	r0, r5
    5a0e:	4e11      	ldr	r6, [pc, #68]	; (5a54 <usb_d_ep_halt+0x5c>)
    5a10:	47b0      	blx	r6
    5a12:	b180      	cbz	r0, 5a36 <usb_d_ep_halt+0x3e>
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    5a14:	4621      	mov	r1, r4
    5a16:	4628      	mov	r0, r5
    5a18:	47b0      	blx	r6
		if (rc < 0) {
    5a1a:	2800      	cmp	r0, #0
    5a1c:	db0b      	blt.n	5a36 <usb_d_ep_halt+0x3e>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
    5a1e:	480e      	ldr	r0, [pc, #56]	; (5a58 <usb_d_ep_halt+0x60>)
    5a20:	eb00 1047 	add.w	r0, r0, r7, lsl #5
    5a24:	f240 3301 	movw	r3, #769	; 0x301
    5a28:	8043      	strh	r3, [r0, #2]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
    5a2a:	4622      	mov	r2, r4
    5a2c:	69c3      	ldr	r3, [r0, #28]
    5a2e:	2103      	movs	r1, #3
    5a30:	4628      	mov	r0, r5
    5a32:	4798      	blx	r3
	return ERR_NONE;
    5a34:	4620      	mov	r0, r4
	} else if (ctrl == USB_EP_HALT_SET) {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
	}
}
    5a36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (ctrl == USB_EP_HALT_SET) {
    5a3a:	2901      	cmp	r1, #1
    5a3c:	4b05      	ldr	r3, [pc, #20]	; (5a54 <usb_d_ep_halt+0x5c>)
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
    5a3e:	bf18      	it	ne
    5a40:	2102      	movne	r1, #2
}
    5a42:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
    5a46:	4718      	bx	r3
		return -USB_ERR_PARAM;
    5a48:	f06f 0011 	mvn.w	r0, #17
    5a4c:	e7f3      	b.n	5a36 <usb_d_ep_halt+0x3e>
    5a4e:	bf00      	nop
    5a50:	000055dd 	.word	0x000055dd
    5a54:	00005159 	.word	0x00005159
    5a58:	200018ec 	.word	0x200018ec

00005a5c <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
    5a5c:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    5a5e:	4b0f      	ldr	r3, [pc, #60]	; (5a9c <usb_d_ep_register_callback+0x40>)
{
    5a60:	4614      	mov	r4, r2
    5a62:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    5a64:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
    5a66:	4b0e      	ldr	r3, [pc, #56]	; (5aa0 <usb_d_ep_register_callback+0x44>)
    5a68:	2c00      	cmp	r4, #0
    5a6a:	bf08      	it	eq
    5a6c:	461c      	moveq	r4, r3
	if (ep_index < 0) {
    5a6e:	2800      	cmp	r0, #0
    5a70:	db04      	blt.n	5a7c <usb_d_ep_register_callback+0x20>
		return;
	}
	switch (type) {
    5a72:	2d01      	cmp	r5, #1
    5a74:	d008      	beq.n	5a88 <usb_d_ep_register_callback+0x2c>
    5a76:	d302      	bcc.n	5a7e <usb_d_ep_register_callback+0x22>
    5a78:	2d02      	cmp	r5, #2
    5a7a:	d00a      	beq.n	5a92 <usb_d_ep_register_callback+0x36>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
		break;
	default:
		break;
	}
}
    5a7c:	bd38      	pop	{r3, r4, r5, pc}
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
    5a7e:	4b09      	ldr	r3, [pc, #36]	; (5aa4 <usb_d_ep_register_callback+0x48>)
    5a80:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    5a84:	6144      	str	r4, [r0, #20]
		break;
    5a86:	e7f9      	b.n	5a7c <usb_d_ep_register_callback+0x20>
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
    5a88:	4b06      	ldr	r3, [pc, #24]	; (5aa4 <usb_d_ep_register_callback+0x48>)
    5a8a:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    5a8e:	6184      	str	r4, [r0, #24]
		break;
    5a90:	e7f4      	b.n	5a7c <usb_d_ep_register_callback+0x20>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
    5a92:	4b04      	ldr	r3, [pc, #16]	; (5aa4 <usb_d_ep_register_callback+0x48>)
    5a94:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    5a98:	61c4      	str	r4, [r0, #28]
		break;
    5a9a:	e7ef      	b.n	5a7c <usb_d_ep_register_callback+0x20>
    5a9c:	000055dd 	.word	0x000055dd
    5aa0:	0000560d 	.word	0x0000560d
    5aa4:	200018ec 	.word	0x200018ec

00005aa8 <_gpio_set_direction.constprop.3>:
	((Port *)hw)->Group[submodule_index].DIRTGL.reg = PORT_DIR_DIR(mask);
}

static inline void hri_port_set_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    5aa8:	01c0      	lsls	r0, r0, #7
    5aaa:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    5aae:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
		                                | ((mask & 0xffff0000) >> 16));
		break;

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT, port, mask);
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    5ab2:	b28b      	uxth	r3, r1
    5ab4:	6081      	str	r1, [r0, #8]
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    5ab6:	0c09      	lsrs	r1, r1, #16
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    5ab8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
		hri_port_write_WRCONFIG_reg(
    5abc:	f041 4140 	orr.w	r1, r1, #3221225472	; 0xc0000000

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    5ac0:	6283      	str	r3, [r0, #40]	; 0x28
    5ac2:	6281      	str	r1, [r0, #40]	; 0x28
		break;

	default:
		ASSERT(false);
	}
}
    5ac4:	4770      	bx	lr
	...

00005ac8 <TARGET_USB_PORT_init>:
#include <peripheral_clk_config.h>
#include <utils.h>
#include <hal_init.h>

void TARGET_USB_PORT_init(void)
{
    5ac8:	b510      	push	{r4, lr}
 *                      GPIO_DIRECTION_OFF = Disables the pin
 *                      (low power state)
 */
static inline void gpio_set_pin_direction(const uint8_t pin, const enum gpio_direction direction)
{
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    5aca:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    5ace:	2000      	movs	r0, #0
    5ad0:	4c1c      	ldr	r4, [pc, #112]	; (5b44 <TARGET_USB_PORT_init+0x7c>)
    5ad2:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5ad4:	4a1c      	ldr	r2, [pc, #112]	; (5b48 <TARGET_USB_PORT_init+0x80>)
    5ad6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    5ada:	6153      	str	r3, [r2, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    5adc:	f892 3058 	ldrb.w	r3, [r2, #88]	; 0x58
    5ae0:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    5ae4:	f882 3058 	strb.w	r3, [r2, #88]	; 0x58
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    5ae8:	f892 3058 	ldrb.w	r3, [r2, #88]	; 0x58
	tmp &= ~PORT_PINCFG_PMUXEN;
    5aec:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    5af0:	f043 0301 	orr.w	r3, r3, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    5af4:	f882 3058 	strb.w	r3, [r2, #88]	; 0x58
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    5af8:	f892 303c 	ldrb.w	r3, [r2, #60]	; 0x3c
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    5afc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
    5b00:	f043 0307 	orr.w	r3, r3, #7
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    5b04:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
    5b08:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
    5b0c:	2000      	movs	r0, #0
    5b0e:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5b10:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
    5b14:	6153      	str	r3, [r2, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    5b16:	f892 3059 	ldrb.w	r3, [r2, #89]	; 0x59
    5b1a:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    5b1e:	f882 3059 	strb.w	r3, [r2, #89]	; 0x59
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    5b22:	f892 3059 	ldrb.w	r3, [r2, #89]	; 0x59
	tmp &= ~PORT_PINCFG_PMUXEN;
    5b26:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    5b2a:	f043 0301 	orr.w	r3, r3, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    5b2e:	f882 3059 	strb.w	r3, [r2, #89]	; 0x59
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    5b32:	f892 303c 	ldrb.w	r3, [r2, #60]	; 0x3c
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    5b36:	f003 030f 	and.w	r3, r3, #15
	tmp |= PORT_PMUX_PMUXO(data);
    5b3a:	f043 0370 	orr.w	r3, r3, #112	; 0x70
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    5b3e:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
	                      // <GPIO_PIN_FUNCTION_K"> K
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA25H_USB_DP);
}
    5b42:	bd10      	pop	{r4, pc}
    5b44:	00005aa9 	.word	0x00005aa9
    5b48:	41008000 	.word	0x41008000

00005b4c <TARGET_USB_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    5b4c:	4b07      	ldr	r3, [pc, #28]	; (5b6c <TARGET_USB_CLOCK_init+0x20>)
    5b4e:	2240      	movs	r2, #64	; 0x40
    5b50:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
}

static inline void hri_mclk_set_AHBMASK_USB_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_USB;
    5b54:	f5a3 53a0 	sub.w	r3, r3, #5120	; 0x1400
    5b58:	691a      	ldr	r2, [r3, #16]
    5b5a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    5b5e:	611a      	str	r2, [r3, #16]
}

static inline void hri_mclk_set_APBBMASK_USB_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_USB;
    5b60:	699a      	ldr	r2, [r3, #24]
    5b62:	f042 0201 	orr.w	r2, r2, #1
    5b66:	619a      	str	r2, [r3, #24]
{

	hri_gclk_write_PCHCTRL_reg(GCLK, USB_GCLK_ID, CONF_GCLK_USB_SRC | GCLK_PCHCTRL_CHEN);
	hri_mclk_set_AHBMASK_USB_bit(MCLK);
	hri_mclk_set_APBBMASK_USB_bit(MCLK);
}
    5b68:	4770      	bx	lr
    5b6a:	bf00      	nop
    5b6c:	40001c00 	.word	0x40001c00

00005b70 <TARGET_USB_init>:

void TARGET_USB_init(void)
{
    5b70:	b510      	push	{r4, lr}
	TARGET_USB_CLOCK_init();
    5b72:	4b04      	ldr	r3, [pc, #16]	; (5b84 <TARGET_USB_init+0x14>)
    5b74:	4798      	blx	r3
	usb_d_init();
    5b76:	4b04      	ldr	r3, [pc, #16]	; (5b88 <TARGET_USB_init+0x18>)
    5b78:	4798      	blx	r3
	TARGET_USB_PORT_init();
    5b7a:	4b04      	ldr	r3, [pc, #16]	; (5b8c <TARGET_USB_init+0x1c>)
}
    5b7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	TARGET_USB_PORT_init();
    5b80:	4718      	bx	r3
    5b82:	bf00      	nop
    5b84:	00005b4d 	.word	0x00005b4d
    5b88:	000057b1 	.word	0x000057b1
    5b8c:	00005ac9 	.word	0x00005ac9

00005b90 <system_init>:
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5b90:	4a13      	ldr	r2, [pc, #76]	; (5be0 <system_init+0x50>)
    5b92:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000

void system_init(void)
{
    5b96:	b510      	push	{r4, lr}
    5b98:	2000      	movs	r0, #0
    5b9a:	6151      	str	r1, [r2, #20]
    5b9c:	4c11      	ldr	r4, [pc, #68]	; (5be4 <system_init+0x54>)
    5b9e:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    5ba0:	f892 305b 	ldrb.w	r3, [r2, #91]	; 0x5b
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5ba4:	2104      	movs	r1, #4
	tmp &= ~PORT_PINCFG_PMUXEN;
    5ba6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    5baa:	f882 305b 	strb.w	r3, [r2, #91]	; 0x5b
    5bae:	2001      	movs	r0, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5bb0:	f8c2 1094 	str.w	r1, [r2, #148]	; 0x94
    5bb4:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    5bb6:	f892 30c2 	ldrb.w	r3, [r2, #194]	; 0xc2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5bba:	2108      	movs	r1, #8
	tmp &= ~PORT_PINCFG_PMUXEN;
    5bbc:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    5bc0:	f882 30c2 	strb.w	r3, [r2, #194]	; 0xc2
    5bc4:	2001      	movs	r0, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5bc6:	f8c2 1094 	str.w	r1, [r2, #148]	; 0x94
    5bca:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    5bcc:	f892 30c3 	ldrb.w	r3, [r2, #195]	; 0xc3
	tmp &= ~PORT_PINCFG_PMUXEN;
    5bd0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    5bd4:	f882 30c3 	strb.w	r3, [r2, #195]	; 0xc3
	gpio_set_pin_direction(PB03, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(PB03, GPIO_PIN_FUNCTION_OFF);

	TARGET_USB_init();
}
    5bd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	TARGET_USB_init();
    5bdc:	4b02      	ldr	r3, [pc, #8]	; (5be8 <system_init+0x58>)
    5bde:	4718      	bx	r3
    5be0:	41008000 	.word	0x41008000
    5be4:	00005aa9 	.word	0x00005aa9
    5be8:	00005b71 	.word	0x00005b71

00005bec <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    5bec:	e7fe      	b.n	5bec <Dummy_Handler>
	...

00005bf0 <Reset_Handler>:
{
    5bf0:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
    5bf2:	4a14      	ldr	r2, [pc, #80]	; (5c44 <Reset_Handler+0x54>)
    5bf4:	4b14      	ldr	r3, [pc, #80]	; (5c48 <Reset_Handler+0x58>)
    5bf6:	429a      	cmp	r2, r3
    5bf8:	d003      	beq.n	5c02 <Reset_Handler+0x12>
		for (; pDest < &_erelocate;) {
    5bfa:	4914      	ldr	r1, [pc, #80]	; (5c4c <Reset_Handler+0x5c>)
    5bfc:	3a04      	subs	r2, #4
    5bfe:	428b      	cmp	r3, r1
    5c00:	d318      	bcc.n	5c34 <Reset_Handler+0x44>
{
    5c02:	4b13      	ldr	r3, [pc, #76]	; (5c50 <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
    5c04:	4a13      	ldr	r2, [pc, #76]	; (5c54 <Reset_Handler+0x64>)
		*pDest++ = 0;
    5c06:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
    5c08:	4293      	cmp	r3, r2
    5c0a:	d318      	bcc.n	5c3e <Reset_Handler+0x4e>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    5c0c:	4a12      	ldr	r2, [pc, #72]	; (5c58 <Reset_Handler+0x68>)
    5c0e:	4b13      	ldr	r3, [pc, #76]	; (5c5c <Reset_Handler+0x6c>)
    5c10:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    5c14:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
    5c16:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    5c1a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    5c1e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    5c22:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    5c26:	f3bf 8f6f 	isb	sy
	__libc_init_array();
    5c2a:	4b0d      	ldr	r3, [pc, #52]	; (5c60 <Reset_Handler+0x70>)
    5c2c:	4798      	blx	r3
	main();
    5c2e:	4b0d      	ldr	r3, [pc, #52]	; (5c64 <Reset_Handler+0x74>)
    5c30:	4798      	blx	r3
    5c32:	e7fe      	b.n	5c32 <Reset_Handler+0x42>
			*pDest++ = *pSrc++;
    5c34:	f852 0f04 	ldr.w	r0, [r2, #4]!
    5c38:	f843 0b04 	str.w	r0, [r3], #4
    5c3c:	e7df      	b.n	5bfe <Reset_Handler+0xe>
		*pDest++ = 0;
    5c3e:	f843 1b04 	str.w	r1, [r3], #4
    5c42:	e7e1      	b.n	5c08 <Reset_Handler+0x18>
    5c44:	00008ddc 	.word	0x00008ddc
    5c48:	20000000 	.word	0x20000000
    5c4c:	20001680 	.word	0x20001680
    5c50:	20001680 	.word	0x20001680
    5c54:	200042d8 	.word	0x200042d8
    5c58:	00004000 	.word	0x00004000
    5c5c:	e000ed00 	.word	0xe000ed00
    5c60:	00007135 	.word	0x00007135
    5c64:	00006e29 	.word	0x00006e29

00005c68 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
    5c68:	b510      	push	{r4, lr}
	system_init();
    5c6a:	4b03      	ldr	r3, [pc, #12]	; (5c78 <atmel_start_init+0x10>)
    5c6c:	4798      	blx	r3
	usb_init();
    5c6e:	4b03      	ldr	r3, [pc, #12]	; (5c7c <atmel_start_init+0x14>)
}
    5c70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	usb_init();
    5c74:	4718      	bx	r3
    5c76:	bf00      	nop
    5c78:	00005b91 	.word	0x00005b91
    5c7c:	000054f9 	.word	0x000054f9

00005c80 <usbdc_unconfig>:
/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
    5c80:	4b05      	ldr	r3, [pc, #20]	; (5c98 <usbdc_unconfig+0x18>)
{
    5c82:	b510      	push	{r4, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
    5c84:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
    5c86:	b904      	cbnz	r4, 5c8a <usbdc_unconfig+0xa>
		func->ctrl(func, USBDF_DISABLE, NULL);
		func = func->next;
	}
}
    5c88:	bd10      	pop	{r4, pc}
		func->ctrl(func, USBDF_DISABLE, NULL);
    5c8a:	6863      	ldr	r3, [r4, #4]
    5c8c:	4620      	mov	r0, r4
    5c8e:	2200      	movs	r2, #0
    5c90:	2101      	movs	r1, #1
    5c92:	4798      	blx	r3
		func = func->next;
    5c94:	6824      	ldr	r4, [r4, #0]
    5c96:	e7f6      	b.n	5c86 <usbdc_unconfig+0x6>
    5c98:	2000196c 	.word	0x2000196c

00005c9c <usbdc_change_notify>:
}

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
    5c9c:	4b06      	ldr	r3, [pc, #24]	; (5cb8 <usbdc_change_notify+0x1c>)
{
    5c9e:	b570      	push	{r4, r5, r6, lr}
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
    5ca0:	68dc      	ldr	r4, [r3, #12]
{
    5ca2:	4605      	mov	r5, r0
    5ca4:	460e      	mov	r6, r1

	while (cg != NULL) {
    5ca6:	b904      	cbnz	r4, 5caa <usbdc_change_notify+0xe>
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
	}
}
    5ca8:	bd70      	pop	{r4, r5, r6, pc}
		if (NULL != cg->cb) {
    5caa:	6863      	ldr	r3, [r4, #4]
    5cac:	b113      	cbz	r3, 5cb4 <usbdc_change_notify+0x18>
			cg->cb(change, value);
    5cae:	4631      	mov	r1, r6
    5cb0:	4628      	mov	r0, r5
    5cb2:	4798      	blx	r3
		cg = cg->next;
    5cb4:	6824      	ldr	r4, [r4, #0]
    5cb6:	e7f6      	b.n	5ca6 <usbdc_change_notify+0xa>
    5cb8:	2000196c 	.word	0x2000196c

00005cbc <usbdc_request_handler>:

/** Invoke all registered request callbacks until request handled. */
static int32_t usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    5cbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
    5cbe:	4b0c      	ldr	r3, [pc, #48]	; (5cf0 <usbdc_request_handler+0x34>)
    5cc0:	689c      	ldr	r4, [r3, #8]
{
    5cc2:	4605      	mov	r5, r0
    5cc4:	460e      	mov	r6, r1
    5cc6:	4617      	mov	r7, r2
	int32_t                   rc;

	while (h != NULL) {
    5cc8:	b90c      	cbnz	r4, 5cce <usbdc_request_handler+0x12>
				return -1;
			}
		}
		h = h->next;
	}
	return false;
    5cca:	4620      	mov	r0, r4
}
    5ccc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (NULL != h->cb) {
    5cce:	6863      	ldr	r3, [r4, #4]
    5cd0:	b90b      	cbnz	r3, 5cd6 <usbdc_request_handler+0x1a>
		h = h->next;
    5cd2:	6824      	ldr	r4, [r4, #0]
    5cd4:	e7f8      	b.n	5cc8 <usbdc_request_handler+0xc>
			rc = h->cb(ep, req, stage);
    5cd6:	463a      	mov	r2, r7
    5cd8:	4631      	mov	r1, r6
    5cda:	4628      	mov	r0, r5
    5cdc:	4798      	blx	r3
			if (0 == rc) {
    5cde:	b120      	cbz	r0, 5cea <usbdc_request_handler+0x2e>
			} else if (ERR_NOT_FOUND != rc) {
    5ce0:	300a      	adds	r0, #10
    5ce2:	d0f6      	beq.n	5cd2 <usbdc_request_handler+0x16>
				return -1;
    5ce4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5ce8:	e7f0      	b.n	5ccc <usbdc_request_handler+0x10>
				return true;
    5cea:	2001      	movs	r0, #1
    5cec:	e7ee      	b.n	5ccc <usbdc_request_handler+0x10>
    5cee:	bf00      	nop
    5cf0:	2000196c 	.word	0x2000196c

00005cf4 <usbd_sof_cb>:
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
    5cf4:	4b04      	ldr	r3, [pc, #16]	; (5d08 <usbd_sof_cb+0x14>)

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
    5cf6:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
    5cf8:	685c      	ldr	r4, [r3, #4]
	while (sof != NULL) {
    5cfa:	b904      	cbnz	r4, 5cfe <usbd_sof_cb+0xa>
	usbdc_sof_notify();
}
    5cfc:	bd10      	pop	{r4, pc}
		if (NULL != sof->cb) {
    5cfe:	6863      	ldr	r3, [r4, #4]
    5d00:	b103      	cbz	r3, 5d04 <usbd_sof_cb+0x10>
			sof->cb();
    5d02:	4798      	blx	r3
		sof = sof->next;
    5d04:	6824      	ldr	r4, [r4, #0]
    5d06:	e7f8      	b.n	5cfa <usbd_sof_cb+0x6>
    5d08:	2000196c 	.word	0x2000196c

00005d0c <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
    5d0c:	b510      	push	{r4, lr}
    5d0e:	4614      	mov	r4, r2
	(void)ep;

	switch (code) {
    5d10:	460a      	mov	r2, r1
    5d12:	b119      	cbz	r1, 5d1c <usbdc_cb_ctl_done+0x10>
    5d14:	2901      	cmp	r1, #1
    5d16:	d020      	beq.n	5d5a <usbdc_cb_ctl_done+0x4e>
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
}
    5d18:	2000      	movs	r0, #0
    5d1a:	bd10      	pop	{r4, pc}
	if (req->bmRequestType != USB_REQT_TYPE_STANDARD) {
    5d1c:	7823      	ldrb	r3, [r4, #0]
    5d1e:	2b00      	cmp	r3, #0
    5d20:	d1fa      	bne.n	5d18 <usbdc_cb_ctl_done+0xc>
	switch (req->bRequest) {
    5d22:	7863      	ldrb	r3, [r4, #1]
    5d24:	2b05      	cmp	r3, #5
    5d26:	d00d      	beq.n	5d44 <usbdc_cb_ctl_done+0x38>
    5d28:	2b09      	cmp	r3, #9
    5d2a:	d1f5      	bne.n	5d18 <usbdc_cb_ctl_done+0xc>
		usbdc.cfg_value = req->wValue;
    5d2c:	8862      	ldrh	r2, [r4, #2]
    5d2e:	4b0d      	ldr	r3, [pc, #52]	; (5d64 <usbdc_cb_ctl_done+0x58>)
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
    5d30:	2a00      	cmp	r2, #0
		usbdc.cfg_value = req->wValue;
    5d32:	76da      	strb	r2, [r3, #27]
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
    5d34:	bf14      	ite	ne
    5d36:	2104      	movne	r1, #4
    5d38:	2103      	moveq	r1, #3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
    5d3a:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
    5d3c:	2001      	movs	r0, #1
    5d3e:	4b0a      	ldr	r3, [pc, #40]	; (5d68 <usbdc_cb_ctl_done+0x5c>)
    5d40:	4798      	blx	r3
    5d42:	e7e9      	b.n	5d18 <usbdc_cb_ctl_done+0xc>
		usbdc_set_address(req->wValue);
    5d44:	8860      	ldrh	r0, [r4, #2]
	usb_d_set_address(addr);
    5d46:	4b09      	ldr	r3, [pc, #36]	; (5d6c <usbdc_cb_ctl_done+0x60>)
    5d48:	b2c0      	uxtb	r0, r0
    5d4a:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
    5d4c:	8863      	ldrh	r3, [r4, #2]
    5d4e:	2b00      	cmp	r3, #0
    5d50:	bf14      	ite	ne
    5d52:	2103      	movne	r1, #3
    5d54:	2102      	moveq	r1, #2
    5d56:	4b03      	ldr	r3, [pc, #12]	; (5d64 <usbdc_cb_ctl_done+0x58>)
    5d58:	e7ef      	b.n	5d3a <usbdc_cb_ctl_done+0x2e>
	usbdc_request_handler(0, req, USB_DATA_STAGE);
    5d5a:	4621      	mov	r1, r4
    5d5c:	4b04      	ldr	r3, [pc, #16]	; (5d70 <usbdc_cb_ctl_done+0x64>)
    5d5e:	2000      	movs	r0, #0
    5d60:	4798      	blx	r3
		return usbdc_ctrl_data_end(req);
    5d62:	e7d9      	b.n	5d18 <usbdc_cb_ctl_done+0xc>
    5d64:	2000196c 	.word	0x2000196c
    5d68:	00005c9d 	.word	0x00005c9d
    5d6c:	0000582d 	.word	0x0000582d
    5d70:	00005cbd 	.word	0x00005cbd

00005d74 <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
    5d74:	b570      	push	{r4, r5, r6, lr}
	usbdc_unconfig();

	usbdc.state       = USBD_S_DEFAULT;
    5d76:	4d0d      	ldr	r5, [pc, #52]	; (5dac <usbdc_reset+0x38>)
	usbdc_unconfig();
    5d78:	4b0d      	ldr	r3, [pc, #52]	; (5db0 <usbdc_reset+0x3c>)
	usbdc.cfg_value   = 0;
	usbdc.ifc_alt_map = 0;
    5d7a:	2400      	movs	r4, #0
	usbdc.state       = USBD_S_DEFAULT;
    5d7c:	2602      	movs	r6, #2
	usbdc_unconfig();
    5d7e:	4798      	blx	r3
	usbdc.state       = USBD_S_DEFAULT;
    5d80:	836e      	strh	r6, [r5, #26]

	// Setup EP0
	usb_d_ep_deinit(0);
    5d82:	4620      	mov	r0, r4
    5d84:	4b0b      	ldr	r3, [pc, #44]	; (5db4 <usbdc_reset+0x40>)
	usbdc.ifc_alt_map = 0;
    5d86:	776c      	strb	r4, [r5, #29]
	usb_d_ep_deinit(0);
    5d88:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
    5d8a:	4b0b      	ldr	r3, [pc, #44]	; (5db8 <usbdc_reset+0x44>)
    5d8c:	7f28      	ldrb	r0, [r5, #28]
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
    5d8e:	4d0b      	ldr	r5, [pc, #44]	; (5dbc <usbdc_reset+0x48>)
	usb_d_ep0_init(usbdc.ctrl_size);
    5d90:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
    5d92:	4621      	mov	r1, r4
    5d94:	4620      	mov	r0, r4
    5d96:	4a0a      	ldr	r2, [pc, #40]	; (5dc0 <usbdc_reset+0x4c>)
    5d98:	47a8      	blx	r5
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
    5d9a:	4620      	mov	r0, r4
    5d9c:	4631      	mov	r1, r6
    5d9e:	4a09      	ldr	r2, [pc, #36]	; (5dc4 <usbdc_reset+0x50>)
    5da0:	47a8      	blx	r5
	usb_d_ep_enable(0);
    5da2:	4620      	mov	r0, r4
    5da4:	4b08      	ldr	r3, [pc, #32]	; (5dc8 <usbdc_reset+0x54>)
}
    5da6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	usb_d_ep_enable(0);
    5daa:	4718      	bx	r3
    5dac:	2000196c 	.word	0x2000196c
    5db0:	00005c81 	.word	0x00005c81
    5db4:	00005895 	.word	0x00005895
    5db8:	00005885 	.word	0x00005885
    5dbc:	00005a5d 	.word	0x00005a5d
    5dc0:	00005e05 	.word	0x00005e05
    5dc4:	00005d0d 	.word	0x00005d0d
    5dc8:	000058c1 	.word	0x000058c1

00005dcc <usbd_event_cb>:
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
	(void)param;

	switch (ev) {
    5dcc:	b110      	cbz	r0, 5dd4 <usbd_event_cb+0x8>
    5dce:	2801      	cmp	r0, #1
    5dd0:	d002      	beq.n	5dd8 <usbd_event_cb+0xc>
    5dd2:	4770      	bx	lr
	case USB_EV_VBUS:
		usbdc_change_notify(USBDC_C_CONN, param);
    5dd4:	4b01      	ldr	r3, [pc, #4]	; (5ddc <usbd_event_cb+0x10>)
    5dd6:	4718      	bx	r3
		break;

	case USB_EV_RESET:
		usbdc_reset();
    5dd8:	4b01      	ldr	r3, [pc, #4]	; (5de0 <usbd_event_cb+0x14>)
    5dda:	4718      	bx	r3
    5ddc:	00005c9d 	.word	0x00005c9d
    5de0:	00005d75 	.word	0x00005d75

00005de4 <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
    5de4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
    5de6:	f88d 000c 	strb.w	r0, [sp, #12]
    5dea:	f88d 300d 	strb.w	r3, [sp, #13]
	return usb_d_ep_transfer(&xfer);
    5dee:	a801      	add	r0, sp, #4
    5df0:	4b03      	ldr	r3, [pc, #12]	; (5e00 <usbdc_xfer+0x1c>)
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
    5df2:	e9cd 1201 	strd	r1, r2, [sp, #4]
	return usb_d_ep_transfer(&xfer);
    5df6:	4798      	blx	r3
}
    5df8:	b005      	add	sp, #20
    5dfa:	f85d fb04 	ldr.w	pc, [sp], #4
    5dfe:	bf00      	nop
    5e00:	00005901 	.word	0x00005901

00005e04 <usbdc_cb_ctl_req>:
{
    5e04:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
    5e08:	4baf      	ldr	r3, [pc, #700]	; (60c8 <usbdc_cb_ctl_req+0x2c4>)
    5e0a:	2200      	movs	r2, #0
{
    5e0c:	4605      	mov	r5, r0
    5e0e:	460c      	mov	r4, r1
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
    5e10:	4798      	blx	r3
    5e12:	1c43      	adds	r3, r0, #1
    5e14:	d009      	beq.n	5e2a <usbdc_cb_ctl_req+0x26>
    5e16:	2801      	cmp	r0, #1
    5e18:	f000 80cd 	beq.w	5fb6 <usbdc_cb_ctl_req+0x1b2>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
    5e1c:	7821      	ldrb	r1, [r4, #0]
    5e1e:	f011 03e0 	ands.w	r3, r1, #224	; 0xe0
    5e22:	d004      	beq.n	5e2e <usbdc_cb_ctl_req+0x2a>
    5e24:	2b80      	cmp	r3, #128	; 0x80
    5e26:	f000 80c9 	beq.w	5fbc <usbdc_cb_ctl_req+0x1b8>
		return false;
    5e2a:	2000      	movs	r0, #0
    5e2c:	e0c3      	b.n	5fb6 <usbdc_cb_ctl_req+0x1b2>
	switch (req->bRequest) {
    5e2e:	7863      	ldrb	r3, [r4, #1]
    5e30:	3b01      	subs	r3, #1
    5e32:	2b0a      	cmp	r3, #10
    5e34:	d8f9      	bhi.n	5e2a <usbdc_cb_ctl_req+0x26>
    5e36:	a201      	add	r2, pc, #4	; (adr r2, 5e3c <usbdc_cb_ctl_req+0x38>)
    5e38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5e3c:	00005ef1 	.word	0x00005ef1
    5e40:	00005e2b 	.word	0x00005e2b
    5e44:	00005f0f 	.word	0x00005f0f
    5e48:	00005e2b 	.word	0x00005e2b
    5e4c:	00005e73 	.word	0x00005e73
    5e50:	00005e2b 	.word	0x00005e2b
    5e54:	00005e2b 	.word	0x00005e2b
    5e58:	00005e2b 	.word	0x00005e2b
    5e5c:	00005e69 	.word	0x00005e69
    5e60:	00005e2b 	.word	0x00005e2b
    5e64:	00005f1f 	.word	0x00005f1f
		if (!usbdc_set_config(req->wValue)) {
    5e68:	8862      	ldrh	r2, [r4, #2]
    5e6a:	b2d2      	uxtb	r2, r2
	if (cfg_value == 0) {
    5e6c:	b95a      	cbnz	r2, 5e86 <usbdc_cb_ctl_req+0x82>
		usbdc_unconfig();
    5e6e:	4b97      	ldr	r3, [pc, #604]	; (60cc <usbdc_cb_ctl_req+0x2c8>)
    5e70:	4798      	blx	r3
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
    5e72:	2200      	movs	r2, #0
    5e74:	2301      	movs	r3, #1
    5e76:	4611      	mov	r1, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
    5e78:	4628      	mov	r0, r5
    5e7a:	4c95      	ldr	r4, [pc, #596]	; (60d0 <usbdc_cb_ctl_req+0x2cc>)
    5e7c:	47a0      	blx	r4
    5e7e:	fab0 f080 	clz	r0, r0
    5e82:	0940      	lsrs	r0, r0, #5
    5e84:	e097      	b.n	5fb6 <usbdc_cb_ctl_req+0x1b2>
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, cfg_value);
    5e86:	4c93      	ldr	r4, [pc, #588]	; (60d4 <usbdc_cb_ctl_req+0x2d0>)
    5e88:	6823      	ldr	r3, [r4, #0]
    5e8a:	e9d3 0100 	ldrd	r0, r1, [r3]
    5e8e:	4b92      	ldr	r3, [pc, #584]	; (60d8 <usbdc_cb_ctl_req+0x2d4>)
    5e90:	4798      	blx	r3
	if (NULL == cfg_desc) {
    5e92:	2800      	cmp	r0, #0
    5e94:	d0c9      	beq.n	5e2a <usbdc_cb_ctl_req+0x26>
	return (ptr[0] + (ptr[1] << 8));
    5e96:	78c2      	ldrb	r2, [r0, #3]
    5e98:	7883      	ldrb	r3, [r0, #2]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
    5e9a:	4f90      	ldr	r7, [pc, #576]	; (60dc <usbdc_cb_ctl_req+0x2d8>)
    5e9c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod  = cfg_desc + total_len;
    5ea0:	fa10 f183 	uxtah	r1, r0, r3
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
    5ea4:	2204      	movs	r2, #4
	desc.eod  = cfg_desc + total_len;
    5ea6:	9101      	str	r1, [sp, #4]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
    5ea8:	47b8      	blx	r7
    5eaa:	f10d 0808 	add.w	r8, sp, #8
	uint8_t                 last_iface = 0xFF;
    5eae:	23ff      	movs	r3, #255	; 0xff
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
    5eb0:	f848 0d08 	str.w	r0, [r8, #-8]!
	while (NULL != desc.sod) {
    5eb4:	9a00      	ldr	r2, [sp, #0]
    5eb6:	2a00      	cmp	r2, #0
    5eb8:	d0db      	beq.n	5e72 <usbdc_cb_ctl_req+0x6e>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
    5eba:	f892 9002 	ldrb.w	r9, [r2, #2]
    5ebe:	4599      	cmp	r9, r3
    5ec0:	d014      	beq.n	5eec <usbdc_cb_ctl_req+0xe8>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
    5ec2:	6926      	ldr	r6, [r4, #16]
			while (NULL != func) {
    5ec4:	b94e      	cbnz	r6, 5eda <usbdc_cb_ctl_req+0xd6>
		desc.sod = usb_desc_next(desc.sod);
    5ec6:	9800      	ldr	r0, [sp, #0]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    5ec8:	9901      	ldr	r1, [sp, #4]
	return (desc + usb_desc_len(desc));
    5eca:	7803      	ldrb	r3, [r0, #0]
    5ecc:	2204      	movs	r2, #4
    5ece:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
    5ed0:	9000      	str	r0, [sp, #0]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    5ed2:	47b8      	blx	r7
    5ed4:	464b      	mov	r3, r9
    5ed6:	9000      	str	r0, [sp, #0]
    5ed8:	e7ec      	b.n	5eb4 <usbdc_cb_ctl_req+0xb0>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
    5eda:	6873      	ldr	r3, [r6, #4]
    5edc:	4642      	mov	r2, r8
    5ede:	2100      	movs	r1, #0
    5ee0:	4630      	mov	r0, r6
    5ee2:	4798      	blx	r3
    5ee4:	2800      	cmp	r0, #0
    5ee6:	d0ee      	beq.n	5ec6 <usbdc_cb_ctl_req+0xc2>
					func = func->next;
    5ee8:	6836      	ldr	r6, [r6, #0]
    5eea:	e7eb      	b.n	5ec4 <usbdc_cb_ctl_req+0xc0>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
    5eec:	4699      	mov	r9, r3
    5eee:	e7ea      	b.n	5ec6 <usbdc_cb_ctl_req+0xc2>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    5ef0:	2902      	cmp	r1, #2
    5ef2:	d19a      	bne.n	5e2a <usbdc_cb_ctl_req+0x26>
		if (req->wLength != 0) {
    5ef4:	88e6      	ldrh	r6, [r4, #6]
    5ef6:	2e00      	cmp	r6, #0
    5ef8:	d197      	bne.n	5e2a <usbdc_cb_ctl_req+0x26>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
    5efa:	88a0      	ldrh	r0, [r4, #4]
    5efc:	4631      	mov	r1, r6
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
    5efe:	4b78      	ldr	r3, [pc, #480]	; (60e0 <usbdc_cb_ctl_req+0x2dc>)
    5f00:	b2c0      	uxtb	r0, r0
    5f02:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
    5f04:	2301      	movs	r3, #1
    5f06:	4632      	mov	r2, r6
    5f08:	4631      	mov	r1, r6
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
    5f0a:	4628      	mov	r0, r5
    5f0c:	e050      	b.n	5fb0 <usbdc_cb_ctl_req+0x1ac>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    5f0e:	2902      	cmp	r1, #2
    5f10:	d18b      	bne.n	5e2a <usbdc_cb_ctl_req+0x26>
		if (req->wLength != 0) {
    5f12:	88e6      	ldrh	r6, [r4, #6]
    5f14:	2e00      	cmp	r6, #0
    5f16:	d188      	bne.n	5e2a <usbdc_cb_ctl_req+0x26>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
    5f18:	88a0      	ldrh	r0, [r4, #4]
    5f1a:	2101      	movs	r1, #1
    5f1c:	e7ef      	b.n	5efe <usbdc_cb_ctl_req+0xfa>
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
    5f1e:	4d6d      	ldr	r5, [pc, #436]	; (60d4 <usbdc_cb_ctl_req+0x2d0>)
		return usbdc_set_interface(req->wValue, req->wIndex);
    5f20:	8866      	ldrh	r6, [r4, #2]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
    5f22:	682b      	ldr	r3, [r5, #0]
    5f24:	7eea      	ldrb	r2, [r5, #27]
		return usbdc_set_interface(req->wValue, req->wIndex);
    5f26:	88a7      	ldrh	r7, [r4, #4]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
    5f28:	e9d3 0100 	ldrd	r0, r1, [r3]
    5f2c:	4b6a      	ldr	r3, [pc, #424]	; (60d8 <usbdc_cb_ctl_req+0x2d4>)
    5f2e:	4798      	blx	r3
	if (NULL == ifc) {
    5f30:	2800      	cmp	r0, #0
    5f32:	f43f af7a 	beq.w	5e2a <usbdc_cb_ctl_req+0x26>
	desc.sod = ifc;
    5f36:	9000      	str	r0, [sp, #0]
	return (ptr[0] + (ptr[1] << 8));
    5f38:	78c2      	ldrb	r2, [r0, #3]
    5f3a:	7881      	ldrb	r1, [r0, #2]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
    5f3c:	4c67      	ldr	r4, [pc, #412]	; (60dc <usbdc_cb_ctl_req+0x2d8>)
    5f3e:	eb01 2102 	add.w	r1, r1, r2, lsl #8
	desc.eod = ifc + usb_cfg_desc_total_len(ifc);
    5f42:	fa10 f181 	uxtah	r1, r0, r1
    5f46:	9101      	str	r1, [sp, #4]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
    5f48:	2204      	movs	r2, #4
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    5f4a:	47a0      	blx	r4
		if (NULL == ifc) {
    5f4c:	2800      	cmp	r0, #0
    5f4e:	f43f af6c 	beq.w	5e2a <usbdc_cb_ctl_req+0x26>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
    5f52:	7883      	ldrb	r3, [r0, #2]
    5f54:	42bb      	cmp	r3, r7
    5f56:	d113      	bne.n	5f80 <usbdc_cb_ctl_req+0x17c>
    5f58:	78c3      	ldrb	r3, [r0, #3]
    5f5a:	42b3      	cmp	r3, r6
    5f5c:	d110      	bne.n	5f80 <usbdc_cb_ctl_req+0x17c>
	desc.sod = ifc;
    5f5e:	f10d 0808 	add.w	r8, sp, #8
	func     = (struct usbdf_driver *)usbdc.func_list.head;
    5f62:	692c      	ldr	r4, [r5, #16]
	desc.sod = ifc;
    5f64:	f848 0d08 	str.w	r0, [r8, #-8]!
	while (NULL != func) {
    5f68:	2c00      	cmp	r4, #0
    5f6a:	f43f af5e 	beq.w	5e2a <usbdc_cb_ctl_req+0x26>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
    5f6e:	2101      	movs	r1, #1
    5f70:	6863      	ldr	r3, [r4, #4]
    5f72:	4642      	mov	r2, r8
    5f74:	4620      	mov	r0, r4
    5f76:	4798      	blx	r3
    5f78:	4601      	mov	r1, r0
    5f7a:	b140      	cbz	r0, 5f8e <usbdc_cb_ctl_req+0x18a>
			func = func->next;
    5f7c:	6824      	ldr	r4, [r4, #0]
    5f7e:	e7f3      	b.n	5f68 <usbdc_cb_ctl_req+0x164>
		desc.sod = usb_desc_next(desc.sod);
    5f80:	9800      	ldr	r0, [sp, #0]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    5f82:	9901      	ldr	r1, [sp, #4]
	return (desc + usb_desc_len(desc));
    5f84:	7803      	ldrb	r3, [r0, #0]
    5f86:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
    5f88:	9000      	str	r0, [sp, #0]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    5f8a:	2204      	movs	r2, #4
    5f8c:	e7dd      	b.n	5f4a <usbdc_cb_ctl_req+0x146>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
    5f8e:	6863      	ldr	r3, [r4, #4]
    5f90:	4642      	mov	r2, r8
    5f92:	4620      	mov	r0, r4
    5f94:	4798      	blx	r3
    5f96:	2800      	cmp	r0, #0
    5f98:	f47f af47 	bne.w	5e2a <usbdc_cb_ctl_req+0x26>
			if (alt_set) {
    5f9c:	b126      	cbz	r6, 5fa8 <usbdc_cb_ctl_req+0x1a4>
				usbdc.ifc_alt_map |= 1 << ifc_id;
    5f9e:	2301      	movs	r3, #1
    5fa0:	40bb      	lsls	r3, r7
    5fa2:	7f6f      	ldrb	r7, [r5, #29]
    5fa4:	431f      	orrs	r7, r3
    5fa6:	776f      	strb	r7, [r5, #29]
			usbdc_xfer(0, NULL, 0, 0);
    5fa8:	2300      	movs	r3, #0
    5faa:	461a      	mov	r2, r3
    5fac:	4619      	mov	r1, r3
    5fae:	4618      	mov	r0, r3
    5fb0:	4c47      	ldr	r4, [pc, #284]	; (60d0 <usbdc_cb_ctl_req+0x2cc>)
    5fb2:	47a0      	blx	r4
			return true;
    5fb4:	2001      	movs	r0, #1
}
    5fb6:	b003      	add	sp, #12
    5fb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	switch (req->bRequest) {
    5fbc:	7863      	ldrb	r3, [r4, #1]
    5fbe:	2b0a      	cmp	r3, #10
    5fc0:	f63f af33 	bhi.w	5e2a <usbdc_cb_ctl_req+0x26>
    5fc4:	a201      	add	r2, pc, #4	; (adr r2, 5fcc <usbdc_cb_ctl_req+0x1c8>)
    5fc6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    5fca:	bf00      	nop
    5fcc:	0000609b 	.word	0x0000609b
    5fd0:	00005e2b 	.word	0x00005e2b
    5fd4:	00005e2b 	.word	0x00005e2b
    5fd8:	00005e2b 	.word	0x00005e2b
    5fdc:	00005e2b 	.word	0x00005e2b
    5fe0:	00005e2b 	.word	0x00005e2b
    5fe4:	00005ff9 	.word	0x00005ff9
    5fe8:	00005e2b 	.word	0x00005e2b
    5fec:	0000608b 	.word	0x0000608b
    5ff0:	00005e2b 	.word	0x00005e2b
    5ff4:	000060ed 	.word	0x000060ed
	uint8_t type = (uint8_t)(req->wValue >> 8);
    5ff8:	8863      	ldrh	r3, [r4, #2]
	switch (type) {
    5ffa:	0a1a      	lsrs	r2, r3, #8
    5ffc:	2a02      	cmp	r2, #2
    5ffe:	d016      	beq.n	602e <usbdc_cb_ctl_req+0x22a>
    6000:	2a03      	cmp	r2, #3
    6002:	d031      	beq.n	6068 <usbdc_cb_ctl_req+0x264>
    6004:	2a01      	cmp	r2, #1
    6006:	f47f af10 	bne.w	5e2a <usbdc_cb_ctl_req+0x26>
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
    600a:	4b32      	ldr	r3, [pc, #200]	; (60d4 <usbdc_cb_ctl_req+0x2d0>)
	uint16_t length   = req->wLength;
    600c:	88e4      	ldrh	r4, [r4, #6]
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
    600e:	681b      	ldr	r3, [r3, #0]
    6010:	e9d3 0100 	ldrd	r0, r1, [r3]
    6014:	4b31      	ldr	r3, [pc, #196]	; (60dc <usbdc_cb_ctl_req+0x2d8>)
    6016:	4798      	blx	r3
	if (!dev_desc) {
    6018:	4601      	mov	r1, r0
    601a:	2800      	cmp	r0, #0
    601c:	f43f af05 	beq.w	5e2a <usbdc_cb_ctl_req+0x26>
	if (ERR_NONE != usbdc_xfer(ep, dev_desc, length, false)) {
    6020:	2c12      	cmp	r4, #18
    6022:	4622      	mov	r2, r4
    6024:	f04f 0300 	mov.w	r3, #0
    6028:	bf28      	it	cs
    602a:	2212      	movcs	r2, #18
    602c:	e724      	b.n	5e78 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    602e:	4a29      	ldr	r2, [pc, #164]	; (60d4 <usbdc_cb_ctl_req+0x2d0>)
	uint16_t length   = req->wLength;
    6030:	88e4      	ldrh	r4, [r4, #6]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
    6032:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    6034:	7f16      	ldrb	r6, [r2, #28]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
    6036:	1c5a      	adds	r2, r3, #1
    6038:	e9d0 0100 	ldrd	r0, r1, [r0]
    603c:	b2d2      	uxtb	r2, r2
    603e:	4b26      	ldr	r3, [pc, #152]	; (60d8 <usbdc_cb_ctl_req+0x2d4>)
    6040:	4798      	blx	r3
	if (NULL == cfg_desc) {
    6042:	4601      	mov	r1, r0
    6044:	2800      	cmp	r0, #0
    6046:	f43f aef0 	beq.w	5e2a <usbdc_cb_ctl_req+0x26>
	return (ptr[0] + (ptr[1] << 8));
    604a:	78c3      	ldrb	r3, [r0, #3]
    604c:	7882      	ldrb	r2, [r0, #2]
    604e:	eb02 2203 	add.w	r2, r2, r3, lsl #8
    6052:	b292      	uxth	r2, r2
	if (length <= str_desc[0]) {
    6054:	4294      	cmp	r4, r2
    6056:	d916      	bls.n	6086 <usbdc_cb_ctl_req+0x282>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    6058:	3e01      	subs	r6, #1
    605a:	4226      	tst	r6, r4
    605c:	bf0c      	ite	eq
    605e:	2301      	moveq	r3, #1
    6060:	2300      	movne	r3, #0
    6062:	4614      	mov	r4, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
    6064:	4622      	mov	r2, r4
    6066:	e707      	b.n	5e78 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    6068:	4a1a      	ldr	r2, [pc, #104]	; (60d4 <usbdc_cb_ctl_req+0x2d0>)
	uint16_t length   = req->wLength;
    606a:	88e4      	ldrh	r4, [r4, #6]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
    606c:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    606e:	7f16      	ldrb	r6, [r2, #28]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
    6070:	e9d0 0100 	ldrd	r0, r1, [r0]
    6074:	b2da      	uxtb	r2, r3
    6076:	4b1b      	ldr	r3, [pc, #108]	; (60e4 <usbdc_cb_ctl_req+0x2e0>)
    6078:	4798      	blx	r3
	if (NULL == str_desc) {
    607a:	4601      	mov	r1, r0
    607c:	2800      	cmp	r0, #0
    607e:	f43f aed4 	beq.w	5e2a <usbdc_cb_ctl_req+0x26>
	if (length <= str_desc[0]) {
    6082:	7802      	ldrb	r2, [r0, #0]
    6084:	e7e6      	b.n	6054 <usbdc_cb_ctl_req+0x250>
		need_zlp = false;
    6086:	2300      	movs	r3, #0
    6088:	e7ec      	b.n	6064 <usbdc_cb_ctl_req+0x260>
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
    608a:	4912      	ldr	r1, [pc, #72]	; (60d4 <usbdc_cb_ctl_req+0x2d0>)
    608c:	694b      	ldr	r3, [r1, #20]
    608e:	7eca      	ldrb	r2, [r1, #27]
    6090:	701a      	strb	r2, [r3, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
    6092:	2300      	movs	r3, #0
    6094:	2201      	movs	r2, #1
    6096:	6949      	ldr	r1, [r1, #20]
    6098:	e737      	b.n	5f0a <usbdc_cb_ctl_req+0x106>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    609a:	f001 011f 	and.w	r1, r1, #31
    609e:	2901      	cmp	r1, #1
    60a0:	d922      	bls.n	60e8 <usbdc_cb_ctl_req+0x2e4>
    60a2:	2902      	cmp	r1, #2
    60a4:	f47f aec1 	bne.w	5e2a <usbdc_cb_ctl_req+0x26>
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
    60a8:	88a0      	ldrh	r0, [r4, #4]
    60aa:	4b0d      	ldr	r3, [pc, #52]	; (60e0 <usbdc_cb_ctl_req+0x2dc>)
    60ac:	b2c0      	uxtb	r0, r0
    60ae:	4798      	blx	r3
		if (st < 0) {
    60b0:	2800      	cmp	r0, #0
    60b2:	f6ff aeba 	blt.w	5e2a <usbdc_cb_ctl_req+0x26>
		st = st & 0x1;
    60b6:	f000 0001 	and.w	r0, r0, #1
	memcpy(usbdc.ctrl_buf, &st, 2);
    60ba:	4906      	ldr	r1, [pc, #24]	; (60d4 <usbdc_cb_ctl_req+0x2d0>)
    60bc:	694b      	ldr	r3, [r1, #20]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
    60be:	2202      	movs	r2, #2
	memcpy(usbdc.ctrl_buf, &st, 2);
    60c0:	8018      	strh	r0, [r3, #0]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
    60c2:	2300      	movs	r3, #0
    60c4:	e7e7      	b.n	6096 <usbdc_cb_ctl_req+0x292>
    60c6:	bf00      	nop
    60c8:	00005cbd 	.word	0x00005cbd
    60cc:	00005c81 	.word	0x00005c81
    60d0:	00005de5 	.word	0x00005de5
    60d4:	2000196c 	.word	0x2000196c
    60d8:	00005571 	.word	0x00005571
    60dc:	00005539 	.word	0x00005539
    60e0:	000059f9 	.word	0x000059f9
    60e4:	000055ad 	.word	0x000055ad
		st = 0;
    60e8:	2000      	movs	r0, #0
    60ea:	e7e6      	b.n	60ba <usbdc_cb_ctl_req+0x2b6>
	if (!(usbdc.ifc_alt_map & (1 << req->wIndex))) {
    60ec:	490f      	ldr	r1, [pc, #60]	; (612c <usbdc_cb_ctl_req+0x328>)
    60ee:	88a2      	ldrh	r2, [r4, #4]
    60f0:	7f4b      	ldrb	r3, [r1, #29]
    60f2:	4113      	asrs	r3, r2
    60f4:	f013 0301 	ands.w	r3, r3, #1
    60f8:	460e      	mov	r6, r1
    60fa:	d00c      	beq.n	6116 <usbdc_cb_ctl_req+0x312>
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
    60fc:	690d      	ldr	r5, [r1, #16]
	while (NULL != func) {
    60fe:	2d00      	cmp	r5, #0
    6100:	f43f ae93 	beq.w	5e2a <usbdc_cb_ctl_req+0x26>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
    6104:	686b      	ldr	r3, [r5, #4]
    6106:	4622      	mov	r2, r4
    6108:	2102      	movs	r1, #2
    610a:	4628      	mov	r0, r5
    610c:	4798      	blx	r3
    610e:	2800      	cmp	r0, #0
    6110:	da06      	bge.n	6120 <usbdc_cb_ctl_req+0x31c>
			func = func->next;
    6112:	682d      	ldr	r5, [r5, #0]
    6114:	e7f3      	b.n	60fe <usbdc_cb_ctl_req+0x2fa>
		usbdc.ctrl_buf[0] = 0;
    6116:	694a      	ldr	r2, [r1, #20]
    6118:	7013      	strb	r3, [r2, #0]
		usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
    611a:	6949      	ldr	r1, [r1, #20]
    611c:	2201      	movs	r2, #1
    611e:	e746      	b.n	5fae <usbdc_cb_ctl_req+0x1aa>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
    6120:	6973      	ldr	r3, [r6, #20]
    6122:	7018      	strb	r0, [r3, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
    6124:	2201      	movs	r2, #1
    6126:	2300      	movs	r3, #0
    6128:	6971      	ldr	r1, [r6, #20]
    612a:	e740      	b.n	5fae <usbdc_cb_ctl_req+0x1aa>
    612c:	2000196c 	.word	0x2000196c

00006130 <usbdc_register_handler>:
/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
	switch (type) {
    6130:	2801      	cmp	r0, #1
    6132:	d006      	beq.n	6142 <usbdc_register_handler+0x12>
    6134:	d302      	bcc.n	613c <usbdc_register_handler+0xc>
    6136:	2802      	cmp	r0, #2
    6138:	d005      	beq.n	6146 <usbdc_register_handler+0x16>
    613a:	4770      	bx	lr
	case USBDC_HDL_SOF:
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
    613c:	4803      	ldr	r0, [pc, #12]	; (614c <usbdc_register_handler+0x1c>)
		break;
	case USBDC_HDL_REQ:
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
		break;
	case USBDC_HDL_CHANGE:
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
    613e:	4b04      	ldr	r3, [pc, #16]	; (6150 <usbdc_register_handler+0x20>)
    6140:	4718      	bx	r3
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
    6142:	4804      	ldr	r0, [pc, #16]	; (6154 <usbdc_register_handler+0x24>)
    6144:	e7fb      	b.n	613e <usbdc_register_handler+0xe>
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
    6146:	4804      	ldr	r0, [pc, #16]	; (6158 <usbdc_register_handler+0x28>)
    6148:	e7f9      	b.n	613e <usbdc_register_handler+0xe>
    614a:	bf00      	nop
    614c:	20001970 	.word	0x20001970
    6150:	00005401 	.word	0x00005401
    6154:	20001974 	.word	0x20001974
    6158:	20001978 	.word	0x20001978

0000615c <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
    615c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(ctrl_buf);
    615e:	4604      	mov	r4, r0
    6160:	3000      	adds	r0, #0
    6162:	bf18      	it	ne
    6164:	2001      	movne	r0, #1
    6166:	f240 3255 	movw	r2, #853	; 0x355
    616a:	490b      	ldr	r1, [pc, #44]	; (6198 <usbdc_init+0x3c>)
    616c:	4b0b      	ldr	r3, [pc, #44]	; (619c <usbdc_init+0x40>)
    616e:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
    6170:	4b0b      	ldr	r3, [pc, #44]	; (61a0 <usbdc_init+0x44>)
    6172:	4798      	blx	r3
	if (rc < 0) {
    6174:	2800      	cmp	r0, #0
    6176:	db0e      	blt.n	6196 <usbdc_init+0x3a>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
    6178:	4b0a      	ldr	r3, [pc, #40]	; (61a4 <usbdc_init+0x48>)
    617a:	4d0b      	ldr	r5, [pc, #44]	; (61a8 <usbdc_init+0x4c>)
    617c:	2220      	movs	r2, #32
    617e:	4618      	mov	r0, r3
    6180:	2100      	movs	r1, #0
    6182:	47a8      	blx	r5
	usbdc.ctrl_buf = ctrl_buf;
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
    6184:	4909      	ldr	r1, [pc, #36]	; (61ac <usbdc_init+0x50>)
	usbdc.ctrl_buf = ctrl_buf;
    6186:	6144      	str	r4, [r0, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
    6188:	2000      	movs	r0, #0
    618a:	4c09      	ldr	r4, [pc, #36]	; (61b0 <usbdc_init+0x54>)
    618c:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
    618e:	2001      	movs	r0, #1
    6190:	4908      	ldr	r1, [pc, #32]	; (61b4 <usbdc_init+0x58>)
    6192:	47a0      	blx	r4

	return 0;
    6194:	2000      	movs	r0, #0
}
    6196:	bd38      	pop	{r3, r4, r5, pc}
    6198:	00007a9e 	.word	0x00007a9e
    619c:	0000543d 	.word	0x0000543d
    61a0:	000057b1 	.word	0x000057b1
    61a4:	2000196c 	.word	0x2000196c
    61a8:	000071c5 	.word	0x000071c5
    61ac:	00005cf5 	.word	0x00005cf5
    61b0:	00005815 	.word	0x00005815
    61b4:	00005dcd 	.word	0x00005dcd

000061b8 <usbdc_register_function>:
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
	list_insert_at_end(&usbdc.func_list, func);
    61b8:	4601      	mov	r1, r0
    61ba:	4b01      	ldr	r3, [pc, #4]	; (61c0 <usbdc_register_function+0x8>)
    61bc:	4801      	ldr	r0, [pc, #4]	; (61c4 <usbdc_register_function+0xc>)
    61be:	4718      	bx	r3
    61c0:	00005401 	.word	0x00005401
    61c4:	2000197c 	.word	0x2000197c

000061c8 <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
    61c8:	b510      	push	{r4, lr}
	if (usbdc.state >= USBD_S_POWER) {
    61ca:	4b0a      	ldr	r3, [pc, #40]	; (61f4 <usbdc_start+0x2c>)
    61cc:	7e9c      	ldrb	r4, [r3, #26]
    61ce:	b954      	cbnz	r4, 61e6 <usbdc_start+0x1e>
		return ERR_BUSY;
	}

	if (desces) {
    61d0:	b160      	cbz	r0, 61ec <usbdc_start+0x24>
#endif
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
    61d2:	6802      	ldr	r2, [r0, #0]
		usbdc.desces.ls_fs = desces;
    61d4:	6018      	str	r0, [r3, #0]
	usbdc.ctrl_size = desces->sod[7];
    61d6:	79d2      	ldrb	r2, [r2, #7]
    61d8:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
    61da:	2201      	movs	r2, #1
    61dc:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
    61de:	4b06      	ldr	r3, [pc, #24]	; (61f8 <usbdc_start+0x30>)
    61e0:	4798      	blx	r3
	return ERR_NONE;
    61e2:	4620      	mov	r0, r4
}
    61e4:	bd10      	pop	{r4, pc}
		return ERR_BUSY;
    61e6:	f06f 0003 	mvn.w	r0, #3
    61ea:	e7fb      	b.n	61e4 <usbdc_start+0x1c>
		return ERR_BAD_DATA;
    61ec:	f06f 0008 	mvn.w	r0, #8
    61f0:	e7f8      	b.n	61e4 <usbdc_start+0x1c>
    61f2:	bf00      	nop
    61f4:	2000196c 	.word	0x2000196c
    61f8:	0000581d 	.word	0x0000581d

000061fc <usbdc_attach>:
/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
	usb_d_attach();
    61fc:	4b00      	ldr	r3, [pc, #0]	; (6200 <usbdc_attach+0x4>)
    61fe:	4718      	bx	r3
    6200:	00005825 	.word	0x00005825

00006204 <usbdc_get_ctrl_buffer>:
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
}
    6204:	4b01      	ldr	r3, [pc, #4]	; (620c <usbdc_get_ctrl_buffer+0x8>)
    6206:	6958      	ldr	r0, [r3, #20]
    6208:	4770      	bx	lr
    620a:	bf00      	nop
    620c:	2000196c 	.word	0x2000196c

00006210 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
    6210:	4b03      	ldr	r3, [pc, #12]	; (6220 <usbdc_get_state+0x10>)
    6212:	7e98      	ldrb	r0, [r3, #26]
    6214:	f010 0f10 	tst.w	r0, #16
		return USBD_S_SUSPEND;
	}
	return usbdc.state;
}
    6218:	bf18      	it	ne
    621a:	2010      	movne	r0, #16
    621c:	4770      	bx	lr
    621e:	bf00      	nop
    6220:	2000196c 	.word	0x2000196c

00006224 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    6224:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
    6228:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    622a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    622c:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
    6230:	4770      	bx	lr

00006232 <atomic_leave_critical>:
    6232:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
    6236:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    6238:	f383 8810 	msr	PRIMASK, r3
}
    623c:	4770      	bx	lr
	...

00006240 <Fdocon>:
/* 
 * RUN-TIME FUNCTIONS FOR DEFINED WORDS
 */

void Fdocon (void * pfa) {
    *--psp = *(unsigned int *)pfa;
    6240:	4a03      	ldr	r2, [pc, #12]	; (6250 <Fdocon+0x10>)
    6242:	6813      	ldr	r3, [r2, #0]
    6244:	1f19      	subs	r1, r3, #4
    6246:	6011      	str	r1, [r2, #0]
    6248:	6802      	ldr	r2, [r0, #0]
    624a:	f843 2c04 	str.w	r2, [r3, #-4]
}
    624e:	4770      	bx	lr
    6250:	200042d0 	.word	0x200042d0

00006254 <Fdovar>:
    6254:	4b00      	ldr	r3, [pc, #0]	; (6258 <Fdovar+0x4>)
    6256:	4718      	bx	r3
    6258:	00006241 	.word	0x00006241

0000625c <Fdorom>:
void Fdovar (void * pfa) {
    *--psp = *(unsigned int *)pfa;  /* pf holds variable address */
}

void Fdorom (void * pfa) {
    *--psp = (unsigned int)pfa;
    625c:	4a03      	ldr	r2, [pc, #12]	; (626c <Fdorom+0x10>)
    625e:	6813      	ldr	r3, [r2, #0]
    6260:	1f19      	subs	r1, r3, #4
    6262:	6011      	str	r1, [r2, #0]
    6264:	f843 0c04 	str.w	r0, [r3, #-4]
}
    6268:	4770      	bx	lr
    626a:	bf00      	nop
    626c:	200042d0 	.word	0x200042d0

00006270 <Fenter>:

void Fenter (void * pfa) {
    6270:	b530      	push	{r4, r5, lr}
    *--rsp = (unsigned int)ip;      /* push old IP on return stack */
    6272:	4905      	ldr	r1, [pc, #20]	; (6288 <Fenter+0x18>)
    6274:	4b05      	ldr	r3, [pc, #20]	; (628c <Fenter+0x1c>)
    6276:	680a      	ldr	r2, [r1, #0]
    6278:	681c      	ldr	r4, [r3, #0]
    627a:	1f15      	subs	r5, r2, #4
    627c:	600d      	str	r5, [r1, #0]
    627e:	f842 4c04 	str.w	r4, [r2, #-4]
    ip = pfa;                       /* IP points to thread */
    6282:	6018      	str	r0, [r3, #0]
}
    6284:	bd30      	pop	{r4, r5, pc}
    6286:	bf00      	nop
    6288:	20002188 	.word	0x20002188
    628c:	200019b8 	.word	0x200019b8

00006290 <Fdouser>:

void Fdouser (void * pfa) {
    unsigned int i;
    i = *(unsigned int *)pfa;               /* pf holds user var index */
    *--psp = (unsigned int)(&uservars[i]);  /* stack adrs of user var */
    6290:	6802      	ldr	r2, [r0, #0]
    6292:	4905      	ldr	r1, [pc, #20]	; (62a8 <Fdouser+0x18>)
    6294:	4b05      	ldr	r3, [pc, #20]	; (62ac <Fdouser+0x1c>)
    6296:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    629a:	680a      	ldr	r2, [r1, #0]
    629c:	1f10      	subs	r0, r2, #4
    629e:	6008      	str	r0, [r1, #0]
    62a0:	f842 3c04 	str.w	r3, [r2, #-4]
}
    62a4:	4770      	bx	lr
    62a6:	bf00      	nop
    62a8:	200042d0 	.word	0x200042d0
    62ac:	20002190 	.word	0x20002190

000062b0 <Fdocreate>:
 * which returns the address of 'data' (CFA + 2 cells).
 * DOES> will change child word to    [Fdobuilds] [Tdoesword] [...data...]
 */

void Fdocreate (void * pfa) {
    *--psp = (unsigned int)pfa + CELL;
    62b0:	4a03      	ldr	r2, [pc, #12]	; (62c0 <Fdocreate+0x10>)
    62b2:	6813      	ldr	r3, [r2, #0]
    62b4:	3004      	adds	r0, #4
    62b6:	1f19      	subs	r1, r3, #4
    62b8:	6011      	str	r1, [r2, #0]
    62ba:	f843 0c04 	str.w	r0, [r3, #-4]
}
    62be:	4770      	bx	lr
    62c0:	200042d0 	.word	0x200042d0

000062c4 <Fdobuilds>:
    void (*xt)(void *);     /* pointer to code function */
    void *w, *x;            /* generic pointers */

        w = *(void **)pfa;      /* fetch word address from param field */
        pfa += CELL;
        *--psp = (unsigned int)pfa; /* push address of following data */
    62c4:	4906      	ldr	r1, [pc, #24]	; (62e0 <Fdobuilds+0x1c>)
        w = *(void **)pfa;      /* fetch word address from param field */
    62c6:	f850 3b04 	ldr.w	r3, [r0], #4
        *--psp = (unsigned int)pfa; /* push address of following data */
    62ca:	680a      	ldr	r2, [r1, #0]
void Fdobuilds (void * pfa) {
    62cc:	b410      	push	{r4}
        *--psp = (unsigned int)pfa; /* push address of following data */
    62ce:	1f14      	subs	r4, r2, #4
    62d0:	600c      	str	r4, [r1, #0]
    62d2:	f842 0c04 	str.w	r0, [r2, #-4]
            
        x = *(void **)w;        /* fetch function adrs from word def */
        xt = (void (*)())x;     /* too much casting! */
        w += CELL;
        (*xt)(w);               /* call function w/adrs of word def */
}
    62d6:	f85d 4b04 	ldr.w	r4, [sp], #4
        (*xt)(w);               /* call function w/adrs of word def */
    62da:	681a      	ldr	r2, [r3, #0]
    62dc:	1d18      	adds	r0, r3, #4
    62de:	4710      	bx	r2
    62e0:	200042d0 	.word	0x200042d0

000062e4 <Fexit>:
/* 
 * PRIMITIVE FUNCTIONS
 */

CODE(exit) {
    ip = (void *)(*rsp++);        /* pop IP from return stack */
    62e4:	4a03      	ldr	r2, [pc, #12]	; (62f4 <Fexit+0x10>)
    62e6:	6813      	ldr	r3, [r2, #0]
    62e8:	1d19      	adds	r1, r3, #4
    62ea:	6011      	str	r1, [r2, #0]
    62ec:	681a      	ldr	r2, [r3, #0]
    62ee:	4b02      	ldr	r3, [pc, #8]	; (62f8 <Fexit+0x14>)
    62f0:	601a      	str	r2, [r3, #0]
}
    62f2:	4770      	bx	lr
    62f4:	20002188 	.word	0x20002188
    62f8:	200019b8 	.word	0x200019b8

000062fc <Fexecute>:

CODE(execute) {
    void (*xt)(void *);     /* pointer to code function */
    void *w, *x;            /* generic pointers */
    
        w = *(void **)psp;      /* fetch word address from stack */
    62fc:	4a03      	ldr	r2, [pc, #12]	; (630c <Fexecute+0x10>)
    62fe:	6813      	ldr	r3, [r2, #0]
    6300:	f853 0b04 	ldr.w	r0, [r3], #4
        psp++;
    6304:	6013      	str	r3, [r2, #0]
        x = *(void **)w;        /* fetch function adrs from word def */
        xt = (void (*)())x;     /* too much casting! */
        w += CELL;
        (*xt)(w);               /* call function w/adrs of word def */
    6306:	6803      	ldr	r3, [r0, #0]
    6308:	3004      	adds	r0, #4
    630a:	4718      	bx	r3
    630c:	200042d0 	.word	0x200042d0

00006310 <Flit>:
}

CODE(lit) {
    *--psp = *(unsigned int*)ip;     /* fetch inline value */
    6310:	4b05      	ldr	r3, [pc, #20]	; (6328 <Flit+0x18>)
    6312:	4a06      	ldr	r2, [pc, #24]	; (632c <Flit+0x1c>)
    6314:	6819      	ldr	r1, [r3, #0]
    6316:	1f08      	subs	r0, r1, #4
    6318:	6018      	str	r0, [r3, #0]
    631a:	6813      	ldr	r3, [r2, #0]
    631c:	f853 0b04 	ldr.w	r0, [r3], #4
    6320:	f841 0c04 	str.w	r0, [r1, #-4]
    ip += CELL;
    6324:	6013      	str	r3, [r2, #0]
}    
    6326:	4770      	bx	lr
    6328:	200042d0 	.word	0x200042d0
    632c:	200019b8 	.word	0x200019b8

00006330 <Fdup>:

/* STACK OPERATIONS */

CODE(dup) {
    --psp;
    6330:	4a03      	ldr	r2, [pc, #12]	; (6340 <Fdup+0x10>)
    6332:	6813      	ldr	r3, [r2, #0]
    6334:	1f19      	subs	r1, r3, #4
    6336:	6011      	str	r1, [r2, #0]
    psp[0] = psp[1];
    6338:	681a      	ldr	r2, [r3, #0]
    633a:	f843 2c04 	str.w	r2, [r3, #-4]
}
    633e:	4770      	bx	lr
    6340:	200042d0 	.word	0x200042d0

00006344 <Fqdup>:

CODE(qdup) {
    if (*psp != 0) {
    6344:	4904      	ldr	r1, [pc, #16]	; (6358 <Fqdup+0x14>)
    6346:	680b      	ldr	r3, [r1, #0]
    6348:	681a      	ldr	r2, [r3, #0]
    634a:	b11a      	cbz	r2, 6354 <Fqdup+0x10>
        --psp;
    634c:	1f18      	subs	r0, r3, #4
    634e:	6008      	str	r0, [r1, #0]
        psp[0] = psp[1];
    6350:	f843 2c04 	str.w	r2, [r3, #-4]
    }
}
    6354:	4770      	bx	lr
    6356:	bf00      	nop
    6358:	200042d0 	.word	0x200042d0

0000635c <Fdrop>:

CODE(drop) {
    psp++;
    635c:	4a02      	ldr	r2, [pc, #8]	; (6368 <Fdrop+0xc>)
    635e:	6813      	ldr	r3, [r2, #0]
    6360:	3304      	adds	r3, #4
    6362:	6013      	str	r3, [r2, #0]
}
    6364:	4770      	bx	lr
    6366:	bf00      	nop
    6368:	200042d0 	.word	0x200042d0

0000636c <Fswap>:

CODE(swap) {
    unsigned int x;
    x = psp[1];
    636c:	4b03      	ldr	r3, [pc, #12]	; (637c <Fswap+0x10>)
    636e:	681b      	ldr	r3, [r3, #0]
    psp[1] = psp[0];
    6370:	e9d3 1200 	ldrd	r1, r2, [r3]
    psp[0] = x;
    6374:	e9c3 2100 	strd	r2, r1, [r3]
}
    6378:	4770      	bx	lr
    637a:	bf00      	nop
    637c:	200042d0 	.word	0x200042d0

00006380 <Fover>:

CODE(over) {
    --psp;
    6380:	4a03      	ldr	r2, [pc, #12]	; (6390 <Fover+0x10>)
    6382:	6813      	ldr	r3, [r2, #0]
    6384:	1f19      	subs	r1, r3, #4
    6386:	6011      	str	r1, [r2, #0]
    psp[0] = psp[2];
    6388:	685a      	ldr	r2, [r3, #4]
    638a:	f843 2c04 	str.w	r2, [r3, #-4]
}
    638e:	4770      	bx	lr
    6390:	200042d0 	.word	0x200042d0

00006394 <Frot>:

CODE(rot) {
    unsigned int x;
    x = psp[2];
    6394:	4b04      	ldr	r3, [pc, #16]	; (63a8 <Frot+0x14>)
    6396:	681b      	ldr	r3, [r3, #0]
    psp[2] = psp[1];
    6398:	e9d3 1201 	ldrd	r1, r2, [r3, #4]
    639c:	6099      	str	r1, [r3, #8]
    psp[1] = psp[0];
    639e:	6819      	ldr	r1, [r3, #0]
    psp[0] = x;
    63a0:	e9c3 2100 	strd	r2, r1, [r3]
}
    63a4:	4770      	bx	lr
    63a6:	bf00      	nop
    63a8:	200042d0 	.word	0x200042d0

000063ac <Fnip>:

CODE(nip) {     // x1 x2 -- x2
    psp[1] = psp[0];
    63ac:	4a03      	ldr	r2, [pc, #12]	; (63bc <Fnip+0x10>)
    63ae:	6813      	ldr	r3, [r2, #0]
    63b0:	6819      	ldr	r1, [r3, #0]
    63b2:	f843 1f04 	str.w	r1, [r3, #4]!
    psp++;
    63b6:	6013      	str	r3, [r2, #0]
}
    63b8:	4770      	bx	lr
    63ba:	bf00      	nop
    63bc:	200042d0 	.word	0x200042d0

000063c0 <Ftuck>:

CODE(tuck) {    // x1 x2 -- x2 x1 x2
    unsigned int x;
    --psp;
    63c0:	4a05      	ldr	r2, [pc, #20]	; (63d8 <Ftuck+0x18>)
    63c2:	6813      	ldr	r3, [r2, #0]
    63c4:	1f19      	subs	r1, r3, #4
    63c6:	6011      	str	r1, [r2, #0]
    x = psp[2];   // x1
    psp[2] = psp[0] = psp[1];   // x2
    63c8:	e9d3 2100 	ldrd	r2, r1, [r3]
    63cc:	f843 2c04 	str.w	r2, [r3, #-4]
    psp[1] = x;
    63d0:	e9c3 1200 	strd	r1, r2, [r3]
}
    63d4:	4770      	bx	lr
    63d6:	bf00      	nop
    63d8:	200042d0 	.word	0x200042d0

000063dc <Ftor>:

CODE(tor) {
    *--rsp = *psp++;
    63dc:	4b05      	ldr	r3, [pc, #20]	; (63f4 <Ftor+0x18>)
    63de:	681a      	ldr	r2, [r3, #0]
    63e0:	1d11      	adds	r1, r2, #4
    63e2:	6019      	str	r1, [r3, #0]
    63e4:	4904      	ldr	r1, [pc, #16]	; (63f8 <Ftor+0x1c>)
    63e6:	6812      	ldr	r2, [r2, #0]
    63e8:	680b      	ldr	r3, [r1, #0]
    63ea:	1f18      	subs	r0, r3, #4
    63ec:	6008      	str	r0, [r1, #0]
    63ee:	f843 2c04 	str.w	r2, [r3, #-4]
}
    63f2:	4770      	bx	lr
    63f4:	200042d0 	.word	0x200042d0
    63f8:	20002188 	.word	0x20002188

000063fc <Frfrom>:

CODE(rfrom) {
    *--psp = *rsp++;
    63fc:	4b05      	ldr	r3, [pc, #20]	; (6414 <Frfrom+0x18>)
    63fe:	681a      	ldr	r2, [r3, #0]
    6400:	1d11      	adds	r1, r2, #4
    6402:	6019      	str	r1, [r3, #0]
    6404:	4904      	ldr	r1, [pc, #16]	; (6418 <Frfrom+0x1c>)
    6406:	6812      	ldr	r2, [r2, #0]
    6408:	680b      	ldr	r3, [r1, #0]
    640a:	1f18      	subs	r0, r3, #4
    640c:	6008      	str	r0, [r1, #0]
    640e:	f843 2c04 	str.w	r2, [r3, #-4]
}
    6412:	4770      	bx	lr
    6414:	20002188 	.word	0x20002188
    6418:	200042d0 	.word	0x200042d0

0000641c <Frfetch>:

CODE(rfetch) {
    *--psp = *rsp;
    641c:	4a04      	ldr	r2, [pc, #16]	; (6430 <Frfetch+0x14>)
    641e:	4b05      	ldr	r3, [pc, #20]	; (6434 <Frfetch+0x18>)
    6420:	6819      	ldr	r1, [r3, #0]
    6422:	6813      	ldr	r3, [r2, #0]
    6424:	1f18      	subs	r0, r3, #4
    6426:	6010      	str	r0, [r2, #0]
    6428:	680a      	ldr	r2, [r1, #0]
    642a:	f843 2c04 	str.w	r2, [r3, #-4]
}
    642e:	4770      	bx	lr
    6430:	200042d0 	.word	0x200042d0
    6434:	20002188 	.word	0x20002188

00006438 <Fspfetch>:

CODE(spfetch) {
    unsigned int temp;
    temp = (unsigned int)psp;    /* circumvent weird optimization */
    6438:	4a03      	ldr	r2, [pc, #12]	; (6448 <Fspfetch+0x10>)
    643a:	6813      	ldr	r3, [r2, #0]
    *--psp = temp;
    643c:	1f19      	subs	r1, r3, #4
    643e:	6011      	str	r1, [r2, #0]
    6440:	f843 3c04 	str.w	r3, [r3, #-4]
}
    6444:	4770      	bx	lr
    6446:	bf00      	nop
    6448:	200042d0 	.word	0x200042d0

0000644c <Fspstore>:

CODE(spstore) {
    psp = (unsigned int *)(*psp);   /* do not use *psp++ */
    644c:	4b02      	ldr	r3, [pc, #8]	; (6458 <Fspstore+0xc>)
    644e:	681a      	ldr	r2, [r3, #0]
    6450:	6812      	ldr	r2, [r2, #0]
    6452:	601a      	str	r2, [r3, #0]
}
    6454:	4770      	bx	lr
    6456:	bf00      	nop
    6458:	200042d0 	.word	0x200042d0

0000645c <Frpfetch>:

CODE(rpfetch) {
    *--psp = (unsigned int)rsp;
    645c:	4b04      	ldr	r3, [pc, #16]	; (6470 <Frpfetch+0x14>)
    645e:	4a05      	ldr	r2, [pc, #20]	; (6474 <Frpfetch+0x18>)
    6460:	6819      	ldr	r1, [r3, #0]
    6462:	6813      	ldr	r3, [r2, #0]
    6464:	1f18      	subs	r0, r3, #4
    6466:	6010      	str	r0, [r2, #0]
    6468:	f843 1c04 	str.w	r1, [r3, #-4]
}
    646c:	4770      	bx	lr
    646e:	bf00      	nop
    6470:	20002188 	.word	0x20002188
    6474:	200042d0 	.word	0x200042d0

00006478 <Frpstore>:

CODE(rpstore) {
    rsp = (unsigned int *)(*psp++);
    6478:	4a03      	ldr	r2, [pc, #12]	; (6488 <Frpstore+0x10>)
    647a:	6813      	ldr	r3, [r2, #0]
    647c:	1d19      	adds	r1, r3, #4
    647e:	6011      	str	r1, [r2, #0]
    6480:	681a      	ldr	r2, [r3, #0]
    6482:	4b02      	ldr	r3, [pc, #8]	; (648c <Frpstore+0x14>)
    6484:	601a      	str	r2, [r3, #0]
}
    6486:	4770      	bx	lr
    6488:	200042d0 	.word	0x200042d0
    648c:	20002188 	.word	0x20002188

00006490 <Ffetch>:

/* MEMORY OPERATIONS */

CODE(fetch) {
    unsigned int *ptr;
    ptr = (unsigned int*) psp[0];
    6490:	4b02      	ldr	r3, [pc, #8]	; (649c <Ffetch+0xc>)
    6492:	681b      	ldr	r3, [r3, #0]
    psp[0] = *ptr;
    6494:	681a      	ldr	r2, [r3, #0]
    6496:	6812      	ldr	r2, [r2, #0]
    6498:	601a      	str	r2, [r3, #0]
}
    649a:	4770      	bx	lr
    649c:	200042d0 	.word	0x200042d0

000064a0 <Fstore>:

CODE(store) {
    unsigned int *ptr;
    ptr = (unsigned int*)(*psp++);
    64a0:	4904      	ldr	r1, [pc, #16]	; (64b4 <Fstore+0x14>)
    64a2:	680a      	ldr	r2, [r1, #0]
    64a4:	4613      	mov	r3, r2
    64a6:	f853 0b08 	ldr.w	r0, [r3], #8
    *ptr = *psp++;
    64aa:	600b      	str	r3, [r1, #0]
    64ac:	6853      	ldr	r3, [r2, #4]
    64ae:	6003      	str	r3, [r0, #0]
}
    64b0:	4770      	bx	lr
    64b2:	bf00      	nop
    64b4:	200042d0 	.word	0x200042d0

000064b8 <Fcfetch>:

CODE(cfetch) {
    unsigned char *ptr;
    ptr = (unsigned char*) psp[0];
    64b8:	4b02      	ldr	r3, [pc, #8]	; (64c4 <Fcfetch+0xc>)
    64ba:	681b      	ldr	r3, [r3, #0]
    psp[0] = (unsigned int)(*ptr);
    64bc:	681a      	ldr	r2, [r3, #0]
    64be:	7812      	ldrb	r2, [r2, #0]
    64c0:	601a      	str	r2, [r3, #0]
}
    64c2:	4770      	bx	lr
    64c4:	200042d0 	.word	0x200042d0

000064c8 <Fcstore>:

CODE(cstore) {
    unsigned char *ptr;
    ptr = (unsigned char*)(*psp++);
    64c8:	4904      	ldr	r1, [pc, #16]	; (64dc <Fcstore+0x14>)
    64ca:	680a      	ldr	r2, [r1, #0]
    64cc:	4613      	mov	r3, r2
    64ce:	f853 0b08 	ldr.w	r0, [r3], #8
    *ptr = (unsigned char)(*psp++);
    64d2:	600b      	str	r3, [r1, #0]
    64d4:	6853      	ldr	r3, [r2, #4]
    64d6:	7003      	strb	r3, [r0, #0]
}
    64d8:	4770      	bx	lr
    64da:	bf00      	nop
    64dc:	200042d0 	.word	0x200042d0

000064e0 <Fplus>:

/* ARITHMETIC AND LOGIC OPERATIONS */

CODE(plus) {
    psp[1] += psp[0];
    64e0:	4904      	ldr	r1, [pc, #16]	; (64f4 <Fplus+0x14>)
    64e2:	680b      	ldr	r3, [r1, #0]
    64e4:	e9d3 0200 	ldrd	r0, r2, [r3]
    64e8:	4402      	add	r2, r0
    64ea:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    64ee:	600b      	str	r3, [r1, #0]
}
    64f0:	4770      	bx	lr
    64f2:	bf00      	nop
    64f4:	200042d0 	.word	0x200042d0

000064f8 <Fplusstore>:

CODE(plusstore) {
    unsigned int *ptr;
    ptr = (unsigned int*)(*psp++);
    64f8:	4805      	ldr	r0, [pc, #20]	; (6510 <Fplusstore+0x18>)
    64fa:	6801      	ldr	r1, [r0, #0]
    64fc:	460b      	mov	r3, r1
    *ptr += *psp++;
    64fe:	6849      	ldr	r1, [r1, #4]
    ptr = (unsigned int*)(*psp++);
    6500:	f853 2b08 	ldr.w	r2, [r3], #8
    *ptr += *psp++;
    6504:	6003      	str	r3, [r0, #0]
    6506:	6813      	ldr	r3, [r2, #0]
    6508:	440b      	add	r3, r1
    650a:	6013      	str	r3, [r2, #0]
}    
    650c:	4770      	bx	lr
    650e:	bf00      	nop
    6510:	200042d0 	.word	0x200042d0

00006514 <Fmplus>:

CODE(mplus) {
    uint64_t d;
    unsigned int n;
    n = *psp++;
    6514:	4b09      	ldr	r3, [pc, #36]	; (653c <Fmplus+0x28>)
    6516:	6819      	ldr	r1, [r3, #0]
    6518:	1d0a      	adds	r2, r1, #4
CODE(mplus) {
    651a:	b5f0      	push	{r4, r5, r6, r7, lr}
    /* enforce Forth word order, high on top */
    d = (((uint64_t)psp[0]) << CELLWIDTH) + psp[1];
    651c:	6888      	ldr	r0, [r1, #8]
    n = *psp++;
    651e:	601a      	str	r2, [r3, #0]
    d += n;
    6520:	680a      	ldr	r2, [r1, #0]
    6522:	2500      	movs	r5, #0
    6524:	1812      	adds	r2, r2, r0
    6526:	f145 0300 	adc.w	r3, r5, #0
    d = (((uint64_t)psp[0]) << CELLWIDTH) + psp[1];
    652a:	2400      	movs	r4, #0
    652c:	684d      	ldr	r5, [r1, #4]
    d += n;
    652e:	1916      	adds	r6, r2, r4
    6530:	eb43 0705 	adc.w	r7, r3, r5
    psp[0] = (unsigned int)(d >> CELLWIDTH);
    psp[1] = d & CELLMASK;
    6534:	e9c1 7601 	strd	r7, r6, [r1, #4]
}
    6538:	bdf0      	pop	{r4, r5, r6, r7, pc}
    653a:	bf00      	nop
    653c:	200042d0 	.word	0x200042d0

00006540 <Fminus>:

CODE(minus) {
    psp[1] -= psp[0];
    6540:	4904      	ldr	r1, [pc, #16]	; (6554 <Fminus+0x14>)
    6542:	680b      	ldr	r3, [r1, #0]
    6544:	e9d3 0200 	ldrd	r0, r2, [r3]
    6548:	1a12      	subs	r2, r2, r0
    654a:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    654e:	600b      	str	r3, [r1, #0]
}
    6550:	4770      	bx	lr
    6552:	bf00      	nop
    6554:	200042d0 	.word	0x200042d0

00006558 <Fmult>:

CODE(mult) {
    signed int r;
    r = (signed int)psp[1] * (signed int)psp[0];
    6558:	4805      	ldr	r0, [pc, #20]	; (6570 <Fmult+0x18>)
    655a:	6803      	ldr	r3, [r0, #0]
CODE(mult) {
    655c:	b510      	push	{r4, lr}
    r = (signed int)psp[1] * (signed int)psp[0];
    655e:	4619      	mov	r1, r3
    6560:	685c      	ldr	r4, [r3, #4]
    6562:	f851 2b04 	ldr.w	r2, [r1], #4
    psp++;
    6566:	6001      	str	r1, [r0, #0]
    r = (signed int)psp[1] * (signed int)psp[0];
    6568:	4362      	muls	r2, r4
    psp[0] = (unsigned int)r;
    656a:	605a      	str	r2, [r3, #4]
}
    656c:	bd10      	pop	{r4, pc}
    656e:	bf00      	nop
    6570:	200042d0 	.word	0x200042d0

00006574 <Fdiv>:

CODE(div) {
    signed int r;
    r = (signed int)psp[1] / (signed int)psp[0];
    6574:	4805      	ldr	r0, [pc, #20]	; (658c <Fdiv+0x18>)
CODE(div) {
    6576:	b510      	push	{r4, lr}
    r = (signed int)psp[1] / (signed int)psp[0];
    6578:	6803      	ldr	r3, [r0, #0]
    657a:	4619      	mov	r1, r3
    657c:	685a      	ldr	r2, [r3, #4]
    657e:	f851 4b04 	ldr.w	r4, [r1], #4
    psp++;
    6582:	6001      	str	r1, [r0, #0]
    r = (signed int)psp[1] / (signed int)psp[0];
    6584:	fb92 f2f4 	sdiv	r2, r2, r4
    psp[0] = (unsigned int)r;
    6588:	605a      	str	r2, [r3, #4]
}
    658a:	bd10      	pop	{r4, pc}
    658c:	200042d0 	.word	0x200042d0

00006590 <Fand>:

CODE(and) {
    psp[1] &= psp[0];
    6590:	4904      	ldr	r1, [pc, #16]	; (65a4 <Fand+0x14>)
    6592:	680b      	ldr	r3, [r1, #0]
    6594:	e9d3 0200 	ldrd	r0, r2, [r3]
    6598:	4002      	ands	r2, r0
    659a:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    659e:	600b      	str	r3, [r1, #0]
}
    65a0:	4770      	bx	lr
    65a2:	bf00      	nop
    65a4:	200042d0 	.word	0x200042d0

000065a8 <For>:
    
CODE(or) {
    psp[1] |= psp[0];
    65a8:	4904      	ldr	r1, [pc, #16]	; (65bc <For+0x14>)
    65aa:	680b      	ldr	r3, [r1, #0]
    65ac:	e9d3 0200 	ldrd	r0, r2, [r3]
    65b0:	4302      	orrs	r2, r0
    65b2:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    65b6:	600b      	str	r3, [r1, #0]
}
    65b8:	4770      	bx	lr
    65ba:	bf00      	nop
    65bc:	200042d0 	.word	0x200042d0

000065c0 <Fxor>:
    
CODE(xor) {
    psp[1] ^= psp[0];
    65c0:	4904      	ldr	r1, [pc, #16]	; (65d4 <Fxor+0x14>)
    65c2:	680b      	ldr	r3, [r1, #0]
    65c4:	e9d3 0200 	ldrd	r0, r2, [r3]
    65c8:	4042      	eors	r2, r0
    65ca:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    65ce:	600b      	str	r3, [r1, #0]
}
    65d0:	4770      	bx	lr
    65d2:	bf00      	nop
    65d4:	200042d0 	.word	0x200042d0

000065d8 <Finvert>:

CODE(invert) {
    *psp ^= CELLMASK;
    65d8:	4b02      	ldr	r3, [pc, #8]	; (65e4 <Finvert+0xc>)
    65da:	681a      	ldr	r2, [r3, #0]
    65dc:	6813      	ldr	r3, [r2, #0]
    65de:	43db      	mvns	r3, r3
    65e0:	6013      	str	r3, [r2, #0]
}
    65e2:	4770      	bx	lr
    65e4:	200042d0 	.word	0x200042d0

000065e8 <Fnegate>:

CODE(negate) {
    *psp = -(*psp);
    65e8:	4b02      	ldr	r3, [pc, #8]	; (65f4 <Fnegate+0xc>)
    65ea:	681a      	ldr	r2, [r3, #0]
    65ec:	6813      	ldr	r3, [r2, #0]
    65ee:	425b      	negs	r3, r3
    65f0:	6013      	str	r3, [r2, #0]
}
    65f2:	4770      	bx	lr
    65f4:	200042d0 	.word	0x200042d0

000065f8 <Foneplus>:

CODE(oneplus) {
    *psp += 1;
    65f8:	4b02      	ldr	r3, [pc, #8]	; (6604 <Foneplus+0xc>)
    65fa:	681a      	ldr	r2, [r3, #0]
    65fc:	6813      	ldr	r3, [r2, #0]
    65fe:	3301      	adds	r3, #1
    6600:	6013      	str	r3, [r2, #0]
}
    6602:	4770      	bx	lr
    6604:	200042d0 	.word	0x200042d0

00006608 <Foneminus>:

CODE(oneminus) {
    *psp -= 1;
    6608:	4b02      	ldr	r3, [pc, #8]	; (6614 <Foneminus+0xc>)
    660a:	681a      	ldr	r2, [r3, #0]
    660c:	6813      	ldr	r3, [r2, #0]
    660e:	3b01      	subs	r3, #1
    6610:	6013      	str	r3, [r2, #0]
}
    6612:	4770      	bx	lr
    6614:	200042d0 	.word	0x200042d0

00006618 <Fswapbytes>:

CODE(swapbytes) {
    unsigned int u;
    u = *psp;
    6618:	4b03      	ldr	r3, [pc, #12]	; (6628 <Fswapbytes+0x10>)
    661a:	681a      	ldr	r2, [r3, #0]
    *psp = ((u & 0xff) << 8) | ((u & 0xff00) >> 8);
    661c:	8813      	ldrh	r3, [r2, #0]
    661e:	ba5b      	rev16	r3, r3
    6620:	b29b      	uxth	r3, r3
    6622:	6013      	str	r3, [r2, #0]
}
    6624:	4770      	bx	lr
    6626:	bf00      	nop
    6628:	200042d0 	.word	0x200042d0

0000662c <Ftwostar>:

CODE(twostar) {
    *psp = (*psp) << 1;
    662c:	4b02      	ldr	r3, [pc, #8]	; (6638 <Ftwostar+0xc>)
    662e:	681a      	ldr	r2, [r3, #0]
    6630:	6813      	ldr	r3, [r2, #0]
    6632:	005b      	lsls	r3, r3, #1
    6634:	6013      	str	r3, [r2, #0]
}
    6636:	4770      	bx	lr
    6638:	200042d0 	.word	0x200042d0

0000663c <Ftwoslash>:

CODE(twoslash) {
    signed int n;
    n = (signed int)(*psp);
    663c:	4b02      	ldr	r3, [pc, #8]	; (6648 <Ftwoslash+0xc>)
    663e:	681a      	ldr	r2, [r3, #0]
    *psp = (unsigned int)(n >> 1);
    6640:	6813      	ldr	r3, [r2, #0]
    6642:	105b      	asrs	r3, r3, #1
    6644:	6013      	str	r3, [r2, #0]
}
    6646:	4770      	bx	lr
    6648:	200042d0 	.word	0x200042d0

0000664c <Flshift>:

CODE(lshift) {
    unsigned int u;
    u = *psp++;
    664c:	4a04      	ldr	r2, [pc, #16]	; (6660 <Flshift+0x14>)
    664e:	6813      	ldr	r3, [r2, #0]
    6650:	1d19      	adds	r1, r3, #4
    6652:	6011      	str	r1, [r2, #0]
    *psp = (*psp) << u;
    6654:	e9d3 1200 	ldrd	r1, r2, [r3]
    6658:	408a      	lsls	r2, r1
    665a:	605a      	str	r2, [r3, #4]
}
    665c:	4770      	bx	lr
    665e:	bf00      	nop
    6660:	200042d0 	.word	0x200042d0

00006664 <Frshift>:

CODE(rshift) {
    unsigned int u;
    u = *psp++;
    6664:	4a04      	ldr	r2, [pc, #16]	; (6678 <Frshift+0x14>)
    6666:	6813      	ldr	r3, [r2, #0]
    6668:	1d19      	adds	r1, r3, #4
    666a:	6011      	str	r1, [r2, #0]
    *psp = (*psp) >> u;
    666c:	e9d3 1200 	ldrd	r1, r2, [r3]
    6670:	40ca      	lsrs	r2, r1
    6672:	605a      	str	r2, [r3, #4]
}
    6674:	4770      	bx	lr
    6676:	bf00      	nop
    6678:	200042d0 	.word	0x200042d0

0000667c <Fzeroequal>:

/* COMPARISONS */

CODE(zeroequal) {
    psp[0] = (psp[0] == 0) ? -1 : 0;
    667c:	4b04      	ldr	r3, [pc, #16]	; (6690 <Fzeroequal+0x14>)
    667e:	681a      	ldr	r2, [r3, #0]
    6680:	6813      	ldr	r3, [r2, #0]
    6682:	fab3 f383 	clz	r3, r3
    6686:	095b      	lsrs	r3, r3, #5
    6688:	425b      	negs	r3, r3
    668a:	6013      	str	r3, [r2, #0]
}
    668c:	4770      	bx	lr
    668e:	bf00      	nop
    6690:	200042d0 	.word	0x200042d0

00006694 <Fzeroless>:

CODE(zeroless) {
    psp[0] = ((signed int)(psp[0]) < 0) ? -1 : 0;
    6694:	4b02      	ldr	r3, [pc, #8]	; (66a0 <Fzeroless+0xc>)
    6696:	681a      	ldr	r2, [r3, #0]
    6698:	6813      	ldr	r3, [r2, #0]
    669a:	17db      	asrs	r3, r3, #31
    669c:	6013      	str	r3, [r2, #0]
}
    669e:	4770      	bx	lr
    66a0:	200042d0 	.word	0x200042d0

000066a4 <Fequal>:

CODE(equal) {
    psp[1] = (psp[1] == psp[0]) ? -1 : 0;
    66a4:	4906      	ldr	r1, [pc, #24]	; (66c0 <Fequal+0x1c>)
    66a6:	680b      	ldr	r3, [r1, #0]
    66a8:	e9d3 0200 	ldrd	r0, r2, [r3]
    66ac:	4282      	cmp	r2, r0
    66ae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    66b2:	bf18      	it	ne
    66b4:	2200      	movne	r2, #0
    66b6:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    66ba:	600b      	str	r3, [r1, #0]
}
    66bc:	4770      	bx	lr
    66be:	bf00      	nop
    66c0:	200042d0 	.word	0x200042d0

000066c4 <Fnotequal>:

CODE(notequal) {
    psp[1] = (psp[1] != psp[0]) ? -1 : 0;
    66c4:	4905      	ldr	r1, [pc, #20]	; (66dc <Fnotequal+0x18>)
    66c6:	680b      	ldr	r3, [r1, #0]
    66c8:	e9d3 0200 	ldrd	r0, r2, [r3]
    66cc:	1a12      	subs	r2, r2, r0
    66ce:	bf18      	it	ne
    66d0:	f04f 32ff 	movne.w	r2, #4294967295	; 0xffffffff
    66d4:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    66d8:	600b      	str	r3, [r1, #0]
}
    66da:	4770      	bx	lr
    66dc:	200042d0 	.word	0x200042d0

000066e0 <Fless>:

CODE(less) {
    psp[1] = ((signed int)(psp[1]) < (signed int)(psp[0])) ? -1 : 0;
    66e0:	4906      	ldr	r1, [pc, #24]	; (66fc <Fless+0x1c>)
    66e2:	680b      	ldr	r3, [r1, #0]
    66e4:	e9d3 0200 	ldrd	r0, r2, [r3]
    66e8:	4282      	cmp	r2, r0
    66ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    66ee:	bfa8      	it	ge
    66f0:	2200      	movge	r2, #0
    66f2:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    66f6:	600b      	str	r3, [r1, #0]
}
    66f8:	4770      	bx	lr
    66fa:	bf00      	nop
    66fc:	200042d0 	.word	0x200042d0

00006700 <Fgreater>:

CODE(greater) {
    psp[1] = ((signed int)(psp[1]) > (signed int)(psp[0])) ? -1 : 0;
    6700:	4906      	ldr	r1, [pc, #24]	; (671c <Fgreater+0x1c>)
    6702:	680b      	ldr	r3, [r1, #0]
    6704:	e9d3 0200 	ldrd	r0, r2, [r3]
    6708:	4282      	cmp	r2, r0
    670a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    670e:	bfd8      	it	le
    6710:	2200      	movle	r2, #0
    6712:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    6716:	600b      	str	r3, [r1, #0]
}
    6718:	4770      	bx	lr
    671a:	bf00      	nop
    671c:	200042d0 	.word	0x200042d0

00006720 <Fuless>:

CODE(uless) {
    psp[1] = (psp[1] < psp[0]) ? -1 : 0;
    6720:	4906      	ldr	r1, [pc, #24]	; (673c <Fuless+0x1c>)
    6722:	680b      	ldr	r3, [r1, #0]
    6724:	e9d3 0200 	ldrd	r0, r2, [r3]
    6728:	4282      	cmp	r2, r0
    672a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    672e:	bf28      	it	cs
    6730:	2200      	movcs	r2, #0
    6732:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    6736:	600b      	str	r3, [r1, #0]
}
    6738:	4770      	bx	lr
    673a:	bf00      	nop
    673c:	200042d0 	.word	0x200042d0

00006740 <Fugreater>:

CODE(ugreater) {
    psp[1] = (psp[1] > psp[0]) ? -1 : 0;
    6740:	4906      	ldr	r1, [pc, #24]	; (675c <Fugreater+0x1c>)
    6742:	680b      	ldr	r3, [r1, #0]
    6744:	e9d3 0200 	ldrd	r0, r2, [r3]
    6748:	4282      	cmp	r2, r0
    674a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    674e:	bf98      	it	ls
    6750:	2200      	movls	r2, #0
    6752:	f843 2f04 	str.w	r2, [r3, #4]!
    psp++;
    6756:	600b      	str	r3, [r1, #0]
}
    6758:	4770      	bx	lr
    675a:	bf00      	nop
    675c:	200042d0 	.word	0x200042d0

00006760 <Fbranch>:

/* BRANCH AND LOOP */

CODE(branch) {     /* Tbranch,-4  loops back to itself */
    int offset;                 /* Tbranch,+4  is a no-op */
    offset = *(unsigned int*)ip;     /* fetch inline offset */
    6760:	4a02      	ldr	r2, [pc, #8]	; (676c <Fbranch+0xc>)
    6762:	6813      	ldr	r3, [r2, #0]
    ip += offset;
    6764:	6819      	ldr	r1, [r3, #0]
    6766:	440b      	add	r3, r1
    6768:	6013      	str	r3, [r2, #0]
}
    676a:	4770      	bx	lr
    676c:	200019b8 	.word	0x200019b8

00006770 <Fxdo>:
        ip += offset;
    }
}        

CODE(xdo) {     /* limit start -- */
    *--rsp = psp[1];        // push limit
    6770:	4908      	ldr	r1, [pc, #32]	; (6794 <Fxdo+0x24>)
    6772:	4809      	ldr	r0, [pc, #36]	; (6798 <Fxdo+0x28>)
    6774:	680b      	ldr	r3, [r1, #0]
    6776:	6802      	ldr	r2, [r0, #0]
CODE(xdo) {     /* limit start -- */
    6778:	b510      	push	{r4, lr}
    *--rsp = psp[1];        // push limit
    677a:	685c      	ldr	r4, [r3, #4]
    677c:	f842 4c04 	str.w	r4, [r2, #-4]
    *--rsp = *psp++;        // push starting index
    6780:	f1a2 0408 	sub.w	r4, r2, #8
    6784:	6004      	str	r4, [r0, #0]
    6786:	f853 0b08 	ldr.w	r0, [r3], #8
    678a:	f842 0c08 	str.w	r0, [r2, #-8]
    psp++;
    678e:	600b      	str	r3, [r1, #0]
}
    6790:	bd10      	pop	{r4, pc}
    6792:	bf00      	nop
    6794:	200042d0 	.word	0x200042d0
    6798:	20002188 	.word	0x20002188

0000679c <Fi>:
    679c:	4b00      	ldr	r3, [pc, #0]	; (67a0 <Fi+0x4>)
    679e:	4718      	bx	r3
    67a0:	0000641d 	.word	0x0000641d

000067a4 <Fj>:
CODE(i) {
    *--psp = rsp[0];        // first loop index 
}

CODE(j) {
    *--psp = rsp[2];        // second loop index
    67a4:	4a04      	ldr	r2, [pc, #16]	; (67b8 <Fj+0x14>)
    67a6:	4b05      	ldr	r3, [pc, #20]	; (67bc <Fj+0x18>)
    67a8:	6819      	ldr	r1, [r3, #0]
    67aa:	6813      	ldr	r3, [r2, #0]
    67ac:	1f18      	subs	r0, r3, #4
    67ae:	6010      	str	r0, [r2, #0]
    67b0:	688a      	ldr	r2, [r1, #8]
    67b2:	f843 2c04 	str.w	r2, [r3, #-4]
}
    67b6:	4770      	bx	lr
    67b8:	200042d0 	.word	0x200042d0
    67bc:	20002188 	.word	0x20002188

000067c0 <Funloop>:
    
CODE(unloop) {
    rsp += 2;
    67c0:	4a02      	ldr	r2, [pc, #8]	; (67cc <Funloop+0xc>)
    67c2:	6813      	ldr	r3, [r2, #0]
    67c4:	3308      	adds	r3, #8
    67c6:	6013      	str	r3, [r2, #0]
}
    67c8:	4770      	bx	lr
    67ca:	bf00      	nop
    67cc:	20002188 	.word	0x20002188

000067d0 <Fumstar>:

/* MULTIPLY AND DIVIDE */

CODE(umstar) {  /* u1 u2 -- ud */
    uint64_t ud;
    ud = (uint64_t)psp[0] * (uint64_t)psp[1];
    67d0:	4b04      	ldr	r3, [pc, #16]	; (67e4 <Fumstar+0x14>)
    67d2:	681b      	ldr	r3, [r3, #0]
    67d4:	e9d3 0200 	ldrd	r0, r2, [r3]
    67d8:	fba0 0102 	umull	r0, r1, r0, r2
    psp[1] = ud & (uint64_t)0xffffffff;
    psp[0] = ud >> 32;
    67dc:	e9c3 1000 	strd	r1, r0, [r3]
}    
    67e0:	4770      	bx	lr
    67e2:	bf00      	nop
    67e4:	200042d0 	.word	0x200042d0

000067e8 <Fumslashmod>:
    
CODE(umslashmod) {  /* ud u1 -- rem quot */
    67e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint64_t ud, u1;
    u1 = *psp++;
    67ea:	4b08      	ldr	r3, [pc, #32]	; (680c <Fumslashmod+0x24>)
    67ec:	681c      	ldr	r4, [r3, #0]
    ud = ((uint64_t)psp[0] << 32) | (uint64_t)psp[1];
    67ee:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
    u1 = *psp++;
    67f2:	1d22      	adds	r2, r4, #4
    ud = ((uint64_t)psp[0] << 32) | (uint64_t)psp[1];
    67f4:	2600      	movs	r6, #0
    u1 = *psp++;
    67f6:	601a      	str	r2, [r3, #0]
    67f8:	ea46 0005 	orr.w	r0, r6, r5
    67fc:	6822      	ldr	r2, [r4, #0]
    67fe:	4d04      	ldr	r5, [pc, #16]	; (6810 <Fumslashmod+0x28>)
    6800:	4633      	mov	r3, r6
    6802:	4639      	mov	r1, r7
    6804:	47a8      	blx	r5
    psp[1] = (unsigned int)(ud % u1);
    psp[0] = (unsigned int)(ud / u1);
    6806:	e9c4 0201 	strd	r0, r2, [r4, #4]
}
    680a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    680c:	200042d0 	.word	0x200042d0
    6810:	00006e35 	.word	0x00006e35

00006814 <Ffill>:
/* BLOCK AND STRING OPERATIONS */

CODE(fill) {    /* c-addr u char -- */
    unsigned char c, *dst;
    unsigned int u;
    c = (unsigned char)*psp++;
    6814:	4907      	ldr	r1, [pc, #28]	; (6834 <Ffill+0x20>)
    6816:	680b      	ldr	r3, [r1, #0]
CODE(fill) {    /* c-addr u char -- */
    6818:	b510      	push	{r4, lr}
    c = (unsigned char)*psp++;
    681a:	7818      	ldrb	r0, [r3, #0]
    u = *psp++;
    681c:	685a      	ldr	r2, [r3, #4]
    dst = (unsigned char *)*psp++;
    681e:	f103 040c 	add.w	r4, r3, #12
    6822:	689b      	ldr	r3, [r3, #8]
    6824:	600c      	str	r4, [r1, #0]
    6826:	441a      	add	r2, r3
    while (u-- > 0) *dst++ = c;
    6828:	429a      	cmp	r2, r3
    682a:	d100      	bne.n	682e <Ffill+0x1a>
}
    682c:	bd10      	pop	{r4, pc}
    while (u-- > 0) *dst++ = c;
    682e:	7018      	strb	r0, [r3, #0]
    6830:	3301      	adds	r3, #1
    6832:	e7f9      	b.n	6828 <Ffill+0x14>
    6834:	200042d0 	.word	0x200042d0

00006838 <Fcmove>:

CODE(cmove) {   /* src dst u -- */
    unsigned char *dst, *src;
    unsigned int u;
    u = *psp++;
    6838:	4808      	ldr	r0, [pc, #32]	; (685c <Fcmove+0x24>)
    683a:	6803      	ldr	r3, [r0, #0]
    dst = (unsigned char *)*psp++;
    683c:	e9d3 2100 	ldrd	r2, r1, [r3]
CODE(cmove) {   /* src dst u -- */
    6840:	b510      	push	{r4, lr}
    src = (unsigned char *)*psp++;
    6842:	f103 040c 	add.w	r4, r3, #12
    6846:	689b      	ldr	r3, [r3, #8]
    6848:	6004      	str	r4, [r0, #0]
    684a:	441a      	add	r2, r3
    684c:	1ac9      	subs	r1, r1, r3
    while (u-- > 0) *dst++ = *src++;
    684e:	429a      	cmp	r2, r3
    6850:	d100      	bne.n	6854 <Fcmove+0x1c>
}
    6852:	bd10      	pop	{r4, pc}
    while (u-- > 0) *dst++ = *src++;
    6854:	7818      	ldrb	r0, [r3, #0]
    6856:	5458      	strb	r0, [r3, r1]
    6858:	3301      	adds	r3, #1
    685a:	e7f8      	b.n	684e <Fcmove+0x16>
    685c:	200042d0 	.word	0x200042d0

00006860 <Fcmoveup>:

CODE(cmoveup) {   /* src dst u -- */
    unsigned char *dst, *src;
    unsigned int u;
    u = *psp++;
    6860:	4907      	ldr	r1, [pc, #28]	; (6880 <Fcmoveup+0x20>)
    6862:	680a      	ldr	r2, [r1, #0]
CODE(cmoveup) {   /* src dst u -- */
    6864:	b510      	push	{r4, lr}
    dst = (unsigned char *)(u + *psp++);
    6866:	e9d2 3000 	ldrd	r3, r0, [r2]
    src = (unsigned char *)(u + *psp++);
    686a:	f102 040c 	add.w	r4, r2, #12
    686e:	6892      	ldr	r2, [r2, #8]
    6870:	600c      	str	r4, [r1, #0]
    while (u-- > 0) *--dst = *--src;
    6872:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    6876:	d200      	bcs.n	687a <Fcmoveup+0x1a>
}
    6878:	bd10      	pop	{r4, pc}
    while (u-- > 0) *--dst = *--src;
    687a:	5cd1      	ldrb	r1, [r2, r3]
    687c:	54c1      	strb	r1, [r0, r3]
    687e:	e7f8      	b.n	6872 <Fcmoveup+0x12>
    6880:	200042d0 	.word	0x200042d0

00006884 <Fskip>:

CODE(skip) {    /* c-addr u c -- c-addr' u' */
    unsigned char c, *src;
    unsigned int u;
    c = (unsigned char)*psp++;
    6884:	490a      	ldr	r1, [pc, #40]	; (68b0 <Fskip+0x2c>)
    6886:	680a      	ldr	r2, [r1, #0]
    u = *psp++;
    src = (unsigned char *)*psp++;
    6888:	f102 030c 	add.w	r3, r2, #12
CODE(skip) {    /* c-addr u c -- c-addr' u' */
    688c:	b5f0      	push	{r4, r5, r6, r7, lr}
    c = (unsigned char)*psp++;
    688e:	7816      	ldrb	r6, [r2, #0]
    src = (unsigned char *)*psp++;
    6890:	600b      	str	r3, [r1, #0]
    u = *psp++;
    6892:	e9d2 3001 	ldrd	r3, r0, [r2, #4]
    c = (unsigned char)*psp++;
    6896:	1d15      	adds	r5, r2, #4
    6898:	4418      	add	r0, r3
    689a:	1ac4      	subs	r4, r0, r3
    while ((u > 0) && (c == *src)) {
    689c:	b113      	cbz	r3, 68a4 <Fskip+0x20>
    689e:	7827      	ldrb	r7, [r4, #0]
    68a0:	42b7      	cmp	r7, r6
    68a2:	d003      	beq.n	68ac <Fskip+0x28>
        src++; u--;
    }
    *--psp = (unsigned int)src;
    68a4:	6094      	str	r4, [r2, #8]
    *--psp = u;
    68a6:	600d      	str	r5, [r1, #0]
    68a8:	6053      	str	r3, [r2, #4]
}
    68aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
        src++; u--;
    68ac:	3b01      	subs	r3, #1
    68ae:	e7f4      	b.n	689a <Fskip+0x16>
    68b0:	200042d0 	.word	0x200042d0

000068b4 <Fscan>:

CODE(scan) {    /* c-addr u c -- c-addr' u' */
    unsigned char c, *src;
    unsigned int u;
    c = (unsigned char)*psp++;
    68b4:	490a      	ldr	r1, [pc, #40]	; (68e0 <Fscan+0x2c>)
    68b6:	680a      	ldr	r2, [r1, #0]
    u = *psp++;
    src = (unsigned char *)*psp++;
    68b8:	f102 030c 	add.w	r3, r2, #12
CODE(scan) {    /* c-addr u c -- c-addr' u' */
    68bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    c = (unsigned char)*psp++;
    68be:	7816      	ldrb	r6, [r2, #0]
    src = (unsigned char *)*psp++;
    68c0:	600b      	str	r3, [r1, #0]
    u = *psp++;
    68c2:	e9d2 3001 	ldrd	r3, r0, [r2, #4]
    c = (unsigned char)*psp++;
    68c6:	1d15      	adds	r5, r2, #4
    68c8:	4418      	add	r0, r3
    68ca:	1ac4      	subs	r4, r0, r3
    while ((u > 0) && (c != *src)) {
    68cc:	b113      	cbz	r3, 68d4 <Fscan+0x20>
    68ce:	7827      	ldrb	r7, [r4, #0]
    68d0:	42b7      	cmp	r7, r6
    68d2:	d103      	bne.n	68dc <Fscan+0x28>
        src++; u--;
    }
    *--psp = (unsigned int)src;
    68d4:	6094      	str	r4, [r2, #8]
    *--psp = u;
    68d6:	600d      	str	r5, [r1, #0]
    68d8:	6053      	str	r3, [r2, #4]
}
    68da:	bdf0      	pop	{r4, r5, r6, r7, pc}
        src++; u--;
    68dc:	3b01      	subs	r3, #1
    68de:	e7f4      	b.n	68ca <Fscan+0x16>
    68e0:	200042d0 	.word	0x200042d0

000068e4 <Fsequal>:

CODE(sequal) {  /* c-addr1 c-addr2 u -- n */
    unsigned char *dst, *src;
    unsigned int u;
    int result = 0;
    u = *psp++;
    68e4:	4812      	ldr	r0, [pc, #72]	; (6930 <Fsequal+0x4c>)
    68e6:	6802      	ldr	r2, [r0, #0]
CODE(sequal) {  /* c-addr1 c-addr2 u -- n */
    68e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    u = *psp++;
    68ea:	4614      	mov	r4, r2
    dst = (unsigned char *)*psp++;
    68ec:	6853      	ldr	r3, [r2, #4]
    u = *psp++;
    68ee:	f854 6b08 	ldr.w	r6, [r4], #8
    src = (unsigned char *)*psp++;
    68f2:	6895      	ldr	r5, [r2, #8]
    68f4:	f102 010c 	add.w	r1, r2, #12
    68f8:	6001      	str	r1, [r0, #0]
    68fa:	1aed      	subs	r5, r5, r3
    int result = 0;
    68fc:	2100      	movs	r1, #0
    while ((u-- > 0) & (result == 0)) {
    68fe:	441e      	add	r6, r3
    6900:	42b3      	cmp	r3, r6
    6902:	eb05 0703 	add.w	r7, r5, r3
    6906:	d000      	beq.n	690a <Fsequal+0x26>
    6908:	b111      	cbz	r1, 6910 <Fsequal+0x2c>
            if (*dst > *src) result = 1;
            else if (*dst < *src) result = -1;
        }
        dst++; src++;
    }
    *--psp = (unsigned int)result;
    690a:	6004      	str	r4, [r0, #0]
    690c:	6091      	str	r1, [r2, #8]
}
    690e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (*dst != *src) {
    6910:	f893 c000 	ldrb.w	ip, [r3]
    6914:	7839      	ldrb	r1, [r7, #0]
    6916:	458c      	cmp	ip, r1
    6918:	d006      	beq.n	6928 <Fsequal+0x44>
            if (*dst > *src) result = 1;
    691a:	d807      	bhi.n	692c <Fsequal+0x48>
            else if (*dst < *src) result = -1;
    691c:	bf34      	ite	cc
    691e:	f04f 31ff 	movcc.w	r1, #4294967295	; 0xffffffff
    6922:	2100      	movcs	r1, #0
        dst++; src++;
    6924:	3301      	adds	r3, #1
    6926:	e7eb      	b.n	6900 <Fsequal+0x1c>
    6928:	2100      	movs	r1, #0
    692a:	e7fb      	b.n	6924 <Fsequal+0x40>
            if (*dst > *src) result = 1;
    692c:	2101      	movs	r1, #1
    692e:	e7f9      	b.n	6924 <Fsequal+0x40>
    6930:	200042d0 	.word	0x200042d0

00006934 <Fkeyq>:
CODE(emit) {
    putch((char)*psp++);
}

CODE(keyq) {
    *--psp = getquery(); 
    6934:	4a04      	ldr	r2, [pc, #16]	; (6948 <Fkeyq+0x14>)
    6936:	6813      	ldr	r3, [r2, #0]
    6938:	1f19      	subs	r1, r3, #4
    693a:	6011      	str	r1, [r2, #0]
    693c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6940:	f843 2c04 	str.w	r2, [r3, #-4]
}
    6944:	4770      	bx	lr
    6946:	bf00      	nop
    6948:	200042d0 	.word	0x200042d0

0000694c <Fbye>:
        printf(" %02x", *p++);
    }
}       

CODE(bye) {
    run = 0;
    694c:	4b01      	ldr	r3, [pc, #4]	; (6954 <Fbye+0x8>)
    694e:	2200      	movs	r2, #0
    6950:	701a      	strb	r2, [r3, #0]
}
    6952:	4770      	bx	lr
    6954:	2000218c 	.word	0x2000218c

00006958 <Fqbranch.part.0>:
        offset = *(unsigned int*)ip;     /* fetch inline offset */
    6958:	4a02      	ldr	r2, [pc, #8]	; (6964 <Fqbranch.part.0+0xc>)
    695a:	6813      	ldr	r3, [r2, #0]
        ip += offset;
    695c:	6819      	ldr	r1, [r3, #0]
    695e:	440b      	add	r3, r1
    6960:	6013      	str	r3, [r2, #0]
}
    6962:	4770      	bx	lr
    6964:	200019b8 	.word	0x200019b8

00006968 <Fqbranch>:
    if (*psp++ == 0) {
    6968:	4a06      	ldr	r2, [pc, #24]	; (6984 <Fqbranch+0x1c>)
    696a:	6813      	ldr	r3, [r2, #0]
    696c:	1d19      	adds	r1, r3, #4
    696e:	681b      	ldr	r3, [r3, #0]
    6970:	6011      	str	r1, [r2, #0]
    6972:	b90b      	cbnz	r3, 6978 <Fqbranch+0x10>
    6974:	4b04      	ldr	r3, [pc, #16]	; (6988 <Fqbranch+0x20>)
    6976:	4718      	bx	r3
        ip += CELL;
    6978:	4a04      	ldr	r2, [pc, #16]	; (698c <Fqbranch+0x24>)
    697a:	6813      	ldr	r3, [r2, #0]
    697c:	3304      	adds	r3, #4
    697e:	6013      	str	r3, [r2, #0]
}
    6980:	4770      	bx	lr
    6982:	bf00      	nop
    6984:	200042d0 	.word	0x200042d0
    6988:	00006959 	.word	0x00006959
    698c:	200019b8 	.word	0x200019b8

00006990 <Fxplusloop>:
    f = CIRCULARGE(rsp[0],rsp[1]);      // circular compare index:limit
    6990:	480f      	ldr	r0, [pc, #60]	; (69d0 <Fxplusloop+0x40>)
CODE(xplusloop) {   /* n -- */
    6992:	b470      	push	{r4, r5, r6}
    rsp[0] += *psp++;                   // add n to index
    6994:	4d0f      	ldr	r5, [pc, #60]	; (69d4 <Fxplusloop+0x44>)
    f = CIRCULARGE(rsp[0],rsp[1]);      // circular compare index:limit
    6996:	6802      	ldr	r2, [r0, #0]
    rsp[0] += *psp++;                   // add n to index
    6998:	682b      	ldr	r3, [r5, #0]
    f = CIRCULARGE(rsp[0],rsp[1]);      // circular compare index:limit
    699a:	e9d2 1400 	ldrd	r1, r4, [r2]
    rsp[0] += *psp++;                   // add n to index
    699e:	1d1e      	adds	r6, r3, #4
    69a0:	681b      	ldr	r3, [r3, #0]
    69a2:	602e      	str	r6, [r5, #0]
    69a4:	440b      	add	r3, r1
    69a6:	6013      	str	r3, [r2, #0]
    f = CIRCULARGE(rsp[0],rsp[1]);      // circular compare index:limit
    69a8:	1b09      	subs	r1, r1, r4
    if (CIRCULARGE(rsp[0],rsp[1]) != f) { // have we crossed the boundary?
    69aa:	1b1b      	subs	r3, r3, r4
    69ac:	43db      	mvns	r3, r3
    69ae:	43c9      	mvns	r1, r1
    69b0:	0fdb      	lsrs	r3, r3, #31
    69b2:	0fc9      	lsrs	r1, r1, #31
    69b4:	428b      	cmp	r3, r1
    69b6:	d007      	beq.n	69c8 <Fxplusloop+0x38>
        rsp += 2;                           // yes: drop index, limit
    69b8:	3208      	adds	r2, #8
    69ba:	6002      	str	r2, [r0, #0]
        ip += CELL;                         // and exit loop
    69bc:	4a06      	ldr	r2, [pc, #24]	; (69d8 <Fxplusloop+0x48>)
    69be:	6813      	ldr	r3, [r2, #0]
    69c0:	3304      	adds	r3, #4
    69c2:	6013      	str	r3, [r2, #0]
}        
    69c4:	bc70      	pop	{r4, r5, r6}
    69c6:	4770      	bx	lr
    69c8:	4b04      	ldr	r3, [pc, #16]	; (69dc <Fxplusloop+0x4c>)
    69ca:	bc70      	pop	{r4, r5, r6}
    69cc:	4718      	bx	r3
    69ce:	bf00      	nop
    69d0:	20002188 	.word	0x20002188
    69d4:	200042d0 	.word	0x200042d0
    69d8:	200019b8 	.word	0x200019b8
    69dc:	00006959 	.word	0x00006959

000069e0 <Fxloop>:
    rsp[0] += 1;                        // add 1 to index
    69e0:	4908      	ldr	r1, [pc, #32]	; (6a04 <Fxloop+0x24>)
    69e2:	680b      	ldr	r3, [r1, #0]
    69e4:	681a      	ldr	r2, [r3, #0]
    if (rsp[0] == rsp[1]) {             // have we reached the limit?
    69e6:	6858      	ldr	r0, [r3, #4]
    rsp[0] += 1;                        // add 1 to index
    69e8:	3201      	adds	r2, #1
    if (rsp[0] == rsp[1]) {             // have we reached the limit?
    69ea:	4282      	cmp	r2, r0
    rsp[0] += 1;                        // add 1 to index
    69ec:	601a      	str	r2, [r3, #0]
    if (rsp[0] == rsp[1]) {             // have we reached the limit?
    69ee:	d106      	bne.n	69fe <Fxloop+0x1e>
        ip += CELL;                         // and exit loop
    69f0:	4a05      	ldr	r2, [pc, #20]	; (6a08 <Fxloop+0x28>)
        rsp += 2;                           // yes: drop index, limit
    69f2:	3308      	adds	r3, #8
    69f4:	600b      	str	r3, [r1, #0]
        ip += CELL;                         // and exit loop
    69f6:	6813      	ldr	r3, [r2, #0]
    69f8:	3304      	adds	r3, #4
    69fa:	6013      	str	r3, [r2, #0]
}        
    69fc:	4770      	bx	lr
    69fe:	4b03      	ldr	r3, [pc, #12]	; (6a0c <Fxloop+0x2c>)
    6a00:	4718      	bx	r3
    6a02:	bf00      	nop
    6a04:	20002188 	.word	0x20002188
    6a08:	200019b8 	.word	0x200019b8
    6a0c:	00006959 	.word	0x00006959

00006a10 <getKey>:
#include "atsamdx1.h"

unsigned int getKey(void) {     // hardware-independent wrapper
    6a10:	b538      	push	{r3, r4, r5, lr}
    while (strlen(usbd_cdc_in_buffer) == 0) {
    6a12:	4c06      	ldr	r4, [pc, #24]	; (6a2c <getKey+0x1c>)
        cdcdf_acm_read((uint8_t *) usbd_cdc_in_buffer,
    6a14:	4d06      	ldr	r5, [pc, #24]	; (6a30 <getKey+0x20>)
    while (strlen(usbd_cdc_in_buffer) == 0) {
    6a16:	7820      	ldrb	r0, [r4, #0]
    6a18:	b118      	cbz	r0, 6a22 <getKey+0x12>
                       sizeof(usbd_cdc_in_buffer));
    }
    uint8_t ch_read = (uint32_t) usbd_cdc_in_buffer[0];
    usbd_cdc_in_buffer[0] = '\0';
    6a1a:	2300      	movs	r3, #0
    6a1c:	7023      	strb	r3, [r4, #0]
    usbd_cdc_in_buffer[1] = '\0';
    6a1e:	7063      	strb	r3, [r4, #1]
    return ch_read;
}
    6a20:	bd38      	pop	{r3, r4, r5, pc}
        cdcdf_acm_read((uint8_t *) usbd_cdc_in_buffer,
    6a22:	2110      	movs	r1, #16
    6a24:	4620      	mov	r0, r4
    6a26:	47a8      	blx	r5
    6a28:	e7f5      	b.n	6a16 <getKey+0x6>
    6a2a:	bf00      	nop
    6a2c:	20001998 	.word	0x20001998
    6a30:	000044f1 	.word	0x000044f1

00006a34 <Fkey>:
    *--psp = (unsigned int)getch();
    6a34:	4b04      	ldr	r3, [pc, #16]	; (6a48 <Fkey+0x14>)
CODE(key) {
    6a36:	b510      	push	{r4, lr}
    *--psp = (unsigned int)getch();
    6a38:	681c      	ldr	r4, [r3, #0]
    6a3a:	1f22      	subs	r2, r4, #4
    6a3c:	601a      	str	r2, [r3, #0]
    6a3e:	4b03      	ldr	r3, [pc, #12]	; (6a4c <Fkey+0x18>)
    6a40:	4798      	blx	r3
    6a42:	f844 0c04 	str.w	r0, [r4, #-4]
}
    6a46:	bd10      	pop	{r4, pc}
    6a48:	200042d0 	.word	0x200042d0
    6a4c:	00006a11 	.word	0x00006a11

00006a50 <init_cutter>:

char instring[BUFFLEN];
char tempstring[BUFFLEN];

void init_cutter(void) {
    strcpy(instring, print_string);
    6a50:	4901      	ldr	r1, [pc, #4]	; (6a58 <init_cutter+0x8>)
    6a52:	4802      	ldr	r0, [pc, #8]	; (6a5c <init_cutter+0xc>)
    6a54:	4b02      	ldr	r3, [pc, #8]	; (6a60 <init_cutter+0x10>)
    6a56:	4718      	bx	r3
    6a58:	20004210 	.word	0x20004210
    6a5c:	200020e4 	.word	0x200020e4
    6a60:	00007215 	.word	0x00007215

00006a64 <str_cut>:
/*
 *      Remove given section from string. Negative len means remove
 *      everything up to the end.
 */

int str_cut(char *str, int begin, int len) {
    6a64:	b570      	push	{r4, r5, r6, lr}
    int l = strlen(str);
    6a66:	4b0a      	ldr	r3, [pc, #40]	; (6a90 <str_cut+0x2c>)
int str_cut(char *str, int begin, int len) {
    6a68:	4614      	mov	r4, r2
    6a6a:	460d      	mov	r5, r1
    6a6c:	4606      	mov	r6, r0
    int l = strlen(str);
    6a6e:	4798      	blx	r3

    if (len < 0)
    6a70:	2c00      	cmp	r4, #0
        len = l - begin;
    6a72:	bfb8      	it	lt
    6a74:	1b44      	sublt	r4, r0, r5
    if (begin + len > l)
    6a76:	1963      	adds	r3, r4, r5
    6a78:	4283      	cmp	r3, r0
        len = l - begin;
    6a7a:	bfc8      	it	gt
    6a7c:	1b44      	subgt	r4, r0, r5
    memmove(str + begin, str + begin + len, l - len + 1);
    6a7e:	1b02      	subs	r2, r0, r4
    6a80:	1961      	adds	r1, r4, r5
    6a82:	3201      	adds	r2, #1
    6a84:	4431      	add	r1, r6
    6a86:	1970      	adds	r0, r6, r5
    6a88:	4b02      	ldr	r3, [pc, #8]	; (6a94 <str_cut+0x30>)
    6a8a:	4798      	blx	r3

    return len;
}
    6a8c:	4620      	mov	r0, r4
    6a8e:	bd70      	pop	{r4, r5, r6, pc}
    6a90:	00007225 	.word	0x00007225
    6a94:	00007193 	.word	0x00007193

00006a98 <slower>:

void slower(void) {
    6a98:	b082      	sub	sp, #8
    for (volatile int i = 1295; i > 0; i--) {
    6a9a:	f240 530f 	movw	r3, #1295	; 0x50f
    6a9e:	9301      	str	r3, [sp, #4]
    6aa0:	9b01      	ldr	r3, [sp, #4]
    6aa2:	2b00      	cmp	r3, #0
    6aa4:	dc01      	bgt.n	6aaa <slower+0x12>
    }
}
    6aa6:	b002      	add	sp, #8
    6aa8:	4770      	bx	lr
    for (volatile int i = 1295; i > 0; i--) {
    6aaa:	9b01      	ldr	r3, [sp, #4]
    6aac:	3b01      	subs	r3, #1
    6aae:	e7f6      	b.n	6a9e <slower+0x6>

00006ab0 <printf_cutter>:

void printf_cutter(void) {
    6ab0:	b510      	push	{r4, lr}
    cdcdf_acm_write((uint8_t *) tempstring, strlen(tempstring));
    6ab2:	4c06      	ldr	r4, [pc, #24]	; (6acc <printf_cutter+0x1c>)
    6ab4:	4b06      	ldr	r3, [pc, #24]	; (6ad0 <printf_cutter+0x20>)
    6ab6:	4620      	mov	r0, r4
    6ab8:	4798      	blx	r3
    6aba:	4b06      	ldr	r3, [pc, #24]	; (6ad4 <printf_cutter+0x24>)
    6abc:	4601      	mov	r1, r0
    6abe:	4620      	mov	r0, r4
    6ac0:	4798      	blx	r3
    slower();                   // no ringbuffer - kludge
    6ac2:	4b05      	ldr	r3, [pc, #20]	; (6ad8 <printf_cutter+0x28>)
}
    6ac4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    slower();                   // no ringbuffer - kludge
    6ac8:	4718      	bx	r3
    6aca:	bf00      	nop
    6acc:	20004250 	.word	0x20004250
    6ad0:	00007225 	.word	0x00007225
    6ad4:	0000451d 	.word	0x0000451d
    6ad8:	00006a99 	.word	0x00006a99

00006adc <slicer>:

void do_output(void) {
    printf_cutter();
}

void slicer(char *instring) {
    6adc:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    tempstring[0] = '\0';
    6ae0:	4c20      	ldr	r4, [pc, #128]	; (6b64 <slicer+0x88>)

    int origin = 0;
    int chopln = CHOP_LN;       // chop length
    int to_end = -1;

    int l = (strlen(instring) / chopln);
    6ae2:	f8df a090 	ldr.w	sl, [pc, #144]	; 6b74 <slicer+0x98>

    for (int index = 1; index < (l + 1); index++) {
        int j = chopln * index;
        int k = j - chopln;
        strcpy(tempstring, instring);
        str_cut(tempstring, j, to_end);
    6ae6:	f8df 8084 	ldr.w	r8, [pc, #132]	; 6b6c <slicer+0x90>
    tempstring[0] = '\0';
    6aea:	2300      	movs	r3, #0
void slicer(char *instring) {
    6aec:	4607      	mov	r7, r0
    tempstring[0] = '\0';
    6aee:	7023      	strb	r3, [r4, #0]
    tempstring[1] = '\0';
    6af0:	7063      	strb	r3, [r4, #1]
    int l = (strlen(instring) / chopln);
    6af2:	47d0      	blx	sl
    for (int index = 1; index < (l + 1); index++) {
    6af4:	2501      	movs	r5, #1
    int l = (strlen(instring) / chopln);
    6af6:	2605      	movs	r6, #5
    6af8:	fbb0 f6f6 	udiv	r6, r0, r6
    for (int index = 1; index < (l + 1); index++) {
    6afc:	42b5      	cmp	r5, r6
    6afe:	dd17      	ble.n	6b30 <slicer+0x54>
            str_cut(tempstring, origin, k);
        }
        do_output();
    }

    if ((strlen(instring)) > ((strlen(instring) / chopln) * chopln)) {
    6b00:	4638      	mov	r0, r7
    6b02:	47d0      	blx	sl
    6b04:	2305      	movs	r3, #5
    6b06:	fbb0 f3f3 	udiv	r3, r0, r3
    6b0a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    6b0e:	4298      	cmp	r0, r3
    6b10:	d925      	bls.n	6b5e <slicer+0x82>
        strcpy(tempstring, instring);
    6b12:	4639      	mov	r1, r7
    6b14:	4b14      	ldr	r3, [pc, #80]	; (6b68 <slicer+0x8c>)
    6b16:	4813      	ldr	r0, [pc, #76]	; (6b64 <slicer+0x88>)
    6b18:	4798      	blx	r3
        int c = l * chopln;
        str_cut(tempstring, 0, c);
    6b1a:	eb06 0286 	add.w	r2, r6, r6, lsl #2
    6b1e:	2100      	movs	r1, #0
    6b20:	4b12      	ldr	r3, [pc, #72]	; (6b6c <slicer+0x90>)
    6b22:	4810      	ldr	r0, [pc, #64]	; (6b64 <slicer+0x88>)
    6b24:	4798      	blx	r3
    printf_cutter();
    6b26:	4b12      	ldr	r3, [pc, #72]	; (6b70 <slicer+0x94>)
        do_output();
    }

}
    6b28:	b001      	add	sp, #4
    6b2a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    printf_cutter();
    6b2e:	4718      	bx	r3
    6b30:	eb05 0985 	add.w	r9, r5, r5, lsl #2
        strcpy(tempstring, instring);
    6b34:	4639      	mov	r1, r7
    6b36:	4b0c      	ldr	r3, [pc, #48]	; (6b68 <slicer+0x8c>)
    6b38:	4620      	mov	r0, r4
    6b3a:	4798      	blx	r3
        str_cut(tempstring, j, to_end);
    6b3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6b40:	4649      	mov	r1, r9
    6b42:	4620      	mov	r0, r4
    6b44:	47c0      	blx	r8
        if (index > 1) {
    6b46:	2d01      	cmp	r5, #1
    6b48:	f1a9 0b05 	sub.w	fp, r9, #5
    6b4c:	d003      	beq.n	6b56 <slicer+0x7a>
            str_cut(tempstring, origin, k);
    6b4e:	465a      	mov	r2, fp
    6b50:	2100      	movs	r1, #0
    6b52:	4620      	mov	r0, r4
    6b54:	47c0      	blx	r8
    printf_cutter();
    6b56:	4b06      	ldr	r3, [pc, #24]	; (6b70 <slicer+0x94>)
    6b58:	4798      	blx	r3
    for (int index = 1; index < (l + 1); index++) {
    6b5a:	3501      	adds	r5, #1
    6b5c:	e7ce      	b.n	6afc <slicer+0x20>
}
    6b5e:	b001      	add	sp, #4
    6b60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6b64:	20004250 	.word	0x20004250
    6b68:	00007215 	.word	0x00007215
    6b6c:	00006a65 	.word	0x00006a65
    6b70:	00006ab1 	.word	0x00006ab1
    6b74:	00007225 	.word	0x00007225

00006b78 <cut_main>:

void cut_main(void) {
    6b78:	b510      	push	{r4, lr}
    init_cutter();
    6b7a:	4b03      	ldr	r3, [pc, #12]	; (6b88 <cut_main+0x10>)
    6b7c:	4798      	blx	r3
    slicer(instring);
    6b7e:	4803      	ldr	r0, [pc, #12]	; (6b8c <cut_main+0x14>)
    6b80:	4b03      	ldr	r3, [pc, #12]	; (6b90 <cut_main+0x18>)
}
    6b82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    slicer(instring);
    6b86:	4718      	bx	r3
    6b88:	00006a51 	.word	0x00006a51
    6b8c:	200020e4 	.word	0x200020e4
    6b90:	00006add 	.word	0x00006add

00006b94 <Fdothh>:
CODE(dothh) {        /* temporary definition for testing */
    6b94:	b570      	push	{r4, r5, r6, lr}
    printf(" %2x", *psp++);
    6b96:	4d0b      	ldr	r5, [pc, #44]	; (6bc4 <Fdothh+0x30>)
    6b98:	4c0b      	ldr	r4, [pc, #44]	; (6bc8 <Fdothh+0x34>)
    6b9a:	4a0c      	ldr	r2, [pc, #48]	; (6bcc <Fdothh+0x38>)
    6b9c:	2300      	movs	r3, #0
    6b9e:	602b      	str	r3, [r5, #0]
    6ba0:	4b0b      	ldr	r3, [pc, #44]	; (6bd0 <Fdothh+0x3c>)
    6ba2:	7023      	strb	r3, [r4, #0]
    6ba4:	6813      	ldr	r3, [r2, #0]
    6ba6:	1d19      	adds	r1, r3, #4
    6ba8:	6011      	str	r1, [r2, #0]
    6baa:	4620      	mov	r0, r4
    6bac:	681a      	ldr	r2, [r3, #0]
    6bae:	4909      	ldr	r1, [pc, #36]	; (6bd4 <Fdothh+0x40>)
    6bb0:	4b09      	ldr	r3, [pc, #36]	; (6bd8 <Fdothh+0x44>)
    6bb2:	4798      	blx	r3
    6bb4:	4620      	mov	r0, r4
    6bb6:	4b09      	ldr	r3, [pc, #36]	; (6bdc <Fdothh+0x48>)
    6bb8:	4798      	blx	r3

// primary api is chopped_acm_write(print_string) from caller

void chopped_acm_write(char *str) {
    cut_main();
    6bba:	4b09      	ldr	r3, [pc, #36]	; (6be0 <Fdothh+0x4c>)
    6bbc:	6028      	str	r0, [r5, #0]
}
    6bbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    6bc2:	4718      	bx	r3
    6bc4:	2000198c 	.word	0x2000198c
    6bc8:	20004210 	.word	0x20004210
    6bcc:	200042d0 	.word	0x200042d0
    6bd0:	00007ab4 	.word	0x00007ab4
    6bd4:	00008cf2 	.word	0x00008cf2
    6bd8:	000071d5 	.word	0x000071d5
    6bdc:	00007225 	.word	0x00007225
    6be0:	00006b79 	.word	0x00006b79

00006be4 <Fdothhhh>:
CODE(dothhhh) {        /* temporary definition for testing */
    6be4:	b570      	push	{r4, r5, r6, lr}
    printf(" %8x", *psp++);
    6be6:	4d0b      	ldr	r5, [pc, #44]	; (6c14 <Fdothhhh+0x30>)
    6be8:	4c0b      	ldr	r4, [pc, #44]	; (6c18 <Fdothhhh+0x34>)
    6bea:	4a0c      	ldr	r2, [pc, #48]	; (6c1c <Fdothhhh+0x38>)
    6bec:	2300      	movs	r3, #0
    6bee:	602b      	str	r3, [r5, #0]
    6bf0:	4b0b      	ldr	r3, [pc, #44]	; (6c20 <Fdothhhh+0x3c>)
    6bf2:	7023      	strb	r3, [r4, #0]
    6bf4:	6813      	ldr	r3, [r2, #0]
    6bf6:	1d19      	adds	r1, r3, #4
    6bf8:	6011      	str	r1, [r2, #0]
    6bfa:	4620      	mov	r0, r4
    6bfc:	681a      	ldr	r2, [r3, #0]
    6bfe:	4909      	ldr	r1, [pc, #36]	; (6c24 <Fdothhhh+0x40>)
    6c00:	4b09      	ldr	r3, [pc, #36]	; (6c28 <Fdothhhh+0x44>)
    6c02:	4798      	blx	r3
    6c04:	4620      	mov	r0, r4
    6c06:	4b09      	ldr	r3, [pc, #36]	; (6c2c <Fdothhhh+0x48>)
    6c08:	4798      	blx	r3
    6c0a:	4b09      	ldr	r3, [pc, #36]	; (6c30 <Fdothhhh+0x4c>)
    6c0c:	6028      	str	r0, [r5, #0]
}
    6c0e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    6c12:	4718      	bx	r3
    6c14:	2000198c 	.word	0x2000198c
    6c18:	20004210 	.word	0x20004210
    6c1c:	200042d0 	.word	0x200042d0
    6c20:	00007ab4 	.word	0x00007ab4
    6c24:	00008cf7 	.word	0x00008cf7
    6c28:	000071d5 	.word	0x000071d5
    6c2c:	00007225 	.word	0x00007225
    6c30:	00006b79 	.word	0x00006b79

00006c34 <Fdots>:
CODE(dots) {    /* print stack, for testing */
    6c34:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    printf("\n%8x:", (unsigned int)p);
    6c38:	4c19      	ldr	r4, [pc, #100]	; (6ca0 <Fdots+0x6c>)
    6c3a:	4e1a      	ldr	r6, [pc, #104]	; (6ca4 <Fdots+0x70>)
    6c3c:	4d1a      	ldr	r5, [pc, #104]	; (6ca8 <Fdots+0x74>)
    6c3e:	4a1b      	ldr	r2, [pc, #108]	; (6cac <Fdots+0x78>)
    6c40:	491b      	ldr	r1, [pc, #108]	; (6cb0 <Fdots+0x7c>)
    6c42:	f8df a078 	ldr.w	sl, [pc, #120]	; 6cbc <Fdots+0x88>
    6c46:	4f1b      	ldr	r7, [pc, #108]	; (6cb4 <Fdots+0x80>)
    6c48:	f8df 8074 	ldr.w	r8, [pc, #116]	; 6cc0 <Fdots+0x8c>
    p = &pstack[PSTACKSIZE-2];      /* deepest element on stack */
    6c4c:	f8df 905c 	ldr.w	r9, [pc, #92]	; 6cac <Fdots+0x78>
    while (p >= psp) { printf(" %8x", *p--); }
    6c50:	f8df b070 	ldr.w	fp, [pc, #112]	; 6cc4 <Fdots+0x90>
    printf("\n%8x:", (unsigned int)p);
    6c54:	2300      	movs	r3, #0
    6c56:	b2f6      	uxtb	r6, r6
    6c58:	4620      	mov	r0, r4
    6c5a:	602b      	str	r3, [r5, #0]
    6c5c:	7026      	strb	r6, [r4, #0]
    6c5e:	47d0      	blx	sl
    6c60:	4620      	mov	r0, r4
    6c62:	47b8      	blx	r7
    6c64:	6028      	str	r0, [r5, #0]
    6c66:	47c0      	blx	r8
    while (p >= psp) { printf(" %8x", *p--); }
    6c68:	4b13      	ldr	r3, [pc, #76]	; (6cb8 <Fdots+0x84>)
    6c6a:	f8cd a000 	str.w	sl, [sp]
    6c6e:	46a2      	mov	sl, r4
    6c70:	f8db 2000 	ldr.w	r2, [fp]
    6c74:	454a      	cmp	r2, r9
    6c76:	d902      	bls.n	6c7e <Fdots+0x4a>
}
    6c78:	b003      	add	sp, #12
    6c7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while (p >= psp) { printf(" %8x", *p--); }
    6c7e:	2200      	movs	r2, #0
    6c80:	4619      	mov	r1, r3
    6c82:	602a      	str	r2, [r5, #0]
    6c84:	9301      	str	r3, [sp, #4]
    6c86:	f859 2904 	ldr.w	r2, [r9], #-4
    6c8a:	9b00      	ldr	r3, [sp, #0]
    6c8c:	7026      	strb	r6, [r4, #0]
    6c8e:	4650      	mov	r0, sl
    6c90:	4798      	blx	r3
    6c92:	4650      	mov	r0, sl
    6c94:	47b8      	blx	r7
    6c96:	6028      	str	r0, [r5, #0]
    6c98:	47c0      	blx	r8
    6c9a:	9b01      	ldr	r3, [sp, #4]
    6c9c:	e7e8      	b.n	6c70 <Fdots+0x3c>
    6c9e:	bf00      	nop
    6ca0:	20004210 	.word	0x20004210
    6ca4:	00007ab4 	.word	0x00007ab4
    6ca8:	2000198c 	.word	0x2000198c
    6cac:	20002034 	.word	0x20002034
    6cb0:	00008cfc 	.word	0x00008cfc
    6cb4:	00007225 	.word	0x00007225
    6cb8:	00008cf7 	.word	0x00008cf7
    6cbc:	000071d5 	.word	0x000071d5
    6cc0:	00006b79 	.word	0x00006b79
    6cc4:	200042d0 	.word	0x200042d0

00006cc8 <Fdump>:
CODE(dump) {   /* adr n -- */
    6cc8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    n = *psp++;
    6ccc:	491b      	ldr	r1, [pc, #108]	; (6d3c <Fdump+0x74>)
        if ((i&0xf)==0) printf("\n%8x:", (unsigned int)p);
    6cce:	4f1c      	ldr	r7, [pc, #112]	; (6d40 <Fdump+0x78>)
    n = *psp++;
    6cd0:	680a      	ldr	r2, [r1, #0]
    6cd2:	4e1c      	ldr	r6, [pc, #112]	; (6d44 <Fdump+0x7c>)
    6cd4:	4613      	mov	r3, r2
    for (i=0; i<n; i++) {
    6cd6:	2400      	movs	r4, #0
    n = *psp++;
    6cd8:	f853 0b08 	ldr.w	r0, [r3], #8
    p = (unsigned char *)*psp++;
    6cdc:	600b      	str	r3, [r1, #0]
    6cde:	6853      	ldr	r3, [r2, #4]
    n = *psp++;
    6ce0:	9000      	str	r0, [sp, #0]
        if ((i&0xf)==0) printf("\n%8x:", (unsigned int)p);
    6ce2:	b2ff      	uxtb	r7, r7
    for (i=0; i<n; i++) {
    6ce4:	9a00      	ldr	r2, [sp, #0]
    6ce6:	4294      	cmp	r4, r2
    6ce8:	eb03 0804 	add.w	r8, r3, r4
    6cec:	d102      	bne.n	6cf4 <Fdump+0x2c>
}       
    6cee:	b003      	add	sp, #12
    6cf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((i&0xf)==0) printf("\n%8x:", (unsigned int)p);
    6cf4:	4d14      	ldr	r5, [pc, #80]	; (6d48 <Fdump+0x80>)
    6cf6:	4915      	ldr	r1, [pc, #84]	; (6d4c <Fdump+0x84>)
    6cf8:	f8df b058 	ldr.w	fp, [pc, #88]	; 6d54 <Fdump+0x8c>
    6cfc:	9301      	str	r3, [sp, #4]
    6cfe:	f014 020f 	ands.w	r2, r4, #15
    6d02:	bf08      	it	eq
    6d04:	6032      	streq	r2, [r6, #0]
    6d06:	4628      	mov	r0, r5
    6d08:	4642      	mov	r2, r8
    6d0a:	f8df a04c 	ldr.w	sl, [pc, #76]	; 6d58 <Fdump+0x90>
    6d0e:	702f      	strb	r7, [r5, #0]
    6d10:	47d8      	blx	fp
    6d12:	4628      	mov	r0, r5
    6d14:	47d0      	blx	sl
    6d16:	f8df 9044 	ldr.w	r9, [pc, #68]	; 6d5c <Fdump+0x94>
    6d1a:	6030      	str	r0, [r6, #0]
    6d1c:	47c8      	blx	r9
        printf(" %02x", *p++);
    6d1e:	2200      	movs	r2, #0
    6d20:	6032      	str	r2, [r6, #0]
    6d22:	702f      	strb	r7, [r5, #0]
    6d24:	f898 2000 	ldrb.w	r2, [r8]
    6d28:	4909      	ldr	r1, [pc, #36]	; (6d50 <Fdump+0x88>)
    6d2a:	4628      	mov	r0, r5
    6d2c:	47d8      	blx	fp
    6d2e:	4628      	mov	r0, r5
    6d30:	47d0      	blx	sl
    for (i=0; i<n; i++) {
    6d32:	3401      	adds	r4, #1
        printf(" %02x", *p++);
    6d34:	6030      	str	r0, [r6, #0]
    6d36:	47c8      	blx	r9
    for (i=0; i<n; i++) {
    6d38:	9b01      	ldr	r3, [sp, #4]
    6d3a:	e7d3      	b.n	6ce4 <Fdump+0x1c>
    6d3c:	200042d0 	.word	0x200042d0
    6d40:	00007ab4 	.word	0x00007ab4
    6d44:	2000198c 	.word	0x2000198c
    6d48:	20004210 	.word	0x20004210
    6d4c:	00008cfc 	.word	0x00008cfc
    6d50:	00008d02 	.word	0x00008d02
    6d54:	000071d5 	.word	0x000071d5
    6d58:	00007225 	.word	0x00007225
    6d5c:	00006b79 	.word	0x00006b79

00006d60 <putch>:

void putch(char c) {
    char *p;
    p = &c;
    c = *p + 0;
    print_string[0] = c;
    6d60:	4b02      	ldr	r3, [pc, #8]	; (6d6c <putch+0xc>)
    print_string[1] = '\0';
    6d62:	2200      	movs	r2, #0
    print_string[0] = c;
    6d64:	7018      	strb	r0, [r3, #0]
    print_string[1] = '\0';
    6d66:	705a      	strb	r2, [r3, #1]
    6d68:	4b01      	ldr	r3, [pc, #4]	; (6d70 <putch+0x10>)
    6d6a:	4718      	bx	r3
    6d6c:	20004210 	.word	0x20004210
    6d70:	00006b79 	.word	0x00006b79

00006d74 <Femit>:
    putch((char)*psp++);
    6d74:	4a03      	ldr	r2, [pc, #12]	; (6d84 <Femit+0x10>)
    6d76:	6813      	ldr	r3, [r2, #0]
    6d78:	1d19      	adds	r1, r3, #4
    6d7a:	7818      	ldrb	r0, [r3, #0]
    6d7c:	4b02      	ldr	r3, [pc, #8]	; (6d88 <Femit+0x14>)
    6d7e:	6011      	str	r1, [r2, #0]
    6d80:	4718      	bx	r3
    6d82:	bf00      	nop
    6d84:	200042d0 	.word	0x200042d0
    6d88:	00006d61 	.word	0x00006d61

00006d8c <interpreter>:
/*
 * INNER INTERPRETER
 */

void interpreter(void)
{
    6d8c:	b538      	push	{r3, r4, r5, lr}
    void (*xt)(void *);     /* pointer to code function */
    void *w, *x;            /* generic pointers */
    
    psp = &pstack[PSTACKSIZE-1];
    6d8e:	4b0b      	ldr	r3, [pc, #44]	; (6dbc <interpreter+0x30>)
    6d90:	4a0b      	ldr	r2, [pc, #44]	; (6dc0 <interpreter+0x34>)
    6d92:	601a      	str	r2, [r3, #0]
    rsp = &rstack[RSTACKSIZE-1];
    6d94:	4b0b      	ldr	r3, [pc, #44]	; (6dc4 <interpreter+0x38>)
    6d96:	4a0c      	ldr	r2, [pc, #48]	; (6dc8 <interpreter+0x3c>)
    ip = &Tcold;
    ip += CELL;
    6d98:	4c0c      	ldr	r4, [pc, #48]	; (6dcc <interpreter+0x40>)
    run = 1;                /* set to zero to terminate interpreter */
    6d9a:	4d0d      	ldr	r5, [pc, #52]	; (6dd0 <interpreter+0x44>)
    rsp = &rstack[RSTACKSIZE-1];
    6d9c:	601a      	str	r2, [r3, #0]
    ip += CELL;
    6d9e:	4b0d      	ldr	r3, [pc, #52]	; (6dd4 <interpreter+0x48>)
    6da0:	6023      	str	r3, [r4, #0]
    run = 1;                /* set to zero to terminate interpreter */
    6da2:	2201      	movs	r2, #1
    6da4:	702a      	strb	r2, [r5, #0]
    while (run) {
    6da6:	782b      	ldrb	r3, [r5, #0]
    6da8:	b903      	cbnz	r3, 6dac <interpreter+0x20>
        x = *(void **)w;        /* fetch function adrs from word def */
        xt = (void (*)())x;     /* too much casting! */
        w += CELL;
        (*xt)(w);               /* call function w/adrs of word def */
    }        
}
    6daa:	bd38      	pop	{r3, r4, r5, pc}
        w = *(void **)ip;       /* fetch word address from thread */
    6dac:	6823      	ldr	r3, [r4, #0]
    6dae:	f853 0b04 	ldr.w	r0, [r3], #4
        ip += CELL;
    6db2:	6023      	str	r3, [r4, #0]
        (*xt)(w);               /* call function w/adrs of word def */
    6db4:	6803      	ldr	r3, [r0, #0]
    6db6:	3004      	adds	r0, #4
    6db8:	4798      	blx	r3
    6dba:	e7f4      	b.n	6da6 <interpreter+0x1a>
    6dbc:	200042d0 	.word	0x200042d0
    6dc0:	20002038 	.word	0x20002038
    6dc4:	20002188 	.word	0x20002188
    6dc8:	20001eb8 	.word	0x20001eb8
    6dcc:	200019b8 	.word	0x200019b8
    6dd0:	2000218c 	.word	0x2000218c
    6dd4:	2000006c 	.word	0x2000006c

00006dd8 <camelforth>:
 ******
 */

void interpreter(void);         /* forward reference */

void camelforth(void) {
    6dd8:	b507      	push	{r0, r1, r2, lr}
    for (volatile int i = 9080706; i > 0; i--) {
    6dda:	4b08      	ldr	r3, [pc, #32]	; (6dfc <camelforth+0x24>)
    6ddc:	9301      	str	r3, [sp, #4]
    6dde:	9b01      	ldr	r3, [sp, #4]
    6de0:	2b00      	cmp	r3, #0
    6de2:	dc08      	bgt.n	6df6 <camelforth+0x1e>
    }
    strcpy(print_string, "\n\ncamelforth()\n\n");
    6de4:	4906      	ldr	r1, [pc, #24]	; (6e00 <camelforth+0x28>)
    6de6:	4b07      	ldr	r3, [pc, #28]	; (6e04 <camelforth+0x2c>)
    6de8:	4807      	ldr	r0, [pc, #28]	; (6e08 <camelforth+0x30>)
    chopped_acm_write(print_string);
    while (1) {                 /* loop in case interpreter() ever terminates */
        interpreter();
    6dea:	4c08      	ldr	r4, [pc, #32]	; (6e0c <camelforth+0x34>)
    strcpy(print_string, "\n\ncamelforth()\n\n");
    6dec:	4798      	blx	r3
    6dee:	4b08      	ldr	r3, [pc, #32]	; (6e10 <camelforth+0x38>)
    6df0:	4798      	blx	r3
        interpreter();
    6df2:	47a0      	blx	r4
    6df4:	e7fd      	b.n	6df2 <camelforth+0x1a>
    for (volatile int i = 9080706; i > 0; i--) {
    6df6:	9b01      	ldr	r3, [sp, #4]
    6df8:	3b01      	subs	r3, #1
    6dfa:	e7ef      	b.n	6ddc <camelforth+0x4>
    6dfc:	008a8f82 	.word	0x008a8f82
    6e00:	00008d0c 	.word	0x00008d0c
    6e04:	00007215 	.word	0x00007215
    6e08:	20004210 	.word	0x20004210
    6e0c:	00006d8d 	.word	0x00006d8d
    6e10:	00006b79 	.word	0x00006b79

00006e14 <main_cf>:
void delay_some(void) {
    for (volatile int i = 230001; i > 0; i--) {
    }
}

void main_cf(void) {
    6e14:	b508      	push	{r3, lr}
    /* Initializes MCU, drivers and middleware */
    atmel_start_init();
    6e16:	4b02      	ldr	r3, [pc, #8]	; (6e20 <main_cf+0xc>)
    6e18:	4798      	blx	r3

    /* Replace with your application code */
    cdcd_acm_example();
    6e1a:	4b02      	ldr	r3, [pc, #8]	; (6e24 <main_cf+0x10>)
    6e1c:	4798      	blx	r3
    6e1e:	e7fe      	b.n	6e1e <main_cf+0xa>
    6e20:	00005c69 	.word	0x00005c69
    6e24:	000054d1 	.word	0x000054d1

00006e28 <main>:
    while (1) {
    }
}

int main(void) {
    6e28:	b508      	push	{r3, lr}
    main_cf();
    6e2a:	4b01      	ldr	r3, [pc, #4]	; (6e30 <main+0x8>)
    6e2c:	4798      	blx	r3
    6e2e:	bf00      	nop
    6e30:	00006e15 	.word	0x00006e15

00006e34 <__aeabi_uldivmod>:
    6e34:	b953      	cbnz	r3, 6e4c <__aeabi_uldivmod+0x18>
    6e36:	b94a      	cbnz	r2, 6e4c <__aeabi_uldivmod+0x18>
    6e38:	2900      	cmp	r1, #0
    6e3a:	bf08      	it	eq
    6e3c:	2800      	cmpeq	r0, #0
    6e3e:	bf1c      	itt	ne
    6e40:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    6e44:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    6e48:	f000 b972 	b.w	7130 <__aeabi_idiv0>
    6e4c:	f1ad 0c08 	sub.w	ip, sp, #8
    6e50:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    6e54:	f000 f806 	bl	6e64 <__udivmoddi4>
    6e58:	f8dd e004 	ldr.w	lr, [sp, #4]
    6e5c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    6e60:	b004      	add	sp, #16
    6e62:	4770      	bx	lr

00006e64 <__udivmoddi4>:
    6e64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6e68:	9e08      	ldr	r6, [sp, #32]
    6e6a:	4604      	mov	r4, r0
    6e6c:	4688      	mov	r8, r1
    6e6e:	2b00      	cmp	r3, #0
    6e70:	d14b      	bne.n	6f0a <__udivmoddi4+0xa6>
    6e72:	428a      	cmp	r2, r1
    6e74:	4615      	mov	r5, r2
    6e76:	d967      	bls.n	6f48 <__udivmoddi4+0xe4>
    6e78:	fab2 f282 	clz	r2, r2
    6e7c:	b14a      	cbz	r2, 6e92 <__udivmoddi4+0x2e>
    6e7e:	f1c2 0720 	rsb	r7, r2, #32
    6e82:	fa01 f302 	lsl.w	r3, r1, r2
    6e86:	fa20 f707 	lsr.w	r7, r0, r7
    6e8a:	4095      	lsls	r5, r2
    6e8c:	ea47 0803 	orr.w	r8, r7, r3
    6e90:	4094      	lsls	r4, r2
    6e92:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    6e96:	0c23      	lsrs	r3, r4, #16
    6e98:	fbb8 f7fe 	udiv	r7, r8, lr
    6e9c:	fa1f fc85 	uxth.w	ip, r5
    6ea0:	fb0e 8817 	mls	r8, lr, r7, r8
    6ea4:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
    6ea8:	fb07 f10c 	mul.w	r1, r7, ip
    6eac:	4299      	cmp	r1, r3
    6eae:	d909      	bls.n	6ec4 <__udivmoddi4+0x60>
    6eb0:	18eb      	adds	r3, r5, r3
    6eb2:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
    6eb6:	f080 811b 	bcs.w	70f0 <__udivmoddi4+0x28c>
    6eba:	4299      	cmp	r1, r3
    6ebc:	f240 8118 	bls.w	70f0 <__udivmoddi4+0x28c>
    6ec0:	3f02      	subs	r7, #2
    6ec2:	442b      	add	r3, r5
    6ec4:	1a5b      	subs	r3, r3, r1
    6ec6:	b2a4      	uxth	r4, r4
    6ec8:	fbb3 f0fe 	udiv	r0, r3, lr
    6ecc:	fb0e 3310 	mls	r3, lr, r0, r3
    6ed0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    6ed4:	fb00 fc0c 	mul.w	ip, r0, ip
    6ed8:	45a4      	cmp	ip, r4
    6eda:	d909      	bls.n	6ef0 <__udivmoddi4+0x8c>
    6edc:	192c      	adds	r4, r5, r4
    6ede:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    6ee2:	f080 8107 	bcs.w	70f4 <__udivmoddi4+0x290>
    6ee6:	45a4      	cmp	ip, r4
    6ee8:	f240 8104 	bls.w	70f4 <__udivmoddi4+0x290>
    6eec:	3802      	subs	r0, #2
    6eee:	442c      	add	r4, r5
    6ef0:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
    6ef4:	eba4 040c 	sub.w	r4, r4, ip
    6ef8:	2700      	movs	r7, #0
    6efa:	b11e      	cbz	r6, 6f04 <__udivmoddi4+0xa0>
    6efc:	40d4      	lsrs	r4, r2
    6efe:	2300      	movs	r3, #0
    6f00:	e9c6 4300 	strd	r4, r3, [r6]
    6f04:	4639      	mov	r1, r7
    6f06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6f0a:	428b      	cmp	r3, r1
    6f0c:	d909      	bls.n	6f22 <__udivmoddi4+0xbe>
    6f0e:	2e00      	cmp	r6, #0
    6f10:	f000 80eb 	beq.w	70ea <__udivmoddi4+0x286>
    6f14:	2700      	movs	r7, #0
    6f16:	e9c6 0100 	strd	r0, r1, [r6]
    6f1a:	4638      	mov	r0, r7
    6f1c:	4639      	mov	r1, r7
    6f1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6f22:	fab3 f783 	clz	r7, r3
    6f26:	2f00      	cmp	r7, #0
    6f28:	d147      	bne.n	6fba <__udivmoddi4+0x156>
    6f2a:	428b      	cmp	r3, r1
    6f2c:	d302      	bcc.n	6f34 <__udivmoddi4+0xd0>
    6f2e:	4282      	cmp	r2, r0
    6f30:	f200 80fa 	bhi.w	7128 <__udivmoddi4+0x2c4>
    6f34:	1a84      	subs	r4, r0, r2
    6f36:	eb61 0303 	sbc.w	r3, r1, r3
    6f3a:	2001      	movs	r0, #1
    6f3c:	4698      	mov	r8, r3
    6f3e:	2e00      	cmp	r6, #0
    6f40:	d0e0      	beq.n	6f04 <__udivmoddi4+0xa0>
    6f42:	e9c6 4800 	strd	r4, r8, [r6]
    6f46:	e7dd      	b.n	6f04 <__udivmoddi4+0xa0>
    6f48:	b902      	cbnz	r2, 6f4c <__udivmoddi4+0xe8>
    6f4a:	deff      	udf	#255	; 0xff
    6f4c:	fab2 f282 	clz	r2, r2
    6f50:	2a00      	cmp	r2, #0
    6f52:	f040 808f 	bne.w	7074 <__udivmoddi4+0x210>
    6f56:	1b49      	subs	r1, r1, r5
    6f58:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    6f5c:	fa1f f885 	uxth.w	r8, r5
    6f60:	2701      	movs	r7, #1
    6f62:	fbb1 fcfe 	udiv	ip, r1, lr
    6f66:	0c23      	lsrs	r3, r4, #16
    6f68:	fb0e 111c 	mls	r1, lr, ip, r1
    6f6c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    6f70:	fb08 f10c 	mul.w	r1, r8, ip
    6f74:	4299      	cmp	r1, r3
    6f76:	d907      	bls.n	6f88 <__udivmoddi4+0x124>
    6f78:	18eb      	adds	r3, r5, r3
    6f7a:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
    6f7e:	d202      	bcs.n	6f86 <__udivmoddi4+0x122>
    6f80:	4299      	cmp	r1, r3
    6f82:	f200 80cd 	bhi.w	7120 <__udivmoddi4+0x2bc>
    6f86:	4684      	mov	ip, r0
    6f88:	1a59      	subs	r1, r3, r1
    6f8a:	b2a3      	uxth	r3, r4
    6f8c:	fbb1 f0fe 	udiv	r0, r1, lr
    6f90:	fb0e 1410 	mls	r4, lr, r0, r1
    6f94:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
    6f98:	fb08 f800 	mul.w	r8, r8, r0
    6f9c:	45a0      	cmp	r8, r4
    6f9e:	d907      	bls.n	6fb0 <__udivmoddi4+0x14c>
    6fa0:	192c      	adds	r4, r5, r4
    6fa2:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    6fa6:	d202      	bcs.n	6fae <__udivmoddi4+0x14a>
    6fa8:	45a0      	cmp	r8, r4
    6faa:	f200 80b6 	bhi.w	711a <__udivmoddi4+0x2b6>
    6fae:	4618      	mov	r0, r3
    6fb0:	eba4 0408 	sub.w	r4, r4, r8
    6fb4:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    6fb8:	e79f      	b.n	6efa <__udivmoddi4+0x96>
    6fba:	f1c7 0c20 	rsb	ip, r7, #32
    6fbe:	40bb      	lsls	r3, r7
    6fc0:	fa22 fe0c 	lsr.w	lr, r2, ip
    6fc4:	ea4e 0e03 	orr.w	lr, lr, r3
    6fc8:	fa01 f407 	lsl.w	r4, r1, r7
    6fcc:	fa20 f50c 	lsr.w	r5, r0, ip
    6fd0:	fa21 f30c 	lsr.w	r3, r1, ip
    6fd4:	ea4f 481e 	mov.w	r8, lr, lsr #16
    6fd8:	4325      	orrs	r5, r4
    6fda:	fbb3 f9f8 	udiv	r9, r3, r8
    6fde:	0c2c      	lsrs	r4, r5, #16
    6fe0:	fb08 3319 	mls	r3, r8, r9, r3
    6fe4:	fa1f fa8e 	uxth.w	sl, lr
    6fe8:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
    6fec:	fb09 f40a 	mul.w	r4, r9, sl
    6ff0:	429c      	cmp	r4, r3
    6ff2:	fa02 f207 	lsl.w	r2, r2, r7
    6ff6:	fa00 f107 	lsl.w	r1, r0, r7
    6ffa:	d90b      	bls.n	7014 <__udivmoddi4+0x1b0>
    6ffc:	eb1e 0303 	adds.w	r3, lr, r3
    7000:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    7004:	f080 8087 	bcs.w	7116 <__udivmoddi4+0x2b2>
    7008:	429c      	cmp	r4, r3
    700a:	f240 8084 	bls.w	7116 <__udivmoddi4+0x2b2>
    700e:	f1a9 0902 	sub.w	r9, r9, #2
    7012:	4473      	add	r3, lr
    7014:	1b1b      	subs	r3, r3, r4
    7016:	b2ad      	uxth	r5, r5
    7018:	fbb3 f0f8 	udiv	r0, r3, r8
    701c:	fb08 3310 	mls	r3, r8, r0, r3
    7020:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
    7024:	fb00 fa0a 	mul.w	sl, r0, sl
    7028:	45a2      	cmp	sl, r4
    702a:	d908      	bls.n	703e <__udivmoddi4+0x1da>
    702c:	eb1e 0404 	adds.w	r4, lr, r4
    7030:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    7034:	d26b      	bcs.n	710e <__udivmoddi4+0x2aa>
    7036:	45a2      	cmp	sl, r4
    7038:	d969      	bls.n	710e <__udivmoddi4+0x2aa>
    703a:	3802      	subs	r0, #2
    703c:	4474      	add	r4, lr
    703e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    7042:	fba0 8902 	umull	r8, r9, r0, r2
    7046:	eba4 040a 	sub.w	r4, r4, sl
    704a:	454c      	cmp	r4, r9
    704c:	46c2      	mov	sl, r8
    704e:	464b      	mov	r3, r9
    7050:	d354      	bcc.n	70fc <__udivmoddi4+0x298>
    7052:	d051      	beq.n	70f8 <__udivmoddi4+0x294>
    7054:	2e00      	cmp	r6, #0
    7056:	d069      	beq.n	712c <__udivmoddi4+0x2c8>
    7058:	ebb1 050a 	subs.w	r5, r1, sl
    705c:	eb64 0403 	sbc.w	r4, r4, r3
    7060:	fa04 fc0c 	lsl.w	ip, r4, ip
    7064:	40fd      	lsrs	r5, r7
    7066:	40fc      	lsrs	r4, r7
    7068:	ea4c 0505 	orr.w	r5, ip, r5
    706c:	e9c6 5400 	strd	r5, r4, [r6]
    7070:	2700      	movs	r7, #0
    7072:	e747      	b.n	6f04 <__udivmoddi4+0xa0>
    7074:	f1c2 0320 	rsb	r3, r2, #32
    7078:	fa20 f703 	lsr.w	r7, r0, r3
    707c:	4095      	lsls	r5, r2
    707e:	fa01 f002 	lsl.w	r0, r1, r2
    7082:	fa21 f303 	lsr.w	r3, r1, r3
    7086:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    708a:	4338      	orrs	r0, r7
    708c:	0c01      	lsrs	r1, r0, #16
    708e:	fbb3 f7fe 	udiv	r7, r3, lr
    7092:	fa1f f885 	uxth.w	r8, r5
    7096:	fb0e 3317 	mls	r3, lr, r7, r3
    709a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    709e:	fb07 f308 	mul.w	r3, r7, r8
    70a2:	428b      	cmp	r3, r1
    70a4:	fa04 f402 	lsl.w	r4, r4, r2
    70a8:	d907      	bls.n	70ba <__udivmoddi4+0x256>
    70aa:	1869      	adds	r1, r5, r1
    70ac:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
    70b0:	d22f      	bcs.n	7112 <__udivmoddi4+0x2ae>
    70b2:	428b      	cmp	r3, r1
    70b4:	d92d      	bls.n	7112 <__udivmoddi4+0x2ae>
    70b6:	3f02      	subs	r7, #2
    70b8:	4429      	add	r1, r5
    70ba:	1acb      	subs	r3, r1, r3
    70bc:	b281      	uxth	r1, r0
    70be:	fbb3 f0fe 	udiv	r0, r3, lr
    70c2:	fb0e 3310 	mls	r3, lr, r0, r3
    70c6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    70ca:	fb00 f308 	mul.w	r3, r0, r8
    70ce:	428b      	cmp	r3, r1
    70d0:	d907      	bls.n	70e2 <__udivmoddi4+0x27e>
    70d2:	1869      	adds	r1, r5, r1
    70d4:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
    70d8:	d217      	bcs.n	710a <__udivmoddi4+0x2a6>
    70da:	428b      	cmp	r3, r1
    70dc:	d915      	bls.n	710a <__udivmoddi4+0x2a6>
    70de:	3802      	subs	r0, #2
    70e0:	4429      	add	r1, r5
    70e2:	1ac9      	subs	r1, r1, r3
    70e4:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
    70e8:	e73b      	b.n	6f62 <__udivmoddi4+0xfe>
    70ea:	4637      	mov	r7, r6
    70ec:	4630      	mov	r0, r6
    70ee:	e709      	b.n	6f04 <__udivmoddi4+0xa0>
    70f0:	4607      	mov	r7, r0
    70f2:	e6e7      	b.n	6ec4 <__udivmoddi4+0x60>
    70f4:	4618      	mov	r0, r3
    70f6:	e6fb      	b.n	6ef0 <__udivmoddi4+0x8c>
    70f8:	4541      	cmp	r1, r8
    70fa:	d2ab      	bcs.n	7054 <__udivmoddi4+0x1f0>
    70fc:	ebb8 0a02 	subs.w	sl, r8, r2
    7100:	eb69 020e 	sbc.w	r2, r9, lr
    7104:	3801      	subs	r0, #1
    7106:	4613      	mov	r3, r2
    7108:	e7a4      	b.n	7054 <__udivmoddi4+0x1f0>
    710a:	4660      	mov	r0, ip
    710c:	e7e9      	b.n	70e2 <__udivmoddi4+0x27e>
    710e:	4618      	mov	r0, r3
    7110:	e795      	b.n	703e <__udivmoddi4+0x1da>
    7112:	4667      	mov	r7, ip
    7114:	e7d1      	b.n	70ba <__udivmoddi4+0x256>
    7116:	4681      	mov	r9, r0
    7118:	e77c      	b.n	7014 <__udivmoddi4+0x1b0>
    711a:	3802      	subs	r0, #2
    711c:	442c      	add	r4, r5
    711e:	e747      	b.n	6fb0 <__udivmoddi4+0x14c>
    7120:	f1ac 0c02 	sub.w	ip, ip, #2
    7124:	442b      	add	r3, r5
    7126:	e72f      	b.n	6f88 <__udivmoddi4+0x124>
    7128:	4638      	mov	r0, r7
    712a:	e708      	b.n	6f3e <__udivmoddi4+0xda>
    712c:	4637      	mov	r7, r6
    712e:	e6e9      	b.n	6f04 <__udivmoddi4+0xa0>

00007130 <__aeabi_idiv0>:
    7130:	4770      	bx	lr
    7132:	bf00      	nop

00007134 <__libc_init_array>:
    7134:	b570      	push	{r4, r5, r6, lr}
    7136:	4e0d      	ldr	r6, [pc, #52]	; (716c <__libc_init_array+0x38>)
    7138:	4c0d      	ldr	r4, [pc, #52]	; (7170 <__libc_init_array+0x3c>)
    713a:	1ba4      	subs	r4, r4, r6
    713c:	10a4      	asrs	r4, r4, #2
    713e:	2500      	movs	r5, #0
    7140:	42a5      	cmp	r5, r4
    7142:	d109      	bne.n	7158 <__libc_init_array+0x24>
    7144:	4e0b      	ldr	r6, [pc, #44]	; (7174 <__libc_init_array+0x40>)
    7146:	4c0c      	ldr	r4, [pc, #48]	; (7178 <__libc_init_array+0x44>)
    7148:	f001 fe34 	bl	8db4 <_init>
    714c:	1ba4      	subs	r4, r4, r6
    714e:	10a4      	asrs	r4, r4, #2
    7150:	2500      	movs	r5, #0
    7152:	42a5      	cmp	r5, r4
    7154:	d105      	bne.n	7162 <__libc_init_array+0x2e>
    7156:	bd70      	pop	{r4, r5, r6, pc}
    7158:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    715c:	4798      	blx	r3
    715e:	3501      	adds	r5, #1
    7160:	e7ee      	b.n	7140 <__libc_init_array+0xc>
    7162:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    7166:	4798      	blx	r3
    7168:	3501      	adds	r5, #1
    716a:	e7f2      	b.n	7152 <__libc_init_array+0x1e>
    716c:	00008dc0 	.word	0x00008dc0
    7170:	00008dc0 	.word	0x00008dc0
    7174:	00008dc0 	.word	0x00008dc0
    7178:	00008dc4 	.word	0x00008dc4

0000717c <memcpy>:
    717c:	b510      	push	{r4, lr}
    717e:	1e43      	subs	r3, r0, #1
    7180:	440a      	add	r2, r1
    7182:	4291      	cmp	r1, r2
    7184:	d100      	bne.n	7188 <memcpy+0xc>
    7186:	bd10      	pop	{r4, pc}
    7188:	f811 4b01 	ldrb.w	r4, [r1], #1
    718c:	f803 4f01 	strb.w	r4, [r3, #1]!
    7190:	e7f7      	b.n	7182 <memcpy+0x6>

00007192 <memmove>:
    7192:	4288      	cmp	r0, r1
    7194:	b510      	push	{r4, lr}
    7196:	eb01 0302 	add.w	r3, r1, r2
    719a:	d807      	bhi.n	71ac <memmove+0x1a>
    719c:	1e42      	subs	r2, r0, #1
    719e:	4299      	cmp	r1, r3
    71a0:	d00a      	beq.n	71b8 <memmove+0x26>
    71a2:	f811 4b01 	ldrb.w	r4, [r1], #1
    71a6:	f802 4f01 	strb.w	r4, [r2, #1]!
    71aa:	e7f8      	b.n	719e <memmove+0xc>
    71ac:	4283      	cmp	r3, r0
    71ae:	d9f5      	bls.n	719c <memmove+0xa>
    71b0:	1881      	adds	r1, r0, r2
    71b2:	1ad2      	subs	r2, r2, r3
    71b4:	42d3      	cmn	r3, r2
    71b6:	d100      	bne.n	71ba <memmove+0x28>
    71b8:	bd10      	pop	{r4, pc}
    71ba:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    71be:	f801 4d01 	strb.w	r4, [r1, #-1]!
    71c2:	e7f7      	b.n	71b4 <memmove+0x22>

000071c4 <memset>:
    71c4:	4402      	add	r2, r0
    71c6:	4603      	mov	r3, r0
    71c8:	4293      	cmp	r3, r2
    71ca:	d100      	bne.n	71ce <memset+0xa>
    71cc:	4770      	bx	lr
    71ce:	f803 1b01 	strb.w	r1, [r3], #1
    71d2:	e7f9      	b.n	71c8 <memset+0x4>

000071d4 <siprintf>:
    71d4:	b40e      	push	{r1, r2, r3}
    71d6:	b500      	push	{lr}
    71d8:	b09c      	sub	sp, #112	; 0x70
    71da:	ab1d      	add	r3, sp, #116	; 0x74
    71dc:	9002      	str	r0, [sp, #8]
    71de:	9006      	str	r0, [sp, #24]
    71e0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    71e4:	4809      	ldr	r0, [pc, #36]	; (720c <siprintf+0x38>)
    71e6:	9107      	str	r1, [sp, #28]
    71e8:	9104      	str	r1, [sp, #16]
    71ea:	4909      	ldr	r1, [pc, #36]	; (7210 <siprintf+0x3c>)
    71ec:	f853 2b04 	ldr.w	r2, [r3], #4
    71f0:	9105      	str	r1, [sp, #20]
    71f2:	6800      	ldr	r0, [r0, #0]
    71f4:	9301      	str	r3, [sp, #4]
    71f6:	a902      	add	r1, sp, #8
    71f8:	f000 f8d0 	bl	739c <_svfiprintf_r>
    71fc:	9b02      	ldr	r3, [sp, #8]
    71fe:	2200      	movs	r2, #0
    7200:	701a      	strb	r2, [r3, #0]
    7202:	b01c      	add	sp, #112	; 0x70
    7204:	f85d eb04 	ldr.w	lr, [sp], #4
    7208:	b003      	add	sp, #12
    720a:	4770      	bx	lr
    720c:	2000161c 	.word	0x2000161c
    7210:	ffff0208 	.word	0xffff0208

00007214 <strcpy>:
    7214:	4603      	mov	r3, r0
    7216:	f811 2b01 	ldrb.w	r2, [r1], #1
    721a:	f803 2b01 	strb.w	r2, [r3], #1
    721e:	2a00      	cmp	r2, #0
    7220:	d1f9      	bne.n	7216 <strcpy+0x2>
    7222:	4770      	bx	lr

00007224 <strlen>:
    7224:	4603      	mov	r3, r0
    7226:	f813 2b01 	ldrb.w	r2, [r3], #1
    722a:	2a00      	cmp	r2, #0
    722c:	d1fb      	bne.n	7226 <strlen+0x2>
    722e:	1a18      	subs	r0, r3, r0
    7230:	3801      	subs	r0, #1
    7232:	4770      	bx	lr

00007234 <_malloc_r>:
    7234:	b570      	push	{r4, r5, r6, lr}
    7236:	1ccd      	adds	r5, r1, #3
    7238:	f025 0503 	bic.w	r5, r5, #3
    723c:	3508      	adds	r5, #8
    723e:	2d0c      	cmp	r5, #12
    7240:	bf38      	it	cc
    7242:	250c      	movcc	r5, #12
    7244:	2d00      	cmp	r5, #0
    7246:	4606      	mov	r6, r0
    7248:	db01      	blt.n	724e <_malloc_r+0x1a>
    724a:	42a9      	cmp	r1, r5
    724c:	d903      	bls.n	7256 <_malloc_r+0x22>
    724e:	230c      	movs	r3, #12
    7250:	6033      	str	r3, [r6, #0]
    7252:	2000      	movs	r0, #0
    7254:	bd70      	pop	{r4, r5, r6, pc}
    7256:	f000 fb83 	bl	7960 <__malloc_lock>
    725a:	4a21      	ldr	r2, [pc, #132]	; (72e0 <_malloc_r+0xac>)
    725c:	6814      	ldr	r4, [r2, #0]
    725e:	4621      	mov	r1, r4
    7260:	b991      	cbnz	r1, 7288 <_malloc_r+0x54>
    7262:	4c20      	ldr	r4, [pc, #128]	; (72e4 <_malloc_r+0xb0>)
    7264:	6823      	ldr	r3, [r4, #0]
    7266:	b91b      	cbnz	r3, 7270 <_malloc_r+0x3c>
    7268:	4630      	mov	r0, r6
    726a:	f000 fb17 	bl	789c <_sbrk_r>
    726e:	6020      	str	r0, [r4, #0]
    7270:	4629      	mov	r1, r5
    7272:	4630      	mov	r0, r6
    7274:	f000 fb12 	bl	789c <_sbrk_r>
    7278:	1c43      	adds	r3, r0, #1
    727a:	d124      	bne.n	72c6 <_malloc_r+0x92>
    727c:	230c      	movs	r3, #12
    727e:	6033      	str	r3, [r6, #0]
    7280:	4630      	mov	r0, r6
    7282:	f000 fb6e 	bl	7962 <__malloc_unlock>
    7286:	e7e4      	b.n	7252 <_malloc_r+0x1e>
    7288:	680b      	ldr	r3, [r1, #0]
    728a:	1b5b      	subs	r3, r3, r5
    728c:	d418      	bmi.n	72c0 <_malloc_r+0x8c>
    728e:	2b0b      	cmp	r3, #11
    7290:	d90f      	bls.n	72b2 <_malloc_r+0x7e>
    7292:	600b      	str	r3, [r1, #0]
    7294:	50cd      	str	r5, [r1, r3]
    7296:	18cc      	adds	r4, r1, r3
    7298:	4630      	mov	r0, r6
    729a:	f000 fb62 	bl	7962 <__malloc_unlock>
    729e:	f104 000b 	add.w	r0, r4, #11
    72a2:	1d23      	adds	r3, r4, #4
    72a4:	f020 0007 	bic.w	r0, r0, #7
    72a8:	1ac3      	subs	r3, r0, r3
    72aa:	d0d3      	beq.n	7254 <_malloc_r+0x20>
    72ac:	425a      	negs	r2, r3
    72ae:	50e2      	str	r2, [r4, r3]
    72b0:	e7d0      	b.n	7254 <_malloc_r+0x20>
    72b2:	428c      	cmp	r4, r1
    72b4:	684b      	ldr	r3, [r1, #4]
    72b6:	bf16      	itet	ne
    72b8:	6063      	strne	r3, [r4, #4]
    72ba:	6013      	streq	r3, [r2, #0]
    72bc:	460c      	movne	r4, r1
    72be:	e7eb      	b.n	7298 <_malloc_r+0x64>
    72c0:	460c      	mov	r4, r1
    72c2:	6849      	ldr	r1, [r1, #4]
    72c4:	e7cc      	b.n	7260 <_malloc_r+0x2c>
    72c6:	1cc4      	adds	r4, r0, #3
    72c8:	f024 0403 	bic.w	r4, r4, #3
    72cc:	42a0      	cmp	r0, r4
    72ce:	d005      	beq.n	72dc <_malloc_r+0xa8>
    72d0:	1a21      	subs	r1, r4, r0
    72d2:	4630      	mov	r0, r6
    72d4:	f000 fae2 	bl	789c <_sbrk_r>
    72d8:	3001      	adds	r0, #1
    72da:	d0cf      	beq.n	727c <_malloc_r+0x48>
    72dc:	6025      	str	r5, [r4, #0]
    72de:	e7db      	b.n	7298 <_malloc_r+0x64>
    72e0:	20001990 	.word	0x20001990
    72e4:	20001994 	.word	0x20001994

000072e8 <__ssputs_r>:
    72e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    72ec:	688e      	ldr	r6, [r1, #8]
    72ee:	429e      	cmp	r6, r3
    72f0:	4682      	mov	sl, r0
    72f2:	460c      	mov	r4, r1
    72f4:	4690      	mov	r8, r2
    72f6:	4699      	mov	r9, r3
    72f8:	d837      	bhi.n	736a <__ssputs_r+0x82>
    72fa:	898a      	ldrh	r2, [r1, #12]
    72fc:	f412 6f90 	tst.w	r2, #1152	; 0x480
    7300:	d031      	beq.n	7366 <__ssputs_r+0x7e>
    7302:	6825      	ldr	r5, [r4, #0]
    7304:	6909      	ldr	r1, [r1, #16]
    7306:	1a6f      	subs	r7, r5, r1
    7308:	6965      	ldr	r5, [r4, #20]
    730a:	2302      	movs	r3, #2
    730c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    7310:	fb95 f5f3 	sdiv	r5, r5, r3
    7314:	f109 0301 	add.w	r3, r9, #1
    7318:	443b      	add	r3, r7
    731a:	429d      	cmp	r5, r3
    731c:	bf38      	it	cc
    731e:	461d      	movcc	r5, r3
    7320:	0553      	lsls	r3, r2, #21
    7322:	d530      	bpl.n	7386 <__ssputs_r+0x9e>
    7324:	4629      	mov	r1, r5
    7326:	f7ff ff85 	bl	7234 <_malloc_r>
    732a:	4606      	mov	r6, r0
    732c:	b950      	cbnz	r0, 7344 <__ssputs_r+0x5c>
    732e:	230c      	movs	r3, #12
    7330:	f8ca 3000 	str.w	r3, [sl]
    7334:	89a3      	ldrh	r3, [r4, #12]
    7336:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    733a:	81a3      	strh	r3, [r4, #12]
    733c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7340:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7344:	463a      	mov	r2, r7
    7346:	6921      	ldr	r1, [r4, #16]
    7348:	f7ff ff18 	bl	717c <memcpy>
    734c:	89a3      	ldrh	r3, [r4, #12]
    734e:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
    7352:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    7356:	81a3      	strh	r3, [r4, #12]
    7358:	6126      	str	r6, [r4, #16]
    735a:	6165      	str	r5, [r4, #20]
    735c:	443e      	add	r6, r7
    735e:	1bed      	subs	r5, r5, r7
    7360:	6026      	str	r6, [r4, #0]
    7362:	60a5      	str	r5, [r4, #8]
    7364:	464e      	mov	r6, r9
    7366:	454e      	cmp	r6, r9
    7368:	d900      	bls.n	736c <__ssputs_r+0x84>
    736a:	464e      	mov	r6, r9
    736c:	4632      	mov	r2, r6
    736e:	4641      	mov	r1, r8
    7370:	6820      	ldr	r0, [r4, #0]
    7372:	f7ff ff0e 	bl	7192 <memmove>
    7376:	68a3      	ldr	r3, [r4, #8]
    7378:	1b9b      	subs	r3, r3, r6
    737a:	60a3      	str	r3, [r4, #8]
    737c:	6823      	ldr	r3, [r4, #0]
    737e:	441e      	add	r6, r3
    7380:	6026      	str	r6, [r4, #0]
    7382:	2000      	movs	r0, #0
    7384:	e7dc      	b.n	7340 <__ssputs_r+0x58>
    7386:	462a      	mov	r2, r5
    7388:	f000 fb3a 	bl	7a00 <_realloc_r>
    738c:	4606      	mov	r6, r0
    738e:	2800      	cmp	r0, #0
    7390:	d1e2      	bne.n	7358 <__ssputs_r+0x70>
    7392:	6921      	ldr	r1, [r4, #16]
    7394:	4650      	mov	r0, sl
    7396:	f000 fae5 	bl	7964 <_free_r>
    739a:	e7c8      	b.n	732e <__ssputs_r+0x46>

0000739c <_svfiprintf_r>:
    739c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    73a0:	461d      	mov	r5, r3
    73a2:	898b      	ldrh	r3, [r1, #12]
    73a4:	061f      	lsls	r7, r3, #24
    73a6:	b09d      	sub	sp, #116	; 0x74
    73a8:	4680      	mov	r8, r0
    73aa:	460c      	mov	r4, r1
    73ac:	4616      	mov	r6, r2
    73ae:	d50f      	bpl.n	73d0 <_svfiprintf_r+0x34>
    73b0:	690b      	ldr	r3, [r1, #16]
    73b2:	b96b      	cbnz	r3, 73d0 <_svfiprintf_r+0x34>
    73b4:	2140      	movs	r1, #64	; 0x40
    73b6:	f7ff ff3d 	bl	7234 <_malloc_r>
    73ba:	6020      	str	r0, [r4, #0]
    73bc:	6120      	str	r0, [r4, #16]
    73be:	b928      	cbnz	r0, 73cc <_svfiprintf_r+0x30>
    73c0:	230c      	movs	r3, #12
    73c2:	f8c8 3000 	str.w	r3, [r8]
    73c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    73ca:	e0c8      	b.n	755e <_svfiprintf_r+0x1c2>
    73cc:	2340      	movs	r3, #64	; 0x40
    73ce:	6163      	str	r3, [r4, #20]
    73d0:	2300      	movs	r3, #0
    73d2:	9309      	str	r3, [sp, #36]	; 0x24
    73d4:	2320      	movs	r3, #32
    73d6:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    73da:	2330      	movs	r3, #48	; 0x30
    73dc:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    73e0:	9503      	str	r5, [sp, #12]
    73e2:	f04f 0b01 	mov.w	fp, #1
    73e6:	4637      	mov	r7, r6
    73e8:	463d      	mov	r5, r7
    73ea:	f815 3b01 	ldrb.w	r3, [r5], #1
    73ee:	b10b      	cbz	r3, 73f4 <_svfiprintf_r+0x58>
    73f0:	2b25      	cmp	r3, #37	; 0x25
    73f2:	d13e      	bne.n	7472 <_svfiprintf_r+0xd6>
    73f4:	ebb7 0a06 	subs.w	sl, r7, r6
    73f8:	d00b      	beq.n	7412 <_svfiprintf_r+0x76>
    73fa:	4653      	mov	r3, sl
    73fc:	4632      	mov	r2, r6
    73fe:	4621      	mov	r1, r4
    7400:	4640      	mov	r0, r8
    7402:	f7ff ff71 	bl	72e8 <__ssputs_r>
    7406:	3001      	adds	r0, #1
    7408:	f000 80a4 	beq.w	7554 <_svfiprintf_r+0x1b8>
    740c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    740e:	4453      	add	r3, sl
    7410:	9309      	str	r3, [sp, #36]	; 0x24
    7412:	783b      	ldrb	r3, [r7, #0]
    7414:	2b00      	cmp	r3, #0
    7416:	f000 809d 	beq.w	7554 <_svfiprintf_r+0x1b8>
    741a:	2300      	movs	r3, #0
    741c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    7420:	e9cd 2305 	strd	r2, r3, [sp, #20]
    7424:	9304      	str	r3, [sp, #16]
    7426:	9307      	str	r3, [sp, #28]
    7428:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    742c:	931a      	str	r3, [sp, #104]	; 0x68
    742e:	462f      	mov	r7, r5
    7430:	2205      	movs	r2, #5
    7432:	f817 1b01 	ldrb.w	r1, [r7], #1
    7436:	4850      	ldr	r0, [pc, #320]	; (7578 <_svfiprintf_r+0x1dc>)
    7438:	f000 fa42 	bl	78c0 <memchr>
    743c:	9b04      	ldr	r3, [sp, #16]
    743e:	b9d0      	cbnz	r0, 7476 <_svfiprintf_r+0xda>
    7440:	06d9      	lsls	r1, r3, #27
    7442:	bf44      	itt	mi
    7444:	2220      	movmi	r2, #32
    7446:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    744a:	071a      	lsls	r2, r3, #28
    744c:	bf44      	itt	mi
    744e:	222b      	movmi	r2, #43	; 0x2b
    7450:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    7454:	782a      	ldrb	r2, [r5, #0]
    7456:	2a2a      	cmp	r2, #42	; 0x2a
    7458:	d015      	beq.n	7486 <_svfiprintf_r+0xea>
    745a:	9a07      	ldr	r2, [sp, #28]
    745c:	462f      	mov	r7, r5
    745e:	2000      	movs	r0, #0
    7460:	250a      	movs	r5, #10
    7462:	4639      	mov	r1, r7
    7464:	f811 3b01 	ldrb.w	r3, [r1], #1
    7468:	3b30      	subs	r3, #48	; 0x30
    746a:	2b09      	cmp	r3, #9
    746c:	d94d      	bls.n	750a <_svfiprintf_r+0x16e>
    746e:	b1b8      	cbz	r0, 74a0 <_svfiprintf_r+0x104>
    7470:	e00f      	b.n	7492 <_svfiprintf_r+0xf6>
    7472:	462f      	mov	r7, r5
    7474:	e7b8      	b.n	73e8 <_svfiprintf_r+0x4c>
    7476:	4a40      	ldr	r2, [pc, #256]	; (7578 <_svfiprintf_r+0x1dc>)
    7478:	1a80      	subs	r0, r0, r2
    747a:	fa0b f000 	lsl.w	r0, fp, r0
    747e:	4318      	orrs	r0, r3
    7480:	9004      	str	r0, [sp, #16]
    7482:	463d      	mov	r5, r7
    7484:	e7d3      	b.n	742e <_svfiprintf_r+0x92>
    7486:	9a03      	ldr	r2, [sp, #12]
    7488:	1d11      	adds	r1, r2, #4
    748a:	6812      	ldr	r2, [r2, #0]
    748c:	9103      	str	r1, [sp, #12]
    748e:	2a00      	cmp	r2, #0
    7490:	db01      	blt.n	7496 <_svfiprintf_r+0xfa>
    7492:	9207      	str	r2, [sp, #28]
    7494:	e004      	b.n	74a0 <_svfiprintf_r+0x104>
    7496:	4252      	negs	r2, r2
    7498:	f043 0302 	orr.w	r3, r3, #2
    749c:	9207      	str	r2, [sp, #28]
    749e:	9304      	str	r3, [sp, #16]
    74a0:	783b      	ldrb	r3, [r7, #0]
    74a2:	2b2e      	cmp	r3, #46	; 0x2e
    74a4:	d10c      	bne.n	74c0 <_svfiprintf_r+0x124>
    74a6:	787b      	ldrb	r3, [r7, #1]
    74a8:	2b2a      	cmp	r3, #42	; 0x2a
    74aa:	d133      	bne.n	7514 <_svfiprintf_r+0x178>
    74ac:	9b03      	ldr	r3, [sp, #12]
    74ae:	1d1a      	adds	r2, r3, #4
    74b0:	681b      	ldr	r3, [r3, #0]
    74b2:	9203      	str	r2, [sp, #12]
    74b4:	2b00      	cmp	r3, #0
    74b6:	bfb8      	it	lt
    74b8:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
    74bc:	3702      	adds	r7, #2
    74be:	9305      	str	r3, [sp, #20]
    74c0:	4d2e      	ldr	r5, [pc, #184]	; (757c <_svfiprintf_r+0x1e0>)
    74c2:	7839      	ldrb	r1, [r7, #0]
    74c4:	2203      	movs	r2, #3
    74c6:	4628      	mov	r0, r5
    74c8:	f000 f9fa 	bl	78c0 <memchr>
    74cc:	b138      	cbz	r0, 74de <_svfiprintf_r+0x142>
    74ce:	2340      	movs	r3, #64	; 0x40
    74d0:	1b40      	subs	r0, r0, r5
    74d2:	fa03 f000 	lsl.w	r0, r3, r0
    74d6:	9b04      	ldr	r3, [sp, #16]
    74d8:	4303      	orrs	r3, r0
    74da:	3701      	adds	r7, #1
    74dc:	9304      	str	r3, [sp, #16]
    74de:	7839      	ldrb	r1, [r7, #0]
    74e0:	4827      	ldr	r0, [pc, #156]	; (7580 <_svfiprintf_r+0x1e4>)
    74e2:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    74e6:	2206      	movs	r2, #6
    74e8:	1c7e      	adds	r6, r7, #1
    74ea:	f000 f9e9 	bl	78c0 <memchr>
    74ee:	2800      	cmp	r0, #0
    74f0:	d038      	beq.n	7564 <_svfiprintf_r+0x1c8>
    74f2:	4b24      	ldr	r3, [pc, #144]	; (7584 <_svfiprintf_r+0x1e8>)
    74f4:	bb13      	cbnz	r3, 753c <_svfiprintf_r+0x1a0>
    74f6:	9b03      	ldr	r3, [sp, #12]
    74f8:	3307      	adds	r3, #7
    74fa:	f023 0307 	bic.w	r3, r3, #7
    74fe:	3308      	adds	r3, #8
    7500:	9303      	str	r3, [sp, #12]
    7502:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7504:	444b      	add	r3, r9
    7506:	9309      	str	r3, [sp, #36]	; 0x24
    7508:	e76d      	b.n	73e6 <_svfiprintf_r+0x4a>
    750a:	fb05 3202 	mla	r2, r5, r2, r3
    750e:	2001      	movs	r0, #1
    7510:	460f      	mov	r7, r1
    7512:	e7a6      	b.n	7462 <_svfiprintf_r+0xc6>
    7514:	2300      	movs	r3, #0
    7516:	3701      	adds	r7, #1
    7518:	9305      	str	r3, [sp, #20]
    751a:	4619      	mov	r1, r3
    751c:	250a      	movs	r5, #10
    751e:	4638      	mov	r0, r7
    7520:	f810 2b01 	ldrb.w	r2, [r0], #1
    7524:	3a30      	subs	r2, #48	; 0x30
    7526:	2a09      	cmp	r2, #9
    7528:	d903      	bls.n	7532 <_svfiprintf_r+0x196>
    752a:	2b00      	cmp	r3, #0
    752c:	d0c8      	beq.n	74c0 <_svfiprintf_r+0x124>
    752e:	9105      	str	r1, [sp, #20]
    7530:	e7c6      	b.n	74c0 <_svfiprintf_r+0x124>
    7532:	fb05 2101 	mla	r1, r5, r1, r2
    7536:	2301      	movs	r3, #1
    7538:	4607      	mov	r7, r0
    753a:	e7f0      	b.n	751e <_svfiprintf_r+0x182>
    753c:	ab03      	add	r3, sp, #12
    753e:	9300      	str	r3, [sp, #0]
    7540:	4622      	mov	r2, r4
    7542:	4b11      	ldr	r3, [pc, #68]	; (7588 <_svfiprintf_r+0x1ec>)
    7544:	a904      	add	r1, sp, #16
    7546:	4640      	mov	r0, r8
    7548:	f3af 8000 	nop.w
    754c:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    7550:	4681      	mov	r9, r0
    7552:	d1d6      	bne.n	7502 <_svfiprintf_r+0x166>
    7554:	89a3      	ldrh	r3, [r4, #12]
    7556:	065b      	lsls	r3, r3, #25
    7558:	f53f af35 	bmi.w	73c6 <_svfiprintf_r+0x2a>
    755c:	9809      	ldr	r0, [sp, #36]	; 0x24
    755e:	b01d      	add	sp, #116	; 0x74
    7560:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7564:	ab03      	add	r3, sp, #12
    7566:	9300      	str	r3, [sp, #0]
    7568:	4622      	mov	r2, r4
    756a:	4b07      	ldr	r3, [pc, #28]	; (7588 <_svfiprintf_r+0x1ec>)
    756c:	a904      	add	r1, sp, #16
    756e:	4640      	mov	r0, r8
    7570:	f000 f882 	bl	7678 <_printf_i>
    7574:	e7ea      	b.n	754c <_svfiprintf_r+0x1b0>
    7576:	bf00      	nop
    7578:	00008d80 	.word	0x00008d80
    757c:	00008d86 	.word	0x00008d86
    7580:	00008d8a 	.word	0x00008d8a
    7584:	00000000 	.word	0x00000000
    7588:	000072e9 	.word	0x000072e9

0000758c <_printf_common>:
    758c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7590:	4691      	mov	r9, r2
    7592:	461f      	mov	r7, r3
    7594:	688a      	ldr	r2, [r1, #8]
    7596:	690b      	ldr	r3, [r1, #16]
    7598:	f8dd 8020 	ldr.w	r8, [sp, #32]
    759c:	4293      	cmp	r3, r2
    759e:	bfb8      	it	lt
    75a0:	4613      	movlt	r3, r2
    75a2:	f8c9 3000 	str.w	r3, [r9]
    75a6:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    75aa:	4606      	mov	r6, r0
    75ac:	460c      	mov	r4, r1
    75ae:	b112      	cbz	r2, 75b6 <_printf_common+0x2a>
    75b0:	3301      	adds	r3, #1
    75b2:	f8c9 3000 	str.w	r3, [r9]
    75b6:	6823      	ldr	r3, [r4, #0]
    75b8:	0699      	lsls	r1, r3, #26
    75ba:	bf42      	ittt	mi
    75bc:	f8d9 3000 	ldrmi.w	r3, [r9]
    75c0:	3302      	addmi	r3, #2
    75c2:	f8c9 3000 	strmi.w	r3, [r9]
    75c6:	6825      	ldr	r5, [r4, #0]
    75c8:	f015 0506 	ands.w	r5, r5, #6
    75cc:	d107      	bne.n	75de <_printf_common+0x52>
    75ce:	f104 0a19 	add.w	sl, r4, #25
    75d2:	68e3      	ldr	r3, [r4, #12]
    75d4:	f8d9 2000 	ldr.w	r2, [r9]
    75d8:	1a9b      	subs	r3, r3, r2
    75da:	42ab      	cmp	r3, r5
    75dc:	dc28      	bgt.n	7630 <_printf_common+0xa4>
    75de:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    75e2:	6822      	ldr	r2, [r4, #0]
    75e4:	3300      	adds	r3, #0
    75e6:	bf18      	it	ne
    75e8:	2301      	movne	r3, #1
    75ea:	0692      	lsls	r2, r2, #26
    75ec:	d42d      	bmi.n	764a <_printf_common+0xbe>
    75ee:	f104 0243 	add.w	r2, r4, #67	; 0x43
    75f2:	4639      	mov	r1, r7
    75f4:	4630      	mov	r0, r6
    75f6:	47c0      	blx	r8
    75f8:	3001      	adds	r0, #1
    75fa:	d020      	beq.n	763e <_printf_common+0xb2>
    75fc:	6823      	ldr	r3, [r4, #0]
    75fe:	68e5      	ldr	r5, [r4, #12]
    7600:	f8d9 2000 	ldr.w	r2, [r9]
    7604:	f003 0306 	and.w	r3, r3, #6
    7608:	2b04      	cmp	r3, #4
    760a:	bf08      	it	eq
    760c:	1aad      	subeq	r5, r5, r2
    760e:	68a3      	ldr	r3, [r4, #8]
    7610:	6922      	ldr	r2, [r4, #16]
    7612:	bf0c      	ite	eq
    7614:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    7618:	2500      	movne	r5, #0
    761a:	4293      	cmp	r3, r2
    761c:	bfc4      	itt	gt
    761e:	1a9b      	subgt	r3, r3, r2
    7620:	18ed      	addgt	r5, r5, r3
    7622:	f04f 0900 	mov.w	r9, #0
    7626:	341a      	adds	r4, #26
    7628:	454d      	cmp	r5, r9
    762a:	d11a      	bne.n	7662 <_printf_common+0xd6>
    762c:	2000      	movs	r0, #0
    762e:	e008      	b.n	7642 <_printf_common+0xb6>
    7630:	2301      	movs	r3, #1
    7632:	4652      	mov	r2, sl
    7634:	4639      	mov	r1, r7
    7636:	4630      	mov	r0, r6
    7638:	47c0      	blx	r8
    763a:	3001      	adds	r0, #1
    763c:	d103      	bne.n	7646 <_printf_common+0xba>
    763e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7642:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7646:	3501      	adds	r5, #1
    7648:	e7c3      	b.n	75d2 <_printf_common+0x46>
    764a:	18e1      	adds	r1, r4, r3
    764c:	1c5a      	adds	r2, r3, #1
    764e:	2030      	movs	r0, #48	; 0x30
    7650:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    7654:	4422      	add	r2, r4
    7656:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    765a:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    765e:	3302      	adds	r3, #2
    7660:	e7c5      	b.n	75ee <_printf_common+0x62>
    7662:	2301      	movs	r3, #1
    7664:	4622      	mov	r2, r4
    7666:	4639      	mov	r1, r7
    7668:	4630      	mov	r0, r6
    766a:	47c0      	blx	r8
    766c:	3001      	adds	r0, #1
    766e:	d0e6      	beq.n	763e <_printf_common+0xb2>
    7670:	f109 0901 	add.w	r9, r9, #1
    7674:	e7d8      	b.n	7628 <_printf_common+0x9c>
	...

00007678 <_printf_i>:
    7678:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    767c:	f101 0c43 	add.w	ip, r1, #67	; 0x43
    7680:	460c      	mov	r4, r1
    7682:	7e09      	ldrb	r1, [r1, #24]
    7684:	b085      	sub	sp, #20
    7686:	296e      	cmp	r1, #110	; 0x6e
    7688:	4617      	mov	r7, r2
    768a:	4606      	mov	r6, r0
    768c:	4698      	mov	r8, r3
    768e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    7690:	f000 80b3 	beq.w	77fa <_printf_i+0x182>
    7694:	d822      	bhi.n	76dc <_printf_i+0x64>
    7696:	2963      	cmp	r1, #99	; 0x63
    7698:	d036      	beq.n	7708 <_printf_i+0x90>
    769a:	d80a      	bhi.n	76b2 <_printf_i+0x3a>
    769c:	2900      	cmp	r1, #0
    769e:	f000 80b9 	beq.w	7814 <_printf_i+0x19c>
    76a2:	2958      	cmp	r1, #88	; 0x58
    76a4:	f000 8083 	beq.w	77ae <_printf_i+0x136>
    76a8:	f104 0542 	add.w	r5, r4, #66	; 0x42
    76ac:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
    76b0:	e032      	b.n	7718 <_printf_i+0xa0>
    76b2:	2964      	cmp	r1, #100	; 0x64
    76b4:	d001      	beq.n	76ba <_printf_i+0x42>
    76b6:	2969      	cmp	r1, #105	; 0x69
    76b8:	d1f6      	bne.n	76a8 <_printf_i+0x30>
    76ba:	6820      	ldr	r0, [r4, #0]
    76bc:	6813      	ldr	r3, [r2, #0]
    76be:	0605      	lsls	r5, r0, #24
    76c0:	f103 0104 	add.w	r1, r3, #4
    76c4:	d52a      	bpl.n	771c <_printf_i+0xa4>
    76c6:	681b      	ldr	r3, [r3, #0]
    76c8:	6011      	str	r1, [r2, #0]
    76ca:	2b00      	cmp	r3, #0
    76cc:	da03      	bge.n	76d6 <_printf_i+0x5e>
    76ce:	222d      	movs	r2, #45	; 0x2d
    76d0:	425b      	negs	r3, r3
    76d2:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
    76d6:	486f      	ldr	r0, [pc, #444]	; (7894 <_printf_i+0x21c>)
    76d8:	220a      	movs	r2, #10
    76da:	e039      	b.n	7750 <_printf_i+0xd8>
    76dc:	2973      	cmp	r1, #115	; 0x73
    76de:	f000 809d 	beq.w	781c <_printf_i+0x1a4>
    76e2:	d808      	bhi.n	76f6 <_printf_i+0x7e>
    76e4:	296f      	cmp	r1, #111	; 0x6f
    76e6:	d020      	beq.n	772a <_printf_i+0xb2>
    76e8:	2970      	cmp	r1, #112	; 0x70
    76ea:	d1dd      	bne.n	76a8 <_printf_i+0x30>
    76ec:	6823      	ldr	r3, [r4, #0]
    76ee:	f043 0320 	orr.w	r3, r3, #32
    76f2:	6023      	str	r3, [r4, #0]
    76f4:	e003      	b.n	76fe <_printf_i+0x86>
    76f6:	2975      	cmp	r1, #117	; 0x75
    76f8:	d017      	beq.n	772a <_printf_i+0xb2>
    76fa:	2978      	cmp	r1, #120	; 0x78
    76fc:	d1d4      	bne.n	76a8 <_printf_i+0x30>
    76fe:	2378      	movs	r3, #120	; 0x78
    7700:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    7704:	4864      	ldr	r0, [pc, #400]	; (7898 <_printf_i+0x220>)
    7706:	e055      	b.n	77b4 <_printf_i+0x13c>
    7708:	6813      	ldr	r3, [r2, #0]
    770a:	1d19      	adds	r1, r3, #4
    770c:	681b      	ldr	r3, [r3, #0]
    770e:	6011      	str	r1, [r2, #0]
    7710:	f104 0542 	add.w	r5, r4, #66	; 0x42
    7714:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    7718:	2301      	movs	r3, #1
    771a:	e08c      	b.n	7836 <_printf_i+0x1be>
    771c:	681b      	ldr	r3, [r3, #0]
    771e:	6011      	str	r1, [r2, #0]
    7720:	f010 0f40 	tst.w	r0, #64	; 0x40
    7724:	bf18      	it	ne
    7726:	b21b      	sxthne	r3, r3
    7728:	e7cf      	b.n	76ca <_printf_i+0x52>
    772a:	6813      	ldr	r3, [r2, #0]
    772c:	6825      	ldr	r5, [r4, #0]
    772e:	1d18      	adds	r0, r3, #4
    7730:	6010      	str	r0, [r2, #0]
    7732:	0628      	lsls	r0, r5, #24
    7734:	d501      	bpl.n	773a <_printf_i+0xc2>
    7736:	681b      	ldr	r3, [r3, #0]
    7738:	e002      	b.n	7740 <_printf_i+0xc8>
    773a:	0668      	lsls	r0, r5, #25
    773c:	d5fb      	bpl.n	7736 <_printf_i+0xbe>
    773e:	881b      	ldrh	r3, [r3, #0]
    7740:	4854      	ldr	r0, [pc, #336]	; (7894 <_printf_i+0x21c>)
    7742:	296f      	cmp	r1, #111	; 0x6f
    7744:	bf14      	ite	ne
    7746:	220a      	movne	r2, #10
    7748:	2208      	moveq	r2, #8
    774a:	2100      	movs	r1, #0
    774c:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    7750:	6865      	ldr	r5, [r4, #4]
    7752:	60a5      	str	r5, [r4, #8]
    7754:	2d00      	cmp	r5, #0
    7756:	f2c0 8095 	blt.w	7884 <_printf_i+0x20c>
    775a:	6821      	ldr	r1, [r4, #0]
    775c:	f021 0104 	bic.w	r1, r1, #4
    7760:	6021      	str	r1, [r4, #0]
    7762:	2b00      	cmp	r3, #0
    7764:	d13d      	bne.n	77e2 <_printf_i+0x16a>
    7766:	2d00      	cmp	r5, #0
    7768:	f040 808e 	bne.w	7888 <_printf_i+0x210>
    776c:	4665      	mov	r5, ip
    776e:	2a08      	cmp	r2, #8
    7770:	d10b      	bne.n	778a <_printf_i+0x112>
    7772:	6823      	ldr	r3, [r4, #0]
    7774:	07db      	lsls	r3, r3, #31
    7776:	d508      	bpl.n	778a <_printf_i+0x112>
    7778:	6923      	ldr	r3, [r4, #16]
    777a:	6862      	ldr	r2, [r4, #4]
    777c:	429a      	cmp	r2, r3
    777e:	bfde      	ittt	le
    7780:	2330      	movle	r3, #48	; 0x30
    7782:	f805 3c01 	strble.w	r3, [r5, #-1]
    7786:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
    778a:	ebac 0305 	sub.w	r3, ip, r5
    778e:	6123      	str	r3, [r4, #16]
    7790:	f8cd 8000 	str.w	r8, [sp]
    7794:	463b      	mov	r3, r7
    7796:	aa03      	add	r2, sp, #12
    7798:	4621      	mov	r1, r4
    779a:	4630      	mov	r0, r6
    779c:	f7ff fef6 	bl	758c <_printf_common>
    77a0:	3001      	adds	r0, #1
    77a2:	d14d      	bne.n	7840 <_printf_i+0x1c8>
    77a4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    77a8:	b005      	add	sp, #20
    77aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    77ae:	4839      	ldr	r0, [pc, #228]	; (7894 <_printf_i+0x21c>)
    77b0:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
    77b4:	6813      	ldr	r3, [r2, #0]
    77b6:	6821      	ldr	r1, [r4, #0]
    77b8:	1d1d      	adds	r5, r3, #4
    77ba:	681b      	ldr	r3, [r3, #0]
    77bc:	6015      	str	r5, [r2, #0]
    77be:	060a      	lsls	r2, r1, #24
    77c0:	d50b      	bpl.n	77da <_printf_i+0x162>
    77c2:	07ca      	lsls	r2, r1, #31
    77c4:	bf44      	itt	mi
    77c6:	f041 0120 	orrmi.w	r1, r1, #32
    77ca:	6021      	strmi	r1, [r4, #0]
    77cc:	b91b      	cbnz	r3, 77d6 <_printf_i+0x15e>
    77ce:	6822      	ldr	r2, [r4, #0]
    77d0:	f022 0220 	bic.w	r2, r2, #32
    77d4:	6022      	str	r2, [r4, #0]
    77d6:	2210      	movs	r2, #16
    77d8:	e7b7      	b.n	774a <_printf_i+0xd2>
    77da:	064d      	lsls	r5, r1, #25
    77dc:	bf48      	it	mi
    77de:	b29b      	uxthmi	r3, r3
    77e0:	e7ef      	b.n	77c2 <_printf_i+0x14a>
    77e2:	4665      	mov	r5, ip
    77e4:	fbb3 f1f2 	udiv	r1, r3, r2
    77e8:	fb02 3311 	mls	r3, r2, r1, r3
    77ec:	5cc3      	ldrb	r3, [r0, r3]
    77ee:	f805 3d01 	strb.w	r3, [r5, #-1]!
    77f2:	460b      	mov	r3, r1
    77f4:	2900      	cmp	r1, #0
    77f6:	d1f5      	bne.n	77e4 <_printf_i+0x16c>
    77f8:	e7b9      	b.n	776e <_printf_i+0xf6>
    77fa:	6813      	ldr	r3, [r2, #0]
    77fc:	6825      	ldr	r5, [r4, #0]
    77fe:	6961      	ldr	r1, [r4, #20]
    7800:	1d18      	adds	r0, r3, #4
    7802:	6010      	str	r0, [r2, #0]
    7804:	0628      	lsls	r0, r5, #24
    7806:	681b      	ldr	r3, [r3, #0]
    7808:	d501      	bpl.n	780e <_printf_i+0x196>
    780a:	6019      	str	r1, [r3, #0]
    780c:	e002      	b.n	7814 <_printf_i+0x19c>
    780e:	066a      	lsls	r2, r5, #25
    7810:	d5fb      	bpl.n	780a <_printf_i+0x192>
    7812:	8019      	strh	r1, [r3, #0]
    7814:	2300      	movs	r3, #0
    7816:	6123      	str	r3, [r4, #16]
    7818:	4665      	mov	r5, ip
    781a:	e7b9      	b.n	7790 <_printf_i+0x118>
    781c:	6813      	ldr	r3, [r2, #0]
    781e:	1d19      	adds	r1, r3, #4
    7820:	6011      	str	r1, [r2, #0]
    7822:	681d      	ldr	r5, [r3, #0]
    7824:	6862      	ldr	r2, [r4, #4]
    7826:	2100      	movs	r1, #0
    7828:	4628      	mov	r0, r5
    782a:	f000 f849 	bl	78c0 <memchr>
    782e:	b108      	cbz	r0, 7834 <_printf_i+0x1bc>
    7830:	1b40      	subs	r0, r0, r5
    7832:	6060      	str	r0, [r4, #4]
    7834:	6863      	ldr	r3, [r4, #4]
    7836:	6123      	str	r3, [r4, #16]
    7838:	2300      	movs	r3, #0
    783a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    783e:	e7a7      	b.n	7790 <_printf_i+0x118>
    7840:	6923      	ldr	r3, [r4, #16]
    7842:	462a      	mov	r2, r5
    7844:	4639      	mov	r1, r7
    7846:	4630      	mov	r0, r6
    7848:	47c0      	blx	r8
    784a:	3001      	adds	r0, #1
    784c:	d0aa      	beq.n	77a4 <_printf_i+0x12c>
    784e:	6823      	ldr	r3, [r4, #0]
    7850:	079b      	lsls	r3, r3, #30
    7852:	d413      	bmi.n	787c <_printf_i+0x204>
    7854:	68e0      	ldr	r0, [r4, #12]
    7856:	9b03      	ldr	r3, [sp, #12]
    7858:	4298      	cmp	r0, r3
    785a:	bfb8      	it	lt
    785c:	4618      	movlt	r0, r3
    785e:	e7a3      	b.n	77a8 <_printf_i+0x130>
    7860:	2301      	movs	r3, #1
    7862:	464a      	mov	r2, r9
    7864:	4639      	mov	r1, r7
    7866:	4630      	mov	r0, r6
    7868:	47c0      	blx	r8
    786a:	3001      	adds	r0, #1
    786c:	d09a      	beq.n	77a4 <_printf_i+0x12c>
    786e:	3501      	adds	r5, #1
    7870:	68e3      	ldr	r3, [r4, #12]
    7872:	9a03      	ldr	r2, [sp, #12]
    7874:	1a9b      	subs	r3, r3, r2
    7876:	42ab      	cmp	r3, r5
    7878:	dcf2      	bgt.n	7860 <_printf_i+0x1e8>
    787a:	e7eb      	b.n	7854 <_printf_i+0x1dc>
    787c:	2500      	movs	r5, #0
    787e:	f104 0919 	add.w	r9, r4, #25
    7882:	e7f5      	b.n	7870 <_printf_i+0x1f8>
    7884:	2b00      	cmp	r3, #0
    7886:	d1ac      	bne.n	77e2 <_printf_i+0x16a>
    7888:	7803      	ldrb	r3, [r0, #0]
    788a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    788e:	f104 0542 	add.w	r5, r4, #66	; 0x42
    7892:	e76c      	b.n	776e <_printf_i+0xf6>
    7894:	00008d91 	.word	0x00008d91
    7898:	00008da2 	.word	0x00008da2

0000789c <_sbrk_r>:
    789c:	b538      	push	{r3, r4, r5, lr}
    789e:	4c06      	ldr	r4, [pc, #24]	; (78b8 <_sbrk_r+0x1c>)
    78a0:	2300      	movs	r3, #0
    78a2:	4605      	mov	r5, r0
    78a4:	4608      	mov	r0, r1
    78a6:	6023      	str	r3, [r4, #0]
    78a8:	f7fc fe74 	bl	4594 <_sbrk>
    78ac:	1c43      	adds	r3, r0, #1
    78ae:	d102      	bne.n	78b6 <_sbrk_r+0x1a>
    78b0:	6823      	ldr	r3, [r4, #0]
    78b2:	b103      	cbz	r3, 78b6 <_sbrk_r+0x1a>
    78b4:	602b      	str	r3, [r5, #0]
    78b6:	bd38      	pop	{r3, r4, r5, pc}
    78b8:	200042d4 	.word	0x200042d4
    78bc:	00000000 	.word	0x00000000

000078c0 <memchr>:
    78c0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    78c4:	2a10      	cmp	r2, #16
    78c6:	db2b      	blt.n	7920 <memchr+0x60>
    78c8:	f010 0f07 	tst.w	r0, #7
    78cc:	d008      	beq.n	78e0 <memchr+0x20>
    78ce:	f810 3b01 	ldrb.w	r3, [r0], #1
    78d2:	3a01      	subs	r2, #1
    78d4:	428b      	cmp	r3, r1
    78d6:	d02d      	beq.n	7934 <memchr+0x74>
    78d8:	f010 0f07 	tst.w	r0, #7
    78dc:	b342      	cbz	r2, 7930 <memchr+0x70>
    78de:	d1f6      	bne.n	78ce <memchr+0xe>
    78e0:	b4f0      	push	{r4, r5, r6, r7}
    78e2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    78e6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    78ea:	f022 0407 	bic.w	r4, r2, #7
    78ee:	f07f 0700 	mvns.w	r7, #0
    78f2:	2300      	movs	r3, #0
    78f4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    78f8:	3c08      	subs	r4, #8
    78fa:	ea85 0501 	eor.w	r5, r5, r1
    78fe:	ea86 0601 	eor.w	r6, r6, r1
    7902:	fa85 f547 	uadd8	r5, r5, r7
    7906:	faa3 f587 	sel	r5, r3, r7
    790a:	fa86 f647 	uadd8	r6, r6, r7
    790e:	faa5 f687 	sel	r6, r5, r7
    7912:	b98e      	cbnz	r6, 7938 <memchr+0x78>
    7914:	d1ee      	bne.n	78f4 <memchr+0x34>
    7916:	bcf0      	pop	{r4, r5, r6, r7}
    7918:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    791c:	f002 0207 	and.w	r2, r2, #7
    7920:	b132      	cbz	r2, 7930 <memchr+0x70>
    7922:	f810 3b01 	ldrb.w	r3, [r0], #1
    7926:	3a01      	subs	r2, #1
    7928:	ea83 0301 	eor.w	r3, r3, r1
    792c:	b113      	cbz	r3, 7934 <memchr+0x74>
    792e:	d1f8      	bne.n	7922 <memchr+0x62>
    7930:	2000      	movs	r0, #0
    7932:	4770      	bx	lr
    7934:	3801      	subs	r0, #1
    7936:	4770      	bx	lr
    7938:	2d00      	cmp	r5, #0
    793a:	bf06      	itte	eq
    793c:	4635      	moveq	r5, r6
    793e:	3803      	subeq	r0, #3
    7940:	3807      	subne	r0, #7
    7942:	f015 0f01 	tst.w	r5, #1
    7946:	d107      	bne.n	7958 <memchr+0x98>
    7948:	3001      	adds	r0, #1
    794a:	f415 7f80 	tst.w	r5, #256	; 0x100
    794e:	bf02      	ittt	eq
    7950:	3001      	addeq	r0, #1
    7952:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    7956:	3001      	addeq	r0, #1
    7958:	bcf0      	pop	{r4, r5, r6, r7}
    795a:	3801      	subs	r0, #1
    795c:	4770      	bx	lr
    795e:	bf00      	nop

00007960 <__malloc_lock>:
    7960:	4770      	bx	lr

00007962 <__malloc_unlock>:
    7962:	4770      	bx	lr

00007964 <_free_r>:
    7964:	b538      	push	{r3, r4, r5, lr}
    7966:	4605      	mov	r5, r0
    7968:	2900      	cmp	r1, #0
    796a:	d045      	beq.n	79f8 <_free_r+0x94>
    796c:	f851 3c04 	ldr.w	r3, [r1, #-4]
    7970:	1f0c      	subs	r4, r1, #4
    7972:	2b00      	cmp	r3, #0
    7974:	bfb8      	it	lt
    7976:	18e4      	addlt	r4, r4, r3
    7978:	f7ff fff2 	bl	7960 <__malloc_lock>
    797c:	4a1f      	ldr	r2, [pc, #124]	; (79fc <_free_r+0x98>)
    797e:	6813      	ldr	r3, [r2, #0]
    7980:	4610      	mov	r0, r2
    7982:	b933      	cbnz	r3, 7992 <_free_r+0x2e>
    7984:	6063      	str	r3, [r4, #4]
    7986:	6014      	str	r4, [r2, #0]
    7988:	4628      	mov	r0, r5
    798a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    798e:	f7ff bfe8 	b.w	7962 <__malloc_unlock>
    7992:	42a3      	cmp	r3, r4
    7994:	d90c      	bls.n	79b0 <_free_r+0x4c>
    7996:	6821      	ldr	r1, [r4, #0]
    7998:	1862      	adds	r2, r4, r1
    799a:	4293      	cmp	r3, r2
    799c:	bf04      	itt	eq
    799e:	681a      	ldreq	r2, [r3, #0]
    79a0:	685b      	ldreq	r3, [r3, #4]
    79a2:	6063      	str	r3, [r4, #4]
    79a4:	bf04      	itt	eq
    79a6:	1852      	addeq	r2, r2, r1
    79a8:	6022      	streq	r2, [r4, #0]
    79aa:	6004      	str	r4, [r0, #0]
    79ac:	e7ec      	b.n	7988 <_free_r+0x24>
    79ae:	4613      	mov	r3, r2
    79b0:	685a      	ldr	r2, [r3, #4]
    79b2:	b10a      	cbz	r2, 79b8 <_free_r+0x54>
    79b4:	42a2      	cmp	r2, r4
    79b6:	d9fa      	bls.n	79ae <_free_r+0x4a>
    79b8:	6819      	ldr	r1, [r3, #0]
    79ba:	1858      	adds	r0, r3, r1
    79bc:	42a0      	cmp	r0, r4
    79be:	d10b      	bne.n	79d8 <_free_r+0x74>
    79c0:	6820      	ldr	r0, [r4, #0]
    79c2:	4401      	add	r1, r0
    79c4:	1858      	adds	r0, r3, r1
    79c6:	4282      	cmp	r2, r0
    79c8:	6019      	str	r1, [r3, #0]
    79ca:	d1dd      	bne.n	7988 <_free_r+0x24>
    79cc:	6810      	ldr	r0, [r2, #0]
    79ce:	6852      	ldr	r2, [r2, #4]
    79d0:	605a      	str	r2, [r3, #4]
    79d2:	4401      	add	r1, r0
    79d4:	6019      	str	r1, [r3, #0]
    79d6:	e7d7      	b.n	7988 <_free_r+0x24>
    79d8:	d902      	bls.n	79e0 <_free_r+0x7c>
    79da:	230c      	movs	r3, #12
    79dc:	602b      	str	r3, [r5, #0]
    79de:	e7d3      	b.n	7988 <_free_r+0x24>
    79e0:	6820      	ldr	r0, [r4, #0]
    79e2:	1821      	adds	r1, r4, r0
    79e4:	428a      	cmp	r2, r1
    79e6:	bf04      	itt	eq
    79e8:	6811      	ldreq	r1, [r2, #0]
    79ea:	6852      	ldreq	r2, [r2, #4]
    79ec:	6062      	str	r2, [r4, #4]
    79ee:	bf04      	itt	eq
    79f0:	1809      	addeq	r1, r1, r0
    79f2:	6021      	streq	r1, [r4, #0]
    79f4:	605c      	str	r4, [r3, #4]
    79f6:	e7c7      	b.n	7988 <_free_r+0x24>
    79f8:	bd38      	pop	{r3, r4, r5, pc}
    79fa:	bf00      	nop
    79fc:	20001990 	.word	0x20001990

00007a00 <_realloc_r>:
    7a00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7a02:	4607      	mov	r7, r0
    7a04:	4614      	mov	r4, r2
    7a06:	460e      	mov	r6, r1
    7a08:	b921      	cbnz	r1, 7a14 <_realloc_r+0x14>
    7a0a:	4611      	mov	r1, r2
    7a0c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    7a10:	f7ff bc10 	b.w	7234 <_malloc_r>
    7a14:	b922      	cbnz	r2, 7a20 <_realloc_r+0x20>
    7a16:	f7ff ffa5 	bl	7964 <_free_r>
    7a1a:	4625      	mov	r5, r4
    7a1c:	4628      	mov	r0, r5
    7a1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7a20:	f000 f814 	bl	7a4c <_malloc_usable_size_r>
    7a24:	42a0      	cmp	r0, r4
    7a26:	d20f      	bcs.n	7a48 <_realloc_r+0x48>
    7a28:	4621      	mov	r1, r4
    7a2a:	4638      	mov	r0, r7
    7a2c:	f7ff fc02 	bl	7234 <_malloc_r>
    7a30:	4605      	mov	r5, r0
    7a32:	2800      	cmp	r0, #0
    7a34:	d0f2      	beq.n	7a1c <_realloc_r+0x1c>
    7a36:	4631      	mov	r1, r6
    7a38:	4622      	mov	r2, r4
    7a3a:	f7ff fb9f 	bl	717c <memcpy>
    7a3e:	4631      	mov	r1, r6
    7a40:	4638      	mov	r0, r7
    7a42:	f7ff ff8f 	bl	7964 <_free_r>
    7a46:	e7e9      	b.n	7a1c <_realloc_r+0x1c>
    7a48:	4635      	mov	r5, r6
    7a4a:	e7e7      	b.n	7a1c <_realloc_r+0x1c>

00007a4c <_malloc_usable_size_r>:
    7a4c:	f851 3c04 	ldr.w	r3, [r1, #-4]
    7a50:	1f18      	subs	r0, r3, #4
    7a52:	2b00      	cmp	r3, #0
    7a54:	bfbc      	itt	lt
    7a56:	580b      	ldrlt	r3, [r1, r0]
    7a58:	18c0      	addlt	r0, r0, r3
    7a5a:	4770      	bx	lr

00007a5c <_usb_ep_cfgs>:
    7a5c:	186c 2000 0000 0000 0040 0000 182c 2000     l.. ....@...,.. 
    7a6c:	0000 0000 0040 0000 17ec 2000 0000 0000     ....@...... ....
    7a7c:	0040 0000 2e2e 682f 6c61 752f 6974 736c     @...../hal/utils
    7a8c:	732f 6372 752f 6974 736c 6c5f 7369 2e74     /src/utils_list.
    7a9c:	0063 2e2e 752f 6273 642f 7665 6369 2f65     c.../usb/device/
    7aac:	7375 6462 2e63 0063 0000 0000               usbdc.c.....

00007ab8 <Hcold>:
    7ab8:	7ad5 0000 0068 2000 0400 4f43 444c 0000     .z..h.. ..COLD..
    7ac8:	0000 0000                                   ....

00007acc <Hwords>:
    7acc:	7ae9 0000 0094 2000 0500 4f57 4452 0053     .z..... ..WORDS.
    7adc:	0000 0000                                   ....

00007ae0 <Hdump>:
    7ae0:	7afd 0000 14f8 2000 0400 5544 504d 0000     .z..... ..DUMP..
    7af0:	0000 0000                                   ....

00007af4 <Hdots>:
    7af4:	7b0d 0000 14fc 2000 0200 532e 0000 0000     .{..... ...S....

00007b04 <Hdothhhh>:
    7b04:	7b21 0000 1500 2000 0500 482e 4848 0048     !{..... ...HHHH.
    7b14:	0000 0000                                   ....

00007b18 <Hdothh>:
    7b18:	7b35 0000 1504 2000 0300 482e 0048 0000     5{..... ...HH...
    7b28:	0000 0000                                   ....

00007b2c <Hmarker>:
    7b2c:	7b49 0000 00dc 2000 0600 414d 4b52 5245     I{..... ..MARKER
    7b3c:	0000 0000                                   ....

00007b40 <Henvironmentq>:
    7b40:	7b65 0000 0148 2000 0c00 4e45 4956 4f52     e{..H.. ..ENVIRO
    7b50:	4d4e 4e45 3f54 0000 0000 0000               NMENT?......

00007b5c <Hdepth>:
    7b5c:	7b79 0000 0158 2000 0500 4544 5450 0048     y{..X.. ..DEPTH.
    7b6c:	0000 0000                                   ....

00007b70 <Hmove>:
    7b70:	7b8d 0000 0178 2000 0400 4f4d 4556 0000     .{..x.. ..MOVE..
    7b80:	0000 0000                                   ....

00007b84 <Hwithin>:
    7b84:	7ba1 0000 01bc 2000 0600 4957 4854 4e49     .{..... ..WITHIN
    7b94:	0000 0000                                   ....

00007b98 <Hleave>:
    7b98:	7bb5 0000 01dc 2000 0501 454c 5641 0045     .{..... ..LEAVE.
    7ba8:	0000 0000                                   ....

00007bac <Hplusloop>:
    7bac:	7bc9 0000 0208 2000 0501 4c2b 4f4f 0050     .{..... ..+LOOP.
    7bbc:	0000 0000                                   ....

00007bc0 <Hloop>:
    7bc0:	7bdd 0000 021c 2000 0401 4f4c 504f 0000     .{..... ..LOOP..
    7bd0:	0000 0000                                   ....

00007bd4 <Hendloop>:
    7bd4:	7bf5 0000 0230 2000 0700 4e45 4c44 4f4f     .{..0.. ..ENDLOO
    7be4:	0050 0000 0000 0000                         P.......

00007bec <Hdo>:
    7bec:	7c05 0000 025c 2000 0201 4f44 0000 0000     .|..\.. ..DO....

00007bfc <Hlfrom>:
    7bfc:	7c15 0000 027c 2000 0200 3e4c 0000 0000     .|..|.. ..L>....

00007c0c <Htol>:
    7c0c:	7c25 0000 02a0 2000 0200 4c3e 0000 0000     %|..... ..>L....

00007c1c <Hrepeat>:
    7c1c:	7c39 0000 02c0 2000 0601 4552 4550 5441     9|..... ..REPEAT
    7c2c:	0000 0000                                   ....

00007c30 <Hwhile>:
    7c30:	7c4d 0000 02d0 2000 0501 4857 4c49 0045     M|..... ..WHILE.
    7c40:	0000 0000                                   ....

00007c44 <Hagain>:
    7c44:	7c61 0000 02e0 2000 0501 4741 4941 004e     a|..... ..AGAIN.
    7c54:	0000 0000                                   ....

00007c58 <Huntil>:
    7c58:	7c75 0000 02f8 2000 0501 4e55 4954 004c     u|..... ..UNTIL.
    7c68:	0000 0000                                   ....

00007c6c <Hbegin>:
    7c6c:	7c89 0000 0310 2000 0501 4542 4947 004e     .|..... ..BEGIN.
    7c7c:	0000 0000                                   ....

00007c80 <Helse>:
    7c80:	7c9d 0000 031c 2000 0401 4c45 4553 0000     .|..... ..ELSE..
    7c90:	0000 0000                                   ....

00007c94 <Hthen>:
    7c94:	7cb1 0000 0340 2000 0401 4854 4e45 0000     .|..@.. ..THEN..
    7ca4:	0000 0000                                   ....

00007ca8 <Hif>:
    7ca8:	7cc1 0000 0354 2000 0201 4649 0000 0000     .|..T.. ..IF....

00007cb8 <Hcompile>:
    7cb8:	7cd9 0000 0370 2000 0700 4f43 504d 4c49     .|..p.. ..COMPIL
    7cc8:	0045 0000 0000 0000                         E.......

00007cd0 <Hpostpone>:
    7cd0:	7cf1 0000 0390 2000 0801 4f50 5453 4f50     .|..... ..POSTPO
    7ce0:	454e 0000 0000 0000                         NE......

00007ce8 <Hbrackettick>:
    7ce8:	7d05 0000 03f0 2000 0301 275b 005d 0000     .}..... ..[']...
    7cf8:	0000 0000                                   ....

00007cfc <Hsemicolon>:
    7cfc:	7d15 0000 040c 2000 0101 003b 0000 0000     .}..... ..;.....

00007d0c <Hcolon>:
    7d0c:	7d25 0000 0420 2000 0100 003a 0000 0000     %}.. .. ..:.....

00007d1c <Himmediate>:
    7d1c:	7d3d 0000 0438 2000 0900 4d49 454d 4944     =}..8.. ..IMMEDI
    7d2c:	5441 0045 0000 0000                         ATE.....

00007d34 <Hreveal>:
    7d34:	7d51 0000 045c 2000 0600 4552 4556 4c41     Q}..\.. ..REVEAL
    7d44:	0000 0000                                   ....

00007d48 <Hhide>:
    7d48:	7d65 0000 0474 2000 0400 4948 4544 0000     e}..t.. ..HIDE..
    7d58:	0000 0000                                   ....

00007d5c <Hrightbracket>:
    7d5c:	7d75 0000 04a0 2000 0100 005d 0000 0000     u}..... ..].....

00007d6c <Hleftbracket>:
    7d6c:	7d85 0000 04b4 2000 0101 005b 0000 0000     .}..... ..[.....

00007d7c <Hrecurse>:
    7d7c:	7d9d 0000 04c8 2000 0701 4552 5543 5352     .}..... ..RECURS
    7d8c:	0045 0000 0000 0000                         E.......

00007d94 <Hdoes>:
    7d94:	7db1 0000 04e0 2000 0501 4f44 5345 003e     .}..... ..DOES>.
    7da4:	0000 0000                                   ....

00007da8 <Hxdoes>:
    7da8:	7dc9 0000 0500 2000 0700 4428 454f 3e53     .}..... ..(DOES>
    7db8:	0029 0000 0000 0000                         ).......

00007dc0 <Hcreate>:
    7dc0:	7ddd 0000 05a0 2000 0600 5243 4145 4554     .}..... ..CREATE
    7dd0:	0000 0000                                   ....

00007dd4 <Huser>:
    7dd4:	7df1 0000 0530 2000 0400 5355 5245 0000     .}..0.. ..USER..
    7de4:	0000 0000                                   ....

00007de8 <Hconstant>:
    7de8:	7e09 0000 054c 2000 0800 4f43 534e 4154     .~..L.. ..CONSTA
    7df8:	544e 0000 0000 0000                         NT......

00007e00 <Hvariable>:
    7e00:	7e21 0000 0568 2000 0800 4156 4952 4241     !~..h.. ..VARIAB
    7e10:	454c 0000 0000 0000                         LE......

00007e18 <Hbuilds>:
    7e18:	7e39 0000 0594 2000 0700 423c 4955 444c     9~..... ..<BUILD
    7e28:	0053 0000 0000 0000                         S.......

00007e30 <Hheader>:
    7e30:	7e4d 0000 05c4 2000 0600 4548 4441 5245     M~..... ..HEADER
    7e40:	0000 0000                                   ....

00007e44 <Hparen>:
    7e44:	7e5d 0000 061c 2000 0101 0028 0000 0000     ]~..... ..(.....

00007e54 <Hbracchar>:
    7e54:	7e71 0000 0634 2000 0601 435b 4148 5d52     q~..4.. ..[CHAR]
    7e64:	0000 0000                                   ....

00007e68 <Hchar>:
    7e68:	7e85 0000 0650 2000 0400 4843 5241 0000     .~..P.. ..CHAR..
    7e78:	0000 0000                                   ....

00007e7c <Htick>:
    7e7c:	7e95 0000 0668 2000 0100 0027 0000 0000     .~..h.. ..'.....

00007e8c <Habortquote>:
    7e8c:	7ea9 0000 0690 2000 0601 4241 524f 2254     .~..... ..ABORT"
    7e9c:	0000 0000                                   ....

00007ea0 <Hqabort>:
    7ea0:	7ebd 0000 06a8 2000 0600 413f 4f42 5452     .~..... ..?ABORT
    7eb0:	0000 0000                                   ....

00007eb4 <Habort>:
    7eb4:	7ed1 0000 06c8 2000 0500 4241 524f 0054     .~..... ..ABORT.
    7ec4:	0000 0000                                   ....

00007ec8 <Hquit>:
    7ec8:	7ee5 0000 06d8 2000 0400 5551 5449 0000     .~..... ..QUIT..
    7ed8:	0000 0000                                   ....

00007edc <Hevaluate>:
    7edc:	7efd 0000 0744 2000 0800 5645 4c41 4155     .~..D.. ..EVALUA
    7eec:	4554 0000 0000 0000                         TE......

00007ef4 <Hinterpret>:
    7ef4:	7f15 0000 0788 2000 0900 4e49 4554 5052     ....... ..INTERP
    7f04:	4552 0054 0000 0000                         RET.....

00007f0c <Hqnumber>:
    7f0c:	7f2d 0000 0840 2000 0700 4e3f 4d55 4542     -...@.. ..?NUMBE
    7f1c:	0052 0000 0000 0000                         R.......

00007f24 <Htonumber>:
    7f24:	7f45 0000 08a4 2000 0700 4e3e 4d55 4542     E...... ..>NUMBE
    7f34:	0052 0000 0000 0000                         R.......

00007f3c <Hqsign>:
    7f3c:	7f59 0000 0908 2000 0500 533f 4749 004e     Y...... ..?SIGN.
    7f4c:	0000 0000                                   ....

00007f50 <Hdigitq>:
    7f50:	7f6d 0000 0958 2000 0600 4944 4947 3f54     m...X.. ..DIGIT?
    7f60:	0000 0000                                   ....

00007f64 <Hliteral>:
    7f64:	7f85 0000 09bc 2000 0701 494c 4554 4152     ....... ..LITERA
    7f74:	004c 0000 0000 0000                         L.......

00007f7c <Hfind>:
    7f7c:	7f99 0000 09e4 2000 0400 4946 444e 0000     ....... ..FIND..
    7f8c:	0000 0000                                   ....

00007f90 <Himmedq>:
    7f90:	7fad 0000 0a5c 2000 0600 4d49 454d 3f44     ....\.. ..IMMED?
    7fa0:	0000 0000                                   ....

00007fa4 <Hnfatocfa>:
    7fa4:	7fc5 0000 0a74 2000 0700 464e 3e41 4643     ....t.. ..NFA>CF
    7fb4:	0041 0000 0000 0000                         A.......

00007fbc <Hnfatolfa>:
    7fbc:	7fdd 0000 0a8c 2000 0700 464e 3e41 464c     ....... ..NFA>LF
    7fcc:	0041 0000 0000 0000                         A.......

00007fd4 <Hdotquote>:
    7fd4:	7fed 0000 0aa0 2000 0201 222e 0000 0000     ....... ..."....

00007fe4 <Hsquote>:
    7fe4:	7ffd 0000 0ab8 2000 0201 2253 0000 0000     ....... ..S"....

00007ff4 <Hxsquote>:
    7ff4:	8011 0000 0ae8 2000 0400 5328 2922 0000     ....... ..(S")..
    8004:	0000 0000                                   ....

00008008 <Hword>:
    8008:	8025 0000 0b08 2000 0400 4f57 4452 0000     %...... ..WORD..
    8018:	0000 0000                                   ....

0000801c <Hparse>:
    801c:	8039 0000 0b58 2000 0500 4150 5352 0045     9...X.. ..PARSE.
    802c:	0000 0000                                   ....

00008030 <Hadrtoin>:
    8030:	804d 0000 0ba4 2000 0600 4441 3e52 4e49     M...... ..ADR>IN
    8040:	0000 0000                                   ....

00008044 <Htocounted>:
    8044:	8065 0000 0bd0 2000 0800 433e 554f 544e     e...... ..>COUNT
    8054:	4445 0000 0000 0000                         ED......

0000805c <Hslashstring>:
    805c:	807d 0000 0bec 2000 0700 532f 5254 4e49     }...... ../STRIN
    806c:	0047 0000 0000 0000                         G.......

00008074 <Hsource>:
    8074:	8091 0000 0c0c 2000 0600 4f53 5255 4543     ....... ..SOURCE
    8084:	0000 0000                                   ....

00008088 <Hhex>:
    8088:	80a5 0000 0c1c 2000 0300 4548 0058 0000     ....... ..HEX...
    8098:	0000 0000                                   ....

0000809c <Hdecimal>:
    809c:	80bd 0000 0c34 2000 0700 4544 4943 414d     ....4.. ..DECIMA
    80ac:	004c 0000 0000 0000                         L.......

000080b4 <Hdot>:
    80b4:	80cd 0000 0c4c 2000 0100 002e 0000 0000     ....L.. ........

000080c4 <Hudot>:
    80c4:	80dd 0000 0c7c 2000 0200 2e55 0000 0000     ....|.. ..U.....

000080d4 <Hsign>:
    80d4:	80f1 0000 0c9c 2000 0400 4953 4e47 0000     ....... ..SIGN..
    80e4:	0000 0000                                   ....

000080e8 <Hnumgreater>:
    80e8:	8101 0000 0cbc 2000 0200 3e23 0000 0000     ....... ..#>....

000080f8 <Hnums>:
    80f8:	8111 0000 0ce0 2000 0200 5323 0000 0000     ....... ..#S....

00008108 <Hnum>:
    8108:	8121 0000 0d00 2000 0100 0023 0000 0000     !...... ..#.....

00008118 <Htodigit>:
    8118:	8135 0000 0d20 2000 0600 443e 4749 5449     5... .. ..>DIGIT
    8128:	0000 0000                                   ....

0000812c <Hlessnum>:
    812c:	8145 0000 0d54 2000 0200 233c 0000 0000     E...T.. ..<#....

0000813c <Hhold>:
    813c:	8159 0000 0d6c 2000 0400 4f48 444c 0000     Y...l.. ..HOLD..
    814c:	0000 0000                                   ....

00008150 <Hudstar>:
    8150:	816d 0000 0d8c 2000 0300 4455 002a 0000     m...... ..UD*...
    8160:	0000 0000                                   ....

00008164 <Hudslashmod>:
    8164:	8181 0000 0db8 2000 0600 4455 4d2f 444f     ....... ..UD/MOD
    8174:	0000 0000                                   ....

00008178 <Htype>:
    8178:	8195 0000 0de4 2000 0400 5954 4550 0000     ....... ..TYPE..
    8188:	0000 0000                                   ....

0000818c <Haccept>:
    818c:	81a9 0000 0e28 2000 0600 4341 4543 5450     ....(.. ..ACCEPT
    819c:	0000 0000                                   ....

000081a0 <Hspaces>:
    81a0:	81bd 0000 0ed4 2000 0600 5053 4341 5345     ....... ..SPACES
    81b0:	0000 0000                                   ....

000081b4 <Hspace>:
    81b4:	81d1 0000 0efc 2000 0500 5053 4341 0045     ....... ..SPACE.
    81c4:	0000 0000                                   ....

000081c8 <Hcr>:
    81c8:	81e1 0000 0f10 2000 0200 5243 0000 0000     ....... ..CR....

000081d8 <Hcount>:
    81d8:	81f5 0000 0f30 2000 0500 4f43 4e55 0054     ....0.. ..COUNT.
    81e8:	0000 0000                                   ....

000081ec <Hcells>:
    81ec:	8209 0000 0f6c 2000 0500 4543 4c4c 0053     ....l.. ..CELLS.
    81fc:	0000 0000                                   ....

00008200 <Humin>:
    8200:	821d 0000 0f7c 2000 0400 4d55 4e49 0000     ....|.. ..UMIN..
    8210:	0000 0000                                   ....

00008214 <Humax>:
    8214:	8231 0000 0f9c 2000 0400 4d55 5841 0000     1...... ..UMAX..
    8224:	0000 0000                                   ....

00008228 <Hmin>:
    8228:	8245 0000 0fbc 2000 0300 494d 004e 0000     E...... ..MIN...
    8238:	0000 0000                                   ....

0000823c <Hmax>:
    823c:	8259 0000 0fdc 2000 0300 414d 0058 0000     Y...... ..MAX...
    824c:	0000 0000                                   ....

00008250 <Hstarslash>:
    8250:	8269 0000 0ffc 2000 0200 2f2a 0000 0000     i...... ..*/....

00008260 <Hstarslashmod>:
    8260:	827d 0000 100c 2000 0500 2f2a 4f4d 0044     }...... ..*/MOD.
    8270:	0000 0000                                   ....

00008274 <Hmod>:
    8274:	8291 0000 1024 2000 0300 4f4d 0044 0000     ....$.. ..MOD...
    8284:	0000 0000                                   ....

00008288 <Hslash>:
    8288:	82a1 0000 1034 2000 0100 002f 0000 0000     ....4.. ../.....

00008298 <Hslashmod>:
    8298:	82b5 0000 1044 2000 0400 4d2f 444f 0000     ....D.. ../MOD..
    82a8:	0000 0000                                   ....

000082ac <Hstar>:
    82ac:	82c5 0000 105c 2000 0100 002a 0000 0000     ....\.. ..*.....

000082bc <Hfmslashmod>:
    82bc:	82d9 0000 106c 2000 0600 4d46 4d2f 444f     ....l.. ..FM/MOD
    82cc:	0000 0000                                   ....

000082d0 <Hsmslashrem>:
    82d0:	82ed 0000 10e8 2000 0600 4d53 522f 4d45     ....... ..SM/REM
    82e0:	0000 0000                                   ....

000082e4 <Hmstar>:
    82e4:	82fd 0000 1130 2000 0200 2a4d 0000 0000     ....0.. ..M*....

000082f4 <Hdabs>:
    82f4:	8311 0000 1160 2000 0400 4144 5342 0000     ....`.. ..DABS..
    8304:	0000 0000                                   ....

00008308 <Hqdnegate>:
    8308:	8329 0000 1170 2000 0800 443f 454e 4147     )...p.. ..?DNEGA
    8318:	4554 0000 0000 0000                         TE......

00008320 <Hdnegate>:
    8320:	8341 0000 1188 2000 0700 4e44 4745 5441     A...... ..DNEGAT
    8330:	0045 0000 0000 0000                         E.......

00008338 <Habs>:
    8338:	8355 0000 11a8 2000 0300 4241 0053 0000     U...... ..ABS...
    8348:	0000 0000                                   ....

0000834c <Hqnegate>:
    834c:	836d 0000 11b8 2000 0700 4e3f 4745 5441     m...... ..?NEGAT
    835c:	0045 0000 0000 0000                         E.......

00008364 <Hstod>:
    8364:	8381 0000 11d0 2000 0300 3e53 0044 0000     ....... ..S>D...
    8374:	0000 0000                                   ....

00008378 <Htwoover>:
    8378:	8395 0000 11e0 2000 0500 4f32 4556 0052     ....... ..2OVER.
    8388:	0000 0000                                   ....

0000838c <Htwoswap>:
    838c:	83a9 0000 1200 2000 0500 5332 4157 0050     ....... ..2SWAP.
    839c:	0000 0000                                   ....

000083a0 <Htwodup>:
    83a0:	83bd 0000 1218 2000 0400 4432 5055 0000     ....... ..2DUP..
    83b0:	0000 0000                                   ....

000083b4 <Htwodrop>:
    83b4:	83d1 0000 1228 2000 0500 4432 4f52 0050     ....(.. ..2DROP.
    83c4:	0000 0000                                   ....

000083c8 <Htwostore>:
    83c8:	83e1 0000 1238 2000 0200 2132 0000 0000     ....8.. ..2!....

000083d8 <Htwofetch>:
    83d8:	83f1 0000 1254 2000 0200 4032 0000 0000     ....T.. ..2@....

000083e8 <Hcommanone>:
    83e8:	8405 0000 1270 2000 0500 4e2c 4e4f 0045     ....p.. ..,NONE.
    83f8:	0000 0000                                   ....

000083fc <Hstoredest>:
    83fc:	8419 0000 1280 2000 0500 4421 5345 0054     ....... ..!DEST.
    840c:	0000 0000                                   ....

00008410 <Hcommadest>:
    8410:	842d 0000 1298 2000 0500 442c 5345 0054     -...... ..,DEST.
    8420:	0000 0000                                   ....

00008424 <Hcommabranch>:
    8424:	8445 0000 12ac 2000 0700 422c 4152 434e     E...... ..,BRANC
    8434:	0048 0000 0000 0000                         H.......

0000843c <Hcommaexit>:
    843c:	8459 0000 12b8 2000 0500 452c 4958 0054     Y...... ..,EXIT.
    844c:	0000 0000                                   ....

00008450 <Hstorecolon>:
    8450:	846d 0000 0f48 2000 0600 4321 4c4f 4e4f     m...H.. ..!COLON
    8460:	0000 0000                                   ....

00008464 <Hcommacf>:
    8464:	8481 0000 12cc 2000 0300 432c 0046 0000     ....... ..,CF...
    8474:	0000 0000                                   ....

00008478 <Hstorecf>:
    8478:	8495 0000 12e4 2000 0300 4321 0046 0000     ....... ..!CF...
    8488:	0000 0000                                   ....

0000848c <Hcommaxt>:
    848c:	84ad 0000 12f0 2000 0800 4f43 504d 4c49     ....... ..COMPIL
    849c:	2c45 0000 0000 0000                         E,......

000084a4 <Htobody>:
    84a4:	84c1 0000 12fc 2000 0500 423e 444f 0059     ....... ..>BODY.
    84b4:	0000 0000                                   ....

000084b8 <Hcharplus>:
    84b8:	84d5 0000 1348 2000 0500 4843 5241 002b     ....H.. ..CHAR+.
    84c8:	0000 0000                                   ....

000084cc <Hcellplus>:
    84cc:	84e9 0000 1358 2000 0500 4543 4c4c 002b     ....X.. ..CELL+.
    84dc:	0000 0000                                   ....

000084e0 <Halign>:
    84e0:	84fd 0000 1368 2000 0500 4c41 4749 004e     ....h.. ..ALIGN.
    84f0:	0000 0000                                   ....

000084f4 <Haligned>:
    84f4:	8515 0000 1380 2000 0700 4c41 4749 454e     ....... ..ALIGNE
    8504:	0044 0000 0000 0000                         D.......

0000850c <Hccomma>:
    850c:	8525 0000 13a4 2000 0200 2c43 0000 0000     %...... ..C,....

0000851c <Hcomma>:
    851c:	8535 0000 13c0 2000 0100 002c 0000 0000     5...... ..,.....

0000852c <Hallot>:
    852c:	8549 0000 13d8 2000 0500 4c41 4f4c 0054     I...... ..ALLOT.
    853c:	0000 0000                                   ....

00008540 <Hhere>:
    8540:	855d 0000 13e8 2000 0400 4548 4552 0000     ]...... ..HERE..
    8550:	0000 0000                                   ....

00008554 <Hchars>:
    8554:	8571 0000 13f8 2000 0500 4843 5241 0053     q...... ..CHARS.
    8564:	0000 0000                                   ....

00008568 <Hcell>:
    8568:	8585 0000 1400 2000 0400 4543 4c4c 0000     ....... ..CELL..
    8578:	0000 0000                                   ....

0000857c <Hminusone>:
    857c:	8595 0000 1408 2000 0200 312d 0000 0000     ....... ..-1....

0000858c <Hthree>:
    858c:	85a5 0000 1410 2000 0100 0033 0000 0000     ....... ..3.....

0000859c <Htwo>:
    859c:	85b5 0000 1418 2000 0100 0032 0000 0000     ....... ..2.....

000085ac <Hone>:
    85ac:	85c5 0000 1420 2000 0100 0031 0000 0000     .... .. ..1.....

000085bc <Hzero>:
    85bc:	85d5 0000 1428 2000 0100 0030 0000 0000     ....(.. ..0.....

000085cc <Hbl>:
    85cc:	85e5 0000 1430 2000 0200 4c42 0000 0000     ....0.. ..BL....

000085dc <Htibsize>:
    85dc:	85fd 0000 1438 2000 0700 4954 5342 5a49     ....8.. ..TIBSIZ
    85ec:	0045 0000 0000 0000                         E.......

000085f4 <Htib>:
    85f4:	8611 0000 1440 2000 0300 4954 0042 0000     ....@.. ..TIB...
    8604:	0000 0000                                   ....

00008608 <Hr0>:
    8608:	8621 0000 1448 2000 0200 3052 0000 0000     !...H.. ..R0....

00008618 <Hs0>:
    8618:	8631 0000 1450 2000 0200 3053 0000 0000     1...P.. ..S0....

00008628 <Hl0>:
    8628:	8641 0000 1458 2000 0200 304c 0000 0000     A...X.. ..L0....

00008638 <Hpad>:
    8638:	8655 0000 1460 2000 0300 4150 0044 0000     U...`.. ..PAD...
    8648:	0000 0000                                   ....

0000864c <Hninit>:
    864c:	8669 0000 1468 2000 0500 4923 494e 0054     i...h.. ..#INIT.
    865c:	0000 0000                                   ....

00008660 <Huinit>:
    8660:	867d 0000 1470 2000 0500 4955 494e 0054     }...p.. ..UINIT.
    8670:	0000 0000                                   ....

00008674 <Hnewest>:
    8674:	8691 0000 14a4 2000 0600 454e 4557 5453     ....... ..NEWEST
    8684:	0000 0000                                   ....

00008688 <Hlp>:
    8688:	86a1 0000 14ac 2000 0200 504c 0000 0000     ....... ..LP....

00008698 <Hhp>:
    8698:	86b1 0000 14b4 2000 0200 5048 0000 0000     ....... ..HP....

000086a8 <Hlatest>:
    86a8:	86c5 0000 14bc 2000 0600 414c 4554 5453     ....... ..LATEST
    86b8:	0000 0000                                   ....

000086bc <Hticksource>:
    86bc:	86dd 0000 14c4 2000 0700 5327 554f 4352     ....... ..'SOURC
    86cc:	0045 0000 0000 0000                         E.......

000086d4 <Hdp>:
    86d4:	86ed 0000 14cc 2000 0200 5044 0000 0000     ....... ..DP....

000086e4 <Hstate>:
    86e4:	8701 0000 14d4 2000 0500 5453 5441 0045     ....... ..STATE.
    86f4:	0000 0000                                   ....

000086f8 <Hbase>:
    86f8:	8715 0000 14dc 2000 0400 4142 4553 0000     ....... ..BASE..
    8708:	0000 0000                                   ....

0000870c <Htoin>:
    870c:	8729 0000 14e4 2000 0300 493e 004e 0000     )...... ..>IN...
    871c:	0000 0000                                   ....

00008720 <Hu0>:
    8720:	8739 0000 14ec 2000 0200 3055 0000 0000     9...... ..U0....

00008730 <Hbye>:
    8730:	874d 0000 14f4 2000 0300 5942 0045 0000     M...... ..BYE...
    8740:	0000 0000                                   ....

00008744 <Hkeyq>:
    8744:	8761 0000 1508 2000 0400 454b 3f59 0000     a...... ..KEY?..
    8754:	0000 0000                                   ....

00008758 <Hemit>:
    8758:	8775 0000 150c 2000 0400 4d45 5449 0000     u...... ..EMIT..
    8768:	0000 0000                                   ....

0000876c <Hkey>:
    876c:	8789 0000 1510 2000 0300 454b 0059 0000     ....... ..KEY...
    877c:	0000 0000                                   ....

00008780 <Hnequal>:
    8780:	8799 0000 1514 2000 0200 3d4e 0000 0000     ....... ..N=....

00008790 <Hsequal>:
    8790:	87a9 0000 1518 2000 0200 3d53 0000 0000     ....... ..S=....

000087a0 <Hscan>:
    87a0:	87bd 0000 151c 2000 0400 4353 4e41 0000     ....... ..SCAN..
    87b0:	0000 0000                                   ....

000087b4 <Hskip>:
    87b4:	87d1 0000 1520 2000 0400 4b53 5049 0000     .... .. ..SKIP..
    87c4:	0000 0000                                   ....

000087c8 <Hitod>:
    87c8:	87e5 0000 1524 2000 0400 2d49 443e 0000     ....$.. ..I->D..
    87d8:	0000 0000                                   ....

000087dc <Hcmoveup>:
    87dc:	87f9 0000 1528 2000 0600 4d43 564f 3e45     ....(.. ..CMOVE>
    87ec:	0000 0000                                   ....

000087f0 <Hcmove>:
    87f0:	880d 0000 152c 2000 0500 4d43 564f 0045     ....,.. ..CMOVE.
    8800:	0000 0000                                   ....

00008804 <Hfill>:
    8804:	8821 0000 1530 2000 0400 4946 4c4c 0000     !...0.. ..FILL..
    8814:	0000 0000                                   ....

00008818 <Humslashmod>:
    8818:	8835 0000 1534 2000 0600 4d55 4d2f 444f     5...4.. ..UM/MOD
    8828:	0000 0000                                   ....

0000882c <Humstar>:
    882c:	8849 0000 1538 2000 0300 4d55 002a 0000     I...8.. ..UM*...
    883c:	0000 0000                                   ....

00008840 <Hunloop>:
    8840:	885d 0000 153c 2000 0600 4e55 4f4c 504f     ]...<.. ..UNLOOP
    8850:	0000 0000                                   ....

00008854 <Hj>:
    8854:	886d 0000 1540 2000 0100 004a 0000 0000     m...@.. ..J.....

00008864 <Hi>:
    8864:	887d 0000 1544 2000 0100 0049 0000 0000     }...D.. ..I.....

00008874 <Hxdo>:
    8874:	8891 0000 1548 2000 0400 6428 296f 0000     ....H.. ..(do)..
    8884:	0000 0000                                   ....

00008888 <Hxloop>:
    8888:	88a5 0000 154c 2000 0600 6c28 6f6f 2970     ....L.. ..(loop)
    8898:	0000 0000                                   ....

0000889c <Hxplusloop>:
    889c:	88bd 0000 1550 2000 0700 2b28 6f6c 706f     ....P.. ..(+loop
    88ac:	0029 0000 0000 0000                         ).......

000088b4 <Hqbranch>:
    88b4:	88d5 0000 1554 2000 0700 623f 6172 636e     ....T.. ..?branc
    88c4:	0068 0000 0000 0000                         h.......

000088cc <Hbranch>:
    88cc:	88e9 0000 1558 2000 0600 7262 6e61 6863     ....X.. ..branch
    88dc:	0000 0000                                   ....

000088e0 <Hugreater>:
    88e0:	88f9 0000 155c 2000 0200 3e55 0000 0000     ....\.. ..U>....

000088f0 <Huless>:
    88f0:	8909 0000 1560 2000 0200 3c55 0000 0000     ....`.. ..U<....

00008900 <Hgreater>:
    8900:	8919 0000 1564 2000 0100 003e 0000 0000     ....d.. ..>.....

00008910 <Hless>:
    8910:	8929 0000 1568 2000 0100 003c 0000 0000     )...h.. ..<.....

00008920 <Hnotequal>:
    8920:	8939 0000 156c 2000 0200 3e3c 0000 0000     9...l.. ..<>....

00008930 <Hequal>:
    8930:	8949 0000 1570 2000 0100 003d 0000 0000     I...p.. ..=.....

00008940 <Hzeroless>:
    8940:	8959 0000 1574 2000 0200 3c30 0000 0000     Y...t.. ..0<....

00008950 <Hzeroequal>:
    8950:	8969 0000 1578 2000 0200 3d30 0000 0000     i...x.. ..0=....

00008960 <Hrshift>:
    8960:	897d 0000 157c 2000 0600 5352 4948 5446     }...|.. ..RSHIFT
    8970:	0000 0000                                   ....

00008974 <Hlshift>:
    8974:	8991 0000 1580 2000 0600 534c 4948 5446     ....... ..LSHIFT
    8984:	0000 0000                                   ....

00008988 <Htwoslash>:
    8988:	89a1 0000 1584 2000 0200 2f32 0000 0000     ....... ..2/....

00008998 <Htwostar>:
    8998:	89b1 0000 1588 2000 0200 2a32 0000 0000     ....... ..2*....

000089a8 <Hswapbytes>:
    89a8:	89c1 0000 158c 2000 0200 3c3e 0000 0000     ....... ..><....

000089b8 <Honeminus>:
    89b8:	89d1 0000 1590 2000 0200 2d31 0000 0000     ....... ..1-....

000089c8 <Honeplus>:
    89c8:	89e1 0000 1594 2000 0200 2b31 0000 0000     ....... ..1+....

000089d8 <Hnegate>:
    89d8:	89f5 0000 1598 2000 0600 454e 4147 4554     ....... ..NEGATE
    89e8:	0000 0000                                   ....

000089ec <Hinvert>:
    89ec:	8a09 0000 159c 2000 0600 4e49 4556 5452     ....... ..INVERT
    89fc:	0000 0000                                   ....

00008a00 <Hxor>:
    8a00:	8a1d 0000 15a0 2000 0300 4f58 0052 0000     ....... ..XOR...
    8a10:	0000 0000                                   ....

00008a14 <Hor>:
    8a14:	8a2d 0000 15a4 2000 0200 524f 0000 0000     -...... ..OR....

00008a24 <Hand>:
    8a24:	8a41 0000 15a8 2000 0300 4e41 0044 0000     A...... ..AND...
    8a34:	0000 0000                                   ....

00008a38 <Hdiv>:
    8a38:	8a51 0000 15ac 2000 0100 002f 0000 0000     Q...... ../.....

00008a48 <Hmult>:
    8a48:	8a61 0000 15b0 2000 0100 002a 0000 0000     a...... ..*.....

00008a58 <Hminus>:
    8a58:	8a71 0000 15b4 2000 0100 002d 0000 0000     q...... ..-.....

00008a68 <Hmplus>:
    8a68:	8a81 0000 15b8 2000 0200 2b4d 0000 0000     ....... ..M+....

00008a78 <Hplusstore>:
    8a78:	8a91 0000 15bc 2000 0200 212b 0000 0000     ....... ..+!....

00008a88 <Hplus>:
    8a88:	8aa1 0000 15c0 2000 0100 002b 0000 0000     ....... ..+.....

00008a98 <Hhcstore>:
    8a98:	8ab5 0000 15c4 2000 0300 4348 0021 0000     ....... ..HC!...
    8aa8:	0000 0000                                   ....

00008aac <Hhcfetch>:
    8aac:	8ac9 0000 15c8 2000 0300 4348 0040 0000     ....... ..HC@...
    8abc:	0000 0000                                   ....

00008ac0 <Hhstore>:
    8ac0:	8ad9 0000 15cc 2000 0200 2148 0000 0000     ....... ..H!....

00008ad0 <Hhfetch>:
    8ad0:	8ae9 0000 15d0 2000 0200 4048 0000 0000     ....... ..H@....

00008ae0 <Hicstore>:
    8ae0:	8afd 0000 15c4 2000 0300 4349 0021 0000     ....... ..IC!...
    8af0:	0000 0000                                   ....

00008af4 <Hicfetch>:
    8af4:	8b11 0000 15c8 2000 0300 4349 0040 0000     ....... ..IC@...
    8b04:	0000 0000                                   ....

00008b08 <Histore>:
    8b08:	8b21 0000 15cc 2000 0200 2149 0000 0000     !...... ..I!....

00008b18 <Hifetch>:
    8b18:	8b31 0000 15d0 2000 0200 4049 0000 0000     1...... ..I@....

00008b28 <Hcstore>:
    8b28:	8b41 0000 15c4 2000 0200 2143 0000 0000     A...... ..C!....

00008b38 <Hcfetch>:
    8b38:	8b51 0000 15c8 2000 0200 4043 0000 0000     Q...... ..C@....

00008b48 <Hstore>:
    8b48:	8b61 0000 15cc 2000 0100 0021 0000 0000     a...... ..!.....

00008b58 <Hfetch>:
    8b58:	8b71 0000 15d0 2000 0100 0040 0000 0000     q...... ..@.....

00008b68 <Hrpstore>:
    8b68:	8b85 0000 15d4 2000 0300 5052 0021 0000     ....... ..RP!...
    8b78:	0000 0000                                   ....

00008b7c <Hrpfetch>:
    8b7c:	8b99 0000 15d8 2000 0300 5052 0040 0000     ....... ..RP@...
    8b8c:	0000 0000                                   ....

00008b90 <Hspstore>:
    8b90:	8bad 0000 15dc 2000 0300 5053 0021 0000     ....... ..SP!...
    8ba0:	0000 0000                                   ....

00008ba4 <Hspfetch>:
    8ba4:	8bc1 0000 15e0 2000 0300 5053 0040 0000     ....... ..SP@...
    8bb4:	0000 0000                                   ....

00008bb8 <Hrfetch>:
    8bb8:	8bd1 0000 15e4 2000 0200 4052 0000 0000     ....... ..R@....

00008bc8 <Hrfrom>:
    8bc8:	8be1 0000 15e8 2000 0200 3e52 0000 0000     ....... ..R>....

00008bd8 <Htor>:
    8bd8:	8bf1 0000 15ec 2000 0200 523e 0000 0000     ....... ..>R....

00008be8 <Htuck>:
    8be8:	8c05 0000 15f0 2000 0400 5554 4b43 0000     ....... ..TUCK..
    8bf8:	0000 0000                                   ....

00008bfc <Hnip>:
    8bfc:	8c19 0000 15f4 2000 0300 494e 0050 0000     ....... ..NIP...
    8c0c:	0000 0000                                   ....

00008c10 <Hrot>:
    8c10:	8c2d 0000 15f8 2000 0300 4f52 0054 0000     -...... ..ROT...
    8c20:	0000 0000                                   ....

00008c24 <Hover>:
    8c24:	8c41 0000 15fc 2000 0400 564f 5245 0000     A...... ..OVER..
    8c34:	0000 0000                                   ....

00008c38 <Hswap>:
    8c38:	8c55 0000 1600 2000 0400 5753 5041 0000     U...... ..SWAP..
    8c48:	0000 0000                                   ....

00008c4c <Hdrop>:
    8c4c:	8c69 0000 1604 2000 0400 5244 504f 0000     i...... ..DROP..
    8c5c:	0000 0000                                   ....

00008c60 <Hqdup>:
    8c60:	8c7d 0000 1608 2000 0400 443f 5055 0000     }...... ..?DUP..
    8c70:	0000 0000                                   ....

00008c74 <Hdup>:
    8c74:	8c91 0000 160c 2000 0300 5544 0050 0000     ....... ..DUP...
    8c84:	0000 0000                                   ....

00008c88 <Hlit>:
    8c88:	8ca5 0000 1610 2000 0300 696c 0074 0000     ....... ..lit...
    8c98:	0000 0000                                   ....

00008c9c <Hexecute>:
    8c9c:	8cbd 0000 1614 2000 0700 5845 4345 5455     ....... ..EXECUT
    8cac:	0045 0000 0000 0000                         E.......

00008cb4 <Hexit>:
    8cb4:	0000 0000 1618 2000 0400 5845 5449 0000     ....... ..EXIT..
	...

00008cc6 <coldprompt>:
    8cc6:	4322 6d61 6c65 6f46 7472 2068 6e69 4320     "CamelForth in C
    8cd6:	7620 2e30 2031 202d 3431 4620 6265 3220      v0.1 - 14 Feb 2
    8ce6:	3130 0036                                   016.

00008cea <huhprompt>:
    8cea:	3f01                                         .?.

00008ced <okprompt>:
    8ced:	6f03 206b 2000 3225 0078 2520 7838 0a00     .ok . %2x. %8x..
    8cfd:	3825 3a78 2000 3025 7832 2000 6425 0a00     %8x:. %02x. %d..
    8d0d:	630a 6d61 6c65 6f66 7472 2868 0a29 000a     .camelforth()...
    8d1d:	0000                                         ...

00008d20 <__sf_fake_stderr>:
	...

00008d40 <__sf_fake_stdin>:
	...

00008d60 <__sf_fake_stdout>:
	...
    8d80:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
    8d90:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
    8da0:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
    8db0:	6665 0000                                   ef..

00008db4 <_init>:
    8db4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8db6:	bf00      	nop
    8db8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8dba:	bc08      	pop	{r3}
    8dbc:	469e      	mov	lr, r3
    8dbe:	4770      	bx	lr

00008dc0 <__init_array_start>:
    8dc0:	00004289 	.word	0x00004289

00008dc4 <_fini>:
    8dc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8dc6:	bf00      	nop
    8dc8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8dca:	bc08      	pop	{r3}
    8dcc:	469e      	mov	lr, r3
    8dce:	4770      	bx	lr

00008dd0 <__fini_array_start>:
    8dd0:	00004265 	.word	0x00004265
